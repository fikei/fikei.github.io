<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Soundscape — Audio-Reactive Wave Visualization</title>
    <meta name="description" content="Real-time audio visualization using simplex-noise wave grid that reacts to microphone input">
    <link rel="icon" type="image/png" href="https://cdn.glitch.me/597fe374-3d18-46a5-b99c-ceff1f8ffd79%2Ffavicon.png"/>

    <!-- Space Grotesk Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">

    <!-- Socket.io for WebSocket communication -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

    <!-- Meyda Audio Analysis Library -->
    <script src="https://unpkg.com/meyda@5.6.0/dist/web/meyda.min.js"></script>

    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', monospace;
            font-size: 10px;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* ===== SVG VISUALIZATION CONTAINER ===== */
        #visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #wave-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-screen h1 {
            font-size: 10px;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #ffffff;
        }

        .loading-screen p {
            display: none;
        }

        .loading-spinner {
            margin-top: 1rem;
            width: 20px;
            height: 20px;
            border: 1px solid #333333;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== STATUS INDICATOR ===== */
        .status-bar {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 20;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #ffffff;
            font-size: 10px;
            display: none;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 1;
            transition: opacity 0.5s ease;
            cursor: auto;
        }

        .status-bar.active {
            display: flex;
        }

        .status-bar.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            background: #ffffff;
            animation: blink 1s step-start infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        /* ===== PAIRING PANEL ===== */
        .pairing-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pairing-content {
            background: #000000;
            border: 1px solid #ffffff;
            padding: 3rem 2rem;
            text-align: center;
            min-width: 350px;
        }

        .pairing-content h3 {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
        }

        .pairing-instruction {
            font-size: 10px;
            color: #999999;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pairing-url {
            font-family: monospace;
            font-size: 12px;
            color: #ffffff;
            margin-bottom: 2rem;
            padding: 0.75rem;
            background: #111111;
            border: 1px solid #333333;
        }

        .pairing-code {
            font-family: monospace;
            font-size: 48px;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: #ffffff;
            margin-bottom: 2rem;
            padding: 1rem;
            border: 2px solid #ffffff;
        }

        .pairing-close {
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.75rem 2rem;
            font-size: 10px;
            font-family: monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.15s ease;
        }

        .pairing-close:hover {
            background: #ffffff;
            color: #000000;
        }

        /* Pairing Code Display (Bottom Left, next to fullscreen button) */
        .pairing-code-display {
            position: fixed;
            bottom: 1rem;
            left: calc(30px + 1rem + 0.5rem); /* To the right of fullscreen button */
            z-index: 101;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            padding: 0 0.75rem;
            font-family: monospace;
            font-size: 10px;
            color: #ffffff;
            letter-spacing: 0.2em;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .pairing-code-display:hover {
            background: #ffffff;
            color: #000000;
        }

        .pairing-code-display.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        /* ===== SIDEBAR TOGGLE BUTTON ===== */
        .sidebar-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease, right 0.2s ease;
        }

        .sidebar-toggle .caret {
            display: inline-block;
            transition: transform 0.2s ease;
        }

        .sidebar-toggle:hover {
            background: #ffffff;
            color: #000000;
        }

        .sidebar-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .sidebar-toggle.sidebar-is-open {
            right: calc(200px + 1rem); /* Float to left of sidebar */
        }

        .sidebar-toggle.sidebar-is-open .caret {
            transform: rotate(180deg); /* Flip caret to point left */
        }

        /* ===== FULLSCREEN TOGGLE BUTTON ===== */
        .fullscreen-toggle {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease;
        }

        .fullscreen-toggle:hover {
            background: #ffffff;
            color: #000000;
        }

        .fullscreen-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        /* ===== ADD IMAGE BUTTON & DROPDOWN ===== */
        .add-image-button {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease, right 0.2s ease;
        }

        .add-image-button:hover {
            background: #ffffff;
            color: #000000;
        }

        .add-image-button.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .add-image-button.sidebar-is-open {
            right: calc(200px + 1rem); /* Float to left of sidebar */
        }

        body.hide-cursor {
            cursor: none !important;
        }

        body.hide-cursor * {
            cursor: none !important;
        }

        .add-image-dropdown {
            position: fixed;
            bottom: 3rem;
            right: 1rem;
            z-index: 100;
            background: #000000;
            border: 1px solid #ffffff;
            display: none;
            min-width: 120px;
            transition: right 0.2s ease;
        }

        .add-image-dropdown.show {
            display: block;
        }

        .add-image-dropdown.sidebar-is-open {
            right: calc(200px + 1rem);
        }

        .add-image-dropdown-item {
            padding: 0.5rem 1rem;
            font-size: 10px;
            color: #ffffff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background 0.15s ease;
        }

        .add-image-dropdown-item:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== VIDEO POPUP ===== */
        .video-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-popup-content {
            background: #000000;
            border: 1px solid #ffffff;
            padding: 2rem;
            min-width: 300px;
            max-width: 500px;
        }

        .video-popup-content h3 {
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 1.5rem;
        }

        .video-popup-content input[type="text"] {
            width: 100%;
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.75rem;
            font-size: 10px;
            font-family: monospace;
            margin-bottom: 1.5rem;
            outline: none;
        }

        .video-popup-content input[type="text"]:focus {
            border-color: #999999;
        }

        .video-popup-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .video-popup-buttons button {
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.5rem 1.5rem;
            font-size: 10px;
            font-family: monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.15s ease;
        }

        .video-popup-buttons button:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== CONTROLS SIDEBAR ===== */
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100vh;
            background: #000000;
            border-left: 1px solid #ffffff;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            overflow-y: auto;
            padding: 1rem;
            cursor: auto;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar h2 {
            font-size: 10px;
            margin-bottom: 2rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
            border-top: 1px solid #333333;
            padding-top: 1rem;
        }

        .control-section h3 {
            font-size: 10px;
            font-weight: 400;
            margin-bottom: 1rem;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 10px;
            color: #999999;
        }

        .control-value {
            color: #ffffff;
            font-weight: 400;
        }

        /* Range Sliders */
        input[type="range"] {
            width: 100%;
            height: 1px;
            background: #333333;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #000000;
        }

        input[type="range"]::-moz-range-thumb {
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        /* Checkboxes */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 10px;
            color: #999999;
        }

        input[type="checkbox"] {
            width: 12px;
            height: 12px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid #ffffff;
            background: #000000;
        }

        input[type="checkbox"]:checked {
            background: #ffffff;
        }

        input[type="checkbox"]:hover {
            border-color: #999999;
        }

        /* Gradient Presets Grid */
        .gradient-grid {
            display: none;
        }

        /* Grid Density Controls */
        .density-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .density-option {
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .density-option:hover {
            border-color: #ffffff;
        }

        .density-option.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
        }

        /* Theme Dropdown */
        .theme-select {
            width: 100%;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            color: #ffffff;
            font-size: 10px;
            font-family: 'Space Grotesk', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }

        .theme-select:hover {
            border-color: #ffffff;
        }

        .theme-select:focus {
            outline: none;
            border-color: #ffffff;
        }

        /* ===== UNIFIED CONTROL SYSTEM ===== */

        /* Category Sections */
        .control-category {
            margin-bottom: 1.5rem;
        }

        .category-header {
            font-size: 9px;
            font-weight: 700;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #222222;
        }

        .category-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Audio Controls */
        .audio-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 0.5rem;
            border-left: 1px solid #222222;
        }

        .audio-source-dropdown {
            width: 100%;
            padding: 0.4rem;
            background: #000000;
            border: 1px solid #333333;
            color: #999999;
            font-size: 9px;
            font-family: 'Space Grotesk', monospace;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }

        .audio-source-dropdown:hover {
            border-color: #ffffff;
            color: #ffffff;
        }

        .audio-source-dropdown:focus {
            outline: none;
            border-color: #ffffff;
            color: #ffffff;
        }

        .audio-source-dropdown option:disabled {
            color: #666666;
            font-weight: 700;
            background: #000000;
        }

        /* Intensity Controls */
        .intensity-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 9px;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .intensity-slider {
            flex: 1;
            height: 1px;
            background: #222222;
        }

        .intensity-value {
            min-width: 3rem;
            text-align: right;
            color: #ffffff;
            font-size: 9px;
        }

        /* Mode Select (buttonGroup alternative to dropdown) */
        .mode-select {
            width: 100%;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            color: #ffffff;
            font-size: 10px;
            font-family: 'Space Grotesk', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }

        .mode-select:hover {
            border-color: #ffffff;
        }

        .mode-select:focus {
            outline: none;
            border-color: #ffffff;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.5rem;
            font-size: 10px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-reset {
            background: #000000;
            border: 1px solid #ffffff;
            color: white;
            margin-top: 1.5rem;
        }

        .btn-reset:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== ERROR SCREEN ===== */
        .error-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 2rem;
            background: #000000;
            border: 1px solid #ffffff;
            text-align: center;
            max-width: 300px;
            display: none;
        }

        .error-screen.show {
            display: block;
        }

        .error-screen h2 {
            color: #ffffff;
            margin-bottom: 1rem;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .error-screen p {
            color: #999999;
            line-height: 1.4;
            font-size: 10px;
        }

        /* ===== SCROLLBAR STYLING ===== */
        .sidebar::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #000000;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #333333;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #ffffff;
        }

        /* ===== TOAST NOTIFICATIONS ===== */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.95);
            color: white;
            padding: 1rem 2rem;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-width: 80%;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.success {
            background: rgba(100, 255, 100, 0.95);
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- SVG Visualization Container -->
    <div id="visualization-container">
        <svg id="wave-svg" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Neon glow filter -->
                <filter id="neon-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur1"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur2"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur3"/>
                    <feMerge>
                        <feMergeNode in="blur3"/>
                        <feMergeNode in="blur2"/>
                        <feMergeNode in="blur1"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        </svg>
        <!-- Canvas for theme images -->
        <canvas id="theme-canvas" style="display: none; position: absolute; cursor: grab;"></canvas>
        <!-- Upload overlay (GLITCH only) -->
        <div id="upload-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10; cursor: pointer; align-items: center; justify-content: center;">
            <div style="text-align: center;">
                <p id="upload-text" style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload Image...</p>
            </div>
        </div>
        <!-- Drag overlay for GLITCH theme -->
        <div id="drag-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 15; pointer-events: none; align-items: center; justify-content: center; border: 3px dashed #ffffff; box-sizing: border-box;">
            <div style="text-align: center;">
                <p style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload</p>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1>SOUNDSCAPE</h1>
        <div class="loading-spinner"></div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
        <div class="status-indicator"></div>
        <span>activ</span>
    </div>

    <!-- Pairing Code Display -->
    <div class="pairing-panel" id="pairingPanel" style="display: none;">
        <div class="pairing-content">
            <h3>COMPANION CONTROL</h3>
            <p class="pairing-instruction">Open on companion device:</p>
            <p class="pairing-url" id="pairingUrl">Loading...</p>
            <p class="pairing-instruction">Enter code:</p>
            <div class="pairing-code" id="pairingCode">------</div>
            <button class="pairing-close" id="pairingClose">CLOSE</button>
        </div>
    </div>

    <!-- Pairing Code Display -->
    <div class="pairing-code-display" id="pairingCodeDisplay">
        <span id="pairingCodeValue">------</span>
    </div>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle controls"><span class="caret">›</span></button>

    <!-- Fullscreen Toggle -->
    <button class="fullscreen-toggle" id="fullscreenToggle" aria-label="Toggle fullscreen">⛶</button>

    <!-- Add Media Button & Dropdown -->
    <button class="add-image-button" id="addImageButton" aria-label="Add media">+</button>
    <div class="add-image-dropdown" id="addImageDropdown">
        <div class="add-image-dropdown-item" id="addMediaMenuItem">Add Media</div>
        <div class="add-image-dropdown-item" id="saveCanvasMenuItem" style="display: none;">Save Canvas</div>
        <div class="add-image-dropdown-item" id="loadCanvasMenuItem" style="display: none;">Load Canvas</div>
    </div>

    <!-- Unified Media Upload Popup -->
    <div class="video-popup" id="mediaPopup" style="display: none;">
        <div class="video-popup-content">
            <h3 id="mediaPopupTitle">ADD MEDIA</h3>
            <input type="text" id="mediaUrlInput" placeholder="Enter media URL (direct image or video file)" />
            <p style="text-align: center; margin: 0.5rem 0; font-size: 8px; color: #999; text-transform: uppercase;">Or <a href="#" id="mediaBrowseLink" style="color: #fff; text-decoration: underline; cursor: pointer;">browse</a> from desktop</p>
            <div class="video-popup-buttons">
                <button id="mediaPopupAdd">ADD</button>
                <button id="mediaPopupCancel">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="loadCanvasInput" accept=".json" style="display: none;">
    <input type="file" id="mediaFileInput" accept="image/*,video/*" style="display: none;">

    <!-- Controls Sidebar -->
    <aside class="sidebar" id="sidebar">
        <h2>CTRL</h2>

        <!-- Image Controls (visible when image is selected) -->
        <section class="control-section" id="imageControlsSection" style="display: none;">
            <h3>EFFECT</h3>
            <select class="theme-select" id="imageThemeSelect">
                <option value="none">NONE</option>
                <option value="linear">LINEAR</option>
                <option value="neon">NEON</option>
                <option value="glitch">GLITCH</option>
            </select>

            <h3 style="margin-top: 2rem;">IMAGE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>TRANSPARENCY</span>
                    <span class="control-value" id="imageTransparencyValue">1.0</span>
                </div>
                <input type="range" id="imageTransparencySlider" min="0" max="1" step="0.05" value="1">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>ROTATION</span>
                    <span class="control-value" id="imageRotationValue">0</span>
                </div>
                <input type="range" id="imageRotationSlider" min="0" max="360" step="1" value="0">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>BLUR</span>
                    <span class="control-value" id="imageBlurValue">0</span>
                </div>
                <input type="range" id="imageBlurSlider" min="0" max="20" step="0.5" value="0">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>3D MOTION</span>
                    <span class="control-value" id="image3DMotionValue">0.0</span>
                </div>
                <input type="range" id="image3DMotionSlider" min="0" max="2" step="0.1" value="0">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>SCALE</span>
                    <span class="control-value" id="imageScaleValue">1.0x</span>
                </div>
                <input type="range" id="imageScaleSlider" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>

            <h3 style="margin-top: 2rem;">FLASH EFFECT</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQUENCY FLASH</span>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="flashFrequencyCheck">
                    <span>Enable</span>
                </label>
            </div>
            <div class="control-group" id="flashFrequencySliderGroup" style="display: none;">
                <div class="control-label">
                    <span>FREQ THRESHOLD</span>
                    <span class="control-value" id="flashFrequencyValue">0.5</span>
                </div>
                <input type="range" id="flashFrequencySlider" min="0" max="1" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>VOLUME FLASH</span>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="flashVolumeCheck">
                    <span>Enable</span>
                </label>
            </div>
            <div class="control-group" id="flashVolumeSliderGroup" style="display: none;">
                <div class="control-label">
                    <span>VOL THRESHOLD</span>
                    <span class="control-value" id="flashVolumeValue">0.5</span>
                </div>
                <input type="range" id="flashVolumeSlider" min="0" max="1" step="0.05" value="0.5">
            </div>

            <!-- Video Controls (visible only for videos) -->
            <div id="videoControlsSection" style="display: none;">
                <h3 style="margin-top: 2rem;">VIDEO</h3>
                <div class="control-group">
                    <div class="control-label">
                        <span>LOOP</span>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="videoLoopCheck">
                        <span>Enable</span>
                    </label>
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>TRIM START</span>
                        <span class="control-value" id="videoTrimStartValue">0.0s</span>
                    </div>
                    <input type="range" id="videoTrimStartSlider" min="0" max="100" step="0.1" value="0">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>TRIM END</span>
                        <span class="control-value" id="videoTrimEndValue">0.0s</span>
                    </div>
                    <input type="range" id="videoTrimEndSlider" min="0" max="100" step="0.1" value="100">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>PLAYBACK SPEED</span>
                        <span class="control-value" id="videoSpeedValue">1.0x</span>
                    </div>
                    <input type="range" id="videoSpeedSlider" min="0.25" max="4.0" step="0.25" value="1.0">
                </div>
            </div>

            <!-- GLITCH Background Image Controls (visible only when GLITCH theme active and image loaded as background) -->
            <div id="glitchBackgroundControls" style="display: none;">
                <h3 style="margin-top: 2rem;">GLITCH BACKGROUND</h3>
                <div class="control-group">
                    <div class="control-label">
                        <span>FIT MODE</span>
                    </div>
                    <select class="theme-select" id="glitchFitModeSelect">
                        <option value="cover">COVER (Fill, May Crop)</option>
                        <option value="contain">CONTAIN (Fit All, Letterbox)</option>
                        <option value="fill">FILL (Stretch to Fit)</option>
                        <option value="manual">MANUAL (Custom)</option>
                    </select>
                </div>

                <div class="control-group" id="glitchScaleGroup">
                    <div class="control-label">
                        <span>SCALE</span>
                        <span class="control-value" id="glitchScaleValue">1.0x</span>
                    </div>
                    <input type="range" id="glitchScaleSlider" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>

                <div class="control-group" id="glitchXGroup">
                    <div class="control-label">
                        <span>X POSITION</span>
                        <span class="control-value" id="glitchXValue">0</span>
                    </div>
                    <input type="range" id="glitchXSlider" min="-1000" max="1000" step="10" value="0">
                </div>

                <div class="control-group" id="glitchYGroup">
                    <div class="control-label">
                        <span>Y POSITION</span>
                        <span class="control-value" id="glitchYValue">0</span>
                    </div>
                    <input type="range" id="glitchYSlider" min="-1000" max="1000" step="10" value="0">
                </div>

                <button class="btn" id="glitchResetBtn" style="margin-top: 1rem; width: 100%;">RESET TO CENTER</button>
            </div>

            <div id="imageEffectSettings">
                <h3 style="margin-top: 2rem;">EFFECT SETTINGS</h3>
                <div class="control-group">
                <div class="control-label">
                    <span>THEME OPACITY</span>
                    <span class="control-value" id="themeOpacityValue">1.0</span>
                </div>
                <input type="range" id="themeOpacitySlider" min="0" max="1" step="0.05" value="1">
            </div>

            <!-- Frequency Emphasis (for image theme) -->
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ LOW</span>
                    <span class="control-value" id="imageLowValue">1.0</span>
                </div>
                <input type="range" id="imageLowEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ MID</span>
                    <span class="control-value" id="imageMidValue">1.0</span>
                </div>
                <input type="range" id="imageMidEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ HIGH</span>
                    <span class="control-value" id="imageHighValue">1.0</span>
                </div>
                <input type="range" id="imageHighEmphasis" min="0" max="3" step="0.1" value="1">
            </div>

            <!-- Wave Settings (for image theme) -->
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE INTENSITY</span>
                    <span class="control-value" id="imageIntensityValue">2.5</span>
                </div>
                <input type="range" id="imageIntensitySlider" min="0" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE SPEED</span>
                    <span class="control-value" id="imageSpeedValue">1.0</span>
                </div>
                <input type="range" id="imageSpeedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE SMOOTHING</span>
                    <span class="control-value" id="imageSmoothingValue">0.3</span>
                </div>
                <input type="range" id="imageSmoothingSlider" min="0" max="1" step="0.1" value="0.3">
            </div>

                <!-- Density (for image theme) -->
                <div class="control-label" style="margin-top: 1rem;">
                    <span>DENSITY</span>
                </div>
                <div class="density-options">
                    <div class="density-option" data-image-density="low">L</div>
                    <div class="density-option active" data-image-density="medium">M</div>
                    <div class="density-option" data-image-density="high">H</div>
                </div>
            </div>
        </section>

        <!-- Background Controls (visible when no image selected) -->
        <section class="control-section" id="backgroundControlsSection">
            <h3>BACKGROUND THEME</h3>
            <select class="theme-select" id="themeSelect">
                <option value="linear">LINEAR</option>
                <option value="neon">NEON</option>
                <option value="glitch">GLITCH</option>
                <option value="stars">STARS</option>
                <option value="wave">WAVE</option>
            </select>
            <div id="themeDescription" style="margin-top: 0.5rem; font-size: 8px; color: white; font-family: 'Space Grotesk', monospace; line-height: 1.4;"></div>
        </section>

        <!-- Dynamic Theme Controls (Generated by Control System) -->
        <div id="dynamicControlsContainer"></div>

        <!-- Mode Selection (LINEAR theme only) - REPLACED BY UNIFIED CONTROL SYSTEM -->
        <section class="control-section" id="modeSection" style="display: none;">
            <h3>MODE</h3>
            <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                <div class="density-option active" data-mode="default">FLOW</div>
                <div class="density-option" data-mode="hole">HOLE</div>
                <div class="density-option" data-mode="crunch">CRUNCH</div>
            </div>
        </section>

        <!-- NEON Theme Controls -->
        <section class="control-section" id="neonControlsSection" style="display: none;">
            <h3>NEON</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>COLOR MODE</span>
                </div>
                <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="density-option active" data-neon-mode="bright">BRIGHT</div>
                    <div class="density-option" data-neon-mode="gray">GRAY</div>
                    <div class="density-option" data-neon-mode="pastel">PASTEL</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WARM/COOL</span>
                    <span class="control-value" id="colorTempValue">1.0</span>
                </div>
                <input type="range" id="colorTempSlider" min="0" max="2.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- GLITCH Theme Controls -->
        <section class="control-section" id="glitchControlsSection" style="display: none;">
            <h3>GLITCH</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>MODE</span>
                </div>
                <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="density-option active" data-glitch-mode="rgb">RGB</div>
                    <div class="density-option" data-glitch-mode="br">B&R</div>
                    <div class="density-option" data-glitch-mode="gray">GRAY</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>ROTATION</span>
                    <span class="control-value" id="rotationIntensityValue">1.0</span>
                </div>
                <input type="range" id="rotationIntensitySlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>GLITCH</span>
                    <span class="control-value" id="glitchIntensityValue">1.0</span>
                </div>
                <input type="range" id="glitchIntensitySlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>CONTRAST</span>
                    <span class="control-value" id="glitchContrastValue">1.0</span>
                </div>
                <input type="range" id="glitchContrastSlider" min="0" max="3.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- STARS Theme Controls -->
        <section class="control-section" id="starsControlsSection" style="display: none;">
            <h3>STARS</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>HUE</span>
                    <span class="control-value" id="starHueValue">44°</span>
                </div>
                <input type="range" id="starHueSlider" min="0" max="360" step="1" value="44">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SATURATION</span>
                    <span class="control-value" id="starSaturationValue">12%</span>
                </div>
                <input type="range" id="starSaturationSlider" min="0" max="100" step="1" value="12">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>BASE SPEED</span>
                    <span class="control-value" id="starSpeedValue">1.0</span>
                </div>
                <input type="range" id="starSpeedSlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>STAR COUNT</span>
                    <span class="control-value" id="starCountValue">1200</span>
                </div>
                <input type="range" id="starCountSlider" min="100" max="2000" step="100" value="1200">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>BRIGHTNESS</span>
                    <span class="control-value" id="starBrightnessValue">0.8</span>
                </div>
                <input type="range" id="starBrightnessSlider" min="0" max="1.0" step="0.05" value="0.8">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>AUDIO BOOST</span>
                    <span class="control-value" id="starAudioBoostValue">3.0x</span>
                </div>
                <input type="range" id="starAudioBoostSlider" min="0" max="10.0" step="0.5" value="3.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>TWINKLE RATE</span>
                    <span class="control-value" id="starTwinkleValue">200</span>
                </div>
                <input type="range" id="starTwinkleSlider" min="1" max="500" step="1" value="200">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>MIN OPACITY</span>
                    <span class="control-value" id="starMinOpacityValue">0.2</span>
                </div>
                <input type="range" id="starMinOpacitySlider" min="0" max="1.0" step="0.05" value="0.2">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>MAX OPACITY</span>
                    <span class="control-value" id="starMaxOpacityValue">1.0</span>
                </div>
                <input type="range" id="starMaxOpacitySlider" min="0" max="1.0" step="0.05" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>Z-AXIS SPEED</span>
                    <span class="control-value" id="starZSpeedValue">0.0</span>
                </div>
                <input type="range" id="starZSpeedSlider" min="0" max="5.0" step="0.1" value="0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SMOOTHING</span>
                    <span class="control-value" id="starSmoothingValue">0.5</span>
                </div>
                <input type="range" id="starSmoothingSlider" min="0" max="1.0" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>DIAMETER</span>
                    <span class="control-value" id="starDiameterValue">1.0x</span>
                </div>
                <input type="range" id="starDiameterSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- WAVE Theme Controls -->
        <section class="control-section" id="waveControlsSection" style="display: none;">
            <h3>WAVE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>MODE</span>
                </div>
                <select id="waveModeSelect" class="mode-select">
                    <option value="planes">PLANES</option>
                    <option value="grids">GRIDS</option>
                    <option value="dots">DOTS</option>
                </select>
            </div>
            <div class="control-group" id="waveLayersControl" style="display: none;">
                <div class="control-label">
                    <span>LAYERS</span>
                    <span class="control-value" id="waveLayersValue">3</span>
                </div>
                <input type="range" id="waveLayersSlider" min="1" max="10" step="1" value="3">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>HUE</span>
                    <span class="control-value" id="waveHueValue">280°</span>
                </div>
                <input type="range" id="waveHueSlider" min="0" max="360" step="1" value="280">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SATURATION</span>
                    <span class="control-value" id="waveSaturationValue">70%</span>
                </div>
                <input type="range" id="waveSaturationSlider" min="0" max="100" step="1" value="70">
            </div>
        </section>

        <!-- Frequency Emphasis - REPLACED BY UNIFIED CONTROL SYSTEM -->
        <section class="control-section" style="display: none;">
            <h3>FREQ</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>LOW</span>
                    <span class="control-value" id="lowValue">1.0</span>
                </div>
                <input type="range" id="lowEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>MID</span>
                    <span class="control-value" id="midValue">1.0</span>
                </div>
                <input type="range" id="midEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>HIGH</span>
                    <span class="control-value" id="highValue">1.0</span>
                </div>
                <input type="range" id="highEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
        </section>

        <!-- Wave Settings - REPLACED BY UNIFIED CONTROL SYSTEM -->
        <section class="control-section" id="waveSettingsSection" style="display: none;">
            <h3>WAVE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>INTENSITY</span>
                    <span class="control-value" id="intensityValue">2.5</span>
                </div>
                <input type="range" id="intensitySlider" min="0" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SPEED</span>
                    <span class="control-value" id="speedValue">1.0</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SMOOTHING</span>
                    <span class="control-value" id="smoothingValue">0.5</span>
                </div>
                <input type="range" id="smoothingSlider" min="0" max="1" step="0.1" value="0.5">
            </div>
        </section>

        <!-- Grid Density - REPLACED BY UNIFIED CONTROL SYSTEM -->
        <section class="control-section" style="display: none;">
            <h3>DENSITY</h3>
            <div class="density-options">
                <div class="density-option" data-density="low">L</div>
                <div class="density-option active" data-density="medium">M</div>
                <div class="density-option" data-density="high">H</div>
            </div>
        </section>

        <!-- Reset Button -->
        <button class="btn btn-reset" id="resetBtn">RESET</button>

        <!-- Attribution -->
        <div style="padding: 1rem; text-align: center; font-size: 8px; color: #666; margin-top: auto;">
            Advanced audio analysis powered by <a href="https://meyda.js.org" target="_blank" style="color: #888; text-decoration: underline;">Meyda</a>
        </div>
    </aside>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <h2>MIC ACCESS REQUIRED</h2>
        <p>Allow microphone permissions and reload</p>
    </div>

    <script>
        // =====================================================
        // SOUNDSCAPE: Audio-Reactive Wave Visualization
        // =====================================================

        // ===== BEAT DETECTION SYSTEM =====
        class BeatDetector {
            constructor() {
                this.energyHistory = [];
                this.historySize = 43; // ~1 second at 43 FPS
                this.threshold = 1.3; // Beat detected if energy > avg * threshold
                this.minTimeBetweenBeats = 300; // ms (prevents double-triggering)
                this.lastBeatTime = 0;
                this.beatStrength = 0;
                this.decayRate = 0.95; // How fast beat strength decays
            }

            detectBeat(currentEnergy, timestamp) {
                // Add to history
                this.energyHistory.push(currentEnergy);
                if (this.energyHistory.length > this.historySize) {
                    this.energyHistory.shift();
                }

                // Calculate average energy
                const avgEnergy = this.energyHistory.reduce((sum, e) => sum + e, 0) / this.energyHistory.length;

                // Detect beat if current energy significantly exceeds average
                const timeSinceLastBeat = timestamp - this.lastBeatTime;
                const isBeat = currentEnergy > avgEnergy * this.threshold &&
                              timeSinceLastBeat > this.minTimeBetweenBeats;

                if (isBeat) {
                    this.beatStrength = Math.min(1.0, (currentEnergy / avgEnergy - 1) / (this.threshold - 1));
                    this.lastBeatTime = timestamp;
                } else {
                    // Decay beat strength over time
                    this.beatStrength *= this.decayRate;
                }

                return {
                    isBeat,
                    strength: this.beatStrength,
                    energy: currentEnergy,
                    avgEnergy
                };
            }

            reset() {
                this.energyHistory = [];
                this.beatStrength = 0;
                this.lastBeatTime = 0;
            }
        }

        // ===== BPM DETECTION SYSTEM =====
        class BPMDetector {
            constructor() {
                this.beatTimes = [];
                this.maxBeats = 32; // Track last 32 beats
                this.lastBPM = 120; // Default BPM
                this.confidence = 0;
            }

            addBeat(timestamp) {
                this.beatTimes.push(timestamp);
                if (this.beatTimes.length > this.maxBeats) {
                    this.beatTimes.shift();
                }

                // Recalculate BPM
                if (this.beatTimes.length >= 4) {
                    this.calculateBPM();
                }
            }

            calculateBPM() {
                if (this.beatTimes.length < 4) {
                    this.confidence = 0;
                    return this.lastBPM;
                }

                // Calculate intervals between beats
                const intervals = [];
                for (let i = 1; i < this.beatTimes.length; i++) {
                    intervals.push(this.beatTimes[i] - this.beatTimes[i - 1]);
                }

                // Use median interval (more robust than average)
                intervals.sort((a, b) => a - b);
                const medianInterval = intervals[Math.floor(intervals.length / 2)];

                // Convert to BPM
                const bpm = 60000 / medianInterval;

                // Clamp to realistic range
                if (bpm >= 60 && bpm <= 200) {
                    this.lastBPM = bpm;

                    // Calculate confidence based on interval consistency
                    const stdDev = Math.sqrt(intervals.reduce((sum, i) => sum + Math.pow(i - medianInterval, 2), 0) / intervals.length);
                    this.confidence = Math.max(0, 1 - (stdDev / medianInterval));
                }

                return this.lastBPM;
            }

            getBPM() {
                return this.lastBPM;
            }

            getConfidence() {
                return this.confidence;
            }

            reset() {
                this.beatTimes = [];
                this.confidence = 0;
            }
        }

        // Simple 2D noise function (Perlin-like)
        function createNoise2D() {
            const permutation = [];
            for (let i = 0; i < 256; i++) permutation[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
            }
            const p = [...permutation, ...permutation];

            const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return function(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = fade(x);
                const v = fade(y);
                const a = p[X] + Y;
                const b = p[X + 1] + Y;
                return lerp(v,
                    lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                    lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1))
                );
            };
        }

        // ===== DOM ELEMENTS =====
        const elements = {
            svg: document.getElementById('wave-svg'),
            container: document.getElementById('visualization-container'),
            loading: document.getElementById('loadingScreen'),
            sidebar: document.getElementById('sidebar'),
            sidebarToggle: document.getElementById('sidebarToggle'),
            statusBar: document.getElementById('statusBar'),
            error: document.getElementById('errorScreen')
        };

        // ===== CONFIGURATION =====
        const config = {
            // Audio settings
            fftSize: 128, // Reduced from 256 for lower latency
            smoothing: 0.5, // Default smoothing value

            // Grid settings
            densityPresets: {
                low: { xGap: 20, yGap: 20 },
                medium: { xGap: 12, yGap: 12 },
                high: { xGap: 8, yGap: 8 }
            },

            // Wave physics
            waveAmplitude: 12,
            cursorInfluence: 0.00035,
            cursorRadius: 175,
            damping: 0.95,
            restoration: 0.01,

            // Color gradients (grayscale only)
            gradients: {
                default: { colors: ['#ffffff', '#999999'], bg: '#000000' }
            },

            // Theme configurations
            themes: {
                linear: {
                    colors: ['#ffffff', '#999999'],
                    bg: '#000000',
                    opacity: 0.6,
                    opacityMultiplier: 0.4 // Dynamic opacity range
                },
                neon: {
                    blurBase: 3,
                    blurMultiplier: 20,
                    saturationBase: 85,
                    saturationMultiplier: 15,
                    lightnessBase: 55,
                    lightnessRange: 35, // Will range from (55-35) to (55+35) = 20-90%
                    bg: '#000000',
                    opacity: 0.9,
                    baseHues: [180, 300, 60, 120, 340], // cyan, magenta, yellow, lime, pink
                    sizeMultiplierBase: 1.0,
                    sizeMultiplierRange: 1.5, // Will multiply size by 1.0-2.5x
                    movementBase: 150,
                    movementMultiplier: 300
                },
                glitch: {
                    bg: '#000000',
                    opacity: 0.85,
                    colors: ['#FF0000', '#00FFFF', '#FF00FF', '#00FF00'], // R, C, M, G
                    channelSeparationBase: 2,
                    channelSeparationMultiplier: 12, // Bass increases RGB separation
                    glitchIntensityMultiplier: 8, // Mids control random displacement
                    quantizationBase: 1,
                    quantizationMultiplier: 8 // Highs increase pixelation
                },
                stars: {
                    bg: '#000000',
                    opacity: 1.0,
                    maxStars: 1200,
                    hue: 217, // Base color hue (0-360)
                    brightness: 0.8, // Overall star brightness (0-1)
                    baseSpeed: 0.00002, // Base orbit speed
                    speedMultiplier: 3.0, // Audio-reactive speed boost
                    twinkleIntensity: 20, // How often stars twinkle (higher = less frequent)
                    alphaMin: 0.2, // Minimum alpha for stars
                    alphaMax: 1.0 // Maximum alpha for stars
                },
                wave: {
                    bg: '#000000',
                    opacity: 1.0,
                    hue: 280, // Purple hue
                    saturation: 70, // Color saturation

                    // Mesh grid properties
                    gridDensity: {
                        low: { cols: 15, rows: 10 },
                        medium: { cols: 20, rows: 12 },
                        high: { cols: 30, rows: 18 }
                    },
                    nodeSize: 3,
                    noiseScale: 0.05,
                    distortionIntensity: 1.5,
                    speed: 1.0,
                    glow: 1.0,

                    // Orbital dots
                    dotCount: 200,
                    orbitRadius: 100,
                    dotSize: 2,

                    // Color modes
                    colorModes: {
                        mono: { baseHue: 0, saturation: 0 },
                        warm: { baseHue: 30, saturation: 60 },
                        cool: { baseHue: 200, saturation: 60 }
                    }
                }
            }
        };

        // ===== UNIFIED CONTROL SYSTEM =====
        let controlSystemUI = null;
        let audioEngine = null;

        // ===== STATE =====
        const state = {
            // User settings
            settings: {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.5,
                density: 'medium',
                gradient: 'default',
                mode: 'default',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0,
                glitchContrast: 1.0,
                glitchMode: 'rgb',
                neonMode: 'bright',
                colorTemp: 1.0,
                image3DMotion: 0.0,  // 3D motion intensity for image objects (0 = off)
                starHue: 44,  // Star base color hue (0-360)
                starSaturation: 12,  // Star color saturation (0-100%)
                starSpeed: 1.0,  // Star base speed multiplier (0-5)
                starCount: 1200,  // Number of stars (100-2000)
                starBrightness: 0.8,  // Overall star brightness (0-1)
                starAudioBoost: 3.0,  // Audio-reactive speed multiplier (0-10)
                starTwinkle: 200,  // Twinkle rate (higher = less frequent, 200 = subtle)
                starMinOpacity: 0.2,  // Minimum star opacity (0-1)
                starMaxOpacity: 1.0,  // Maximum star opacity (0-1)
                starZSpeed: 0,  // Z-axis movement speed (0-5, creates depth effect)
                starSmoothing: 0.5,  // Audio smoothing for stars (0-1)
                starDiameter: 1.0,  // Animation diameter multiplier (0.5-2.0)

                // WAVE theme settings
                waveMode: 'planes',  // Visual mode: planes, grids, dots
                waveLayers: 3,  // Number of layers for grids/dots mode (1-10)
                waveHue: 280,  // Color hue (0-360)
                waveSaturation: 70  // Color saturation (0-100%)
            },

            // Audio
            audioContext: null,
            analyser: null,
            microphone: null,
            dataArray: null,
            bufferLength: 0,
            isActive: false,

            // Meyda audio analysis
            meydaAnalyzer: null,
            meydaFeatures: null,

            // Wave grid
            paths: [],
            lines: [],
            noise: null,
            boundingRect: null,
            transitioning: false,
            transitionProgress: 1.0,

            // Mouse tracking
            mouse: {
                x: -10,
                y: 0,
                lx: 0,
                ly: 0,
                sx: 0,
                sy: 0,
                v: 0,
                vs: 0,
                a: 0,
                set: false,
                onScreen: false
            },

            // Control visibility
            controlsVisible: true,
            idleTimeout: null,

            // Audio levels (for theme renderers)
            audioLevels: {
                low: 0,
                mid: 0,
                high: 0
            },
            currentTime: 0,

            // Beat and BPM detection
            beatDetector: new BeatDetector(),
            bpmDetector: new BPMDetector(),

            // User-created gradient centers (for NEON theme)
            userGradientCenters: [],

            // GLITCH theme image state (for background replacement)
            glitchImage: {
                img: null,
                loaded: false,
                width: 400,
                height: 300,
                originalWidth: 0,
                originalHeight: 0,
                x: 0,
                y: 0,
                scale: 1.0,
                fitMode: 'cover',
                rotation3D: { x: 0, y: 0, z: 0 },
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragStartWidth: 0,
                dragStartHeight: 0
            },

            // STARS theme state
            stars: {
                initialized: false,
                starArray: [],
                gradientCanvas: null,
                gradientCtx: null,
                count: 0,
                centerX: null,  // Current center X (smoothed)
                centerY: null,  // Current center Y (smoothed)
                targetCenterX: null,  // Target center X (click position)
                targetCenterY: null   // Target center Y (click position)
            },

            wave: {
                initialized: false,
                gridNodes: [],
                orbitalDots: [],
                noiseOffset: 0
            },

            // Image objects (for LINEAR/NEON overlay images)
            imageObjects: [],
            selectedImageIndex: -1
        };

        // Expose state globally for control system
        window.state = state;

        // =====================================================
        // UNIFIED CONTROL SYSTEM INITIALIZATION
        // =====================================================

        function initializeControlSystem() {
            console.log('🎛️ Initializing Unified Control System...');

            try {
                // Initialize Control System UI
                const container = document.getElementById('dynamicControlsContainer');
                if (!container) {
                    console.error('❌ Dynamic controls container not found');
                    return;
                }

                controlSystemUI = new ControlSystemUI(container);
                controlSystemUI.initializeAll();

                // Initialize Audio Modulation Engine
                audioEngine = new AudioModulationEngine();

                // Show controls for current theme
                const currentTheme = state.settings.theme || 'linear';
                controlSystemUI.showTheme(currentTheme);

                // Hook into theme switching
                const themeSelect = document.getElementById('themeSelect');
                if (themeSelect) {
                    themeSelect.addEventListener('change', (e) => {
                        const newTheme = e.target.value;
                        if (controlSystemUI) {
                            controlSystemUI.showTheme(newTheme);
                        }
                    });
                }

                console.log('✅ Unified Control System initialized');
            } catch (error) {
                console.error('❌ Failed to initialize Control System:', error);
            }
        }

        // =====================================================
        // INITIALIZATION
        // =====================================================

        async function init() {
            console.log('🎨 Initializing Soundscape...');

            // Initialize noise generator
            state.noise = createNoise2D();

            // Setup wave grid
            setupWaveGrid();

            // Setup all controls
            setupControls();

            // Update theme description on load
            updateThemeDescription();

            // Initialize unified control system
            initializeControlSystem();

            // Auto-start audio capture
            await startAudioCapture();

            // Initialize mobile companion pairing
            initializePairing();
            setupPairingUI();
            startListeningForMobileUpdates();
        }

        // =====================================================
        // WAVE GRID SETUP
        // =====================================================

        function setupWaveGrid() {
            // Store old grid for transition
            const oldLines = state.lines.length > 0 ? state.lines.map(line =>
                line.map(p => ({ x: p.x, y: p.y }))
            ) : null;

            // Get container dimensions
            state.boundingRect = elements.container.getBoundingClientRect();
            const { width, height } = state.boundingRect;

            // Set SVG dimensions
            elements.svg.style.width = `${width}px`;
            elements.svg.style.height = `${height}px`;
            elements.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Get density settings from control system (LINEAR theme)
            const densityValue = (audioEngine && state.settings.theme === 'linear')
                ? (audioEngine.getValue('linear', 'density') || state.settings.density)
                : state.settings.density;
            const density = config.densityPresets[densityValue];

            // Get spread control (represents both xGap and yGap for uniform grid spacing)
            // Default to 12px (original medium density)
            const spreadControl = (audioEngine && state.settings.theme === 'linear')
                ? (audioEngine.getValue('linear', 'spread') || 12)
                : 12;

            // Use spread control for both x and y gap (uniform grid spacing)
            const xGap = spreadControl;
            const yGap = spreadControl;

            // Calculate grid dimensions - oversized to hide edges
            const padding = 400; // Increased padding to ensure edges are never visible
            const oWidth = width + padding;
            const oHeight = height + padding;

            // Calculate total lines and points based on gap spacing (original behavior)
            const totalLines = Math.ceil(oWidth / xGap);
            const totalPoints = Math.ceil(oHeight / yGap);

            const xStart = (width - xGap * totalLines) / 2;
            const yStart = (height - yGap * totalPoints) / 2;

            console.log(`📊 Creating ${totalLines} lines with ${totalPoints} points each`);

            // Check if we need to rebuild or just transition
            const needsRebuild = state.lines.length !== totalLines ||
                                (state.lines.length > 0 && state.lines[0].length !== totalPoints);

            if (needsRebuild) {
                // Clear existing grid
                state.paths.forEach(path => path.remove());
                state.paths = [];
                state.lines = [];

                // Create grid lines
                for (let i = 0; i < totalLines; i++) {
                    const points = [];

                    // Create points for this line
                    for (let j = 0; j < totalPoints; j++) {
                        const targetX = xStart + xGap * i;
                        const targetY = yStart + yGap * j;

                        // Try to find nearest old point for smooth transition
                        let startX = targetX;
                        let startY = targetY;

                        if (oldLines && oldLines.length > 0) {
                            const oldLineIndex = Math.min(i, oldLines.length - 1);
                            const oldLine = oldLines[oldLineIndex];
                            if (oldLine && oldLine.length > 0) {
                                const oldPointIndex = Math.min(j, oldLine.length - 1);
                                startX = oldLine[oldPointIndex].x;
                                startY = oldLine[oldPointIndex].y;
                            }
                        }

                        points.push({
                            x: startX,
                            y: startY,
                            targetX: targetX,
                            targetY: targetY,
                            wave: { x: 0, y: 0 },
                            cursor: { x: 0, y: 0, vx: 0, vy: 0 },
                            audio: { x: 0, y: 0 }
                        });
                    }

                    // Create SVG path
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-width', '1');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('opacity', '0.6');
                    elements.svg.appendChild(path);

                    state.paths.push(path);
                    state.lines.push(points);
                }

                // Start transition if we had an old grid
                if (oldLines) {
                    state.transitioning = true;
                    state.transitionProgress = 0.0;
                }
            } else {
                // Just update target positions
                for (let i = 0; i < totalLines; i++) {
                    for (let j = 0; j < totalPoints; j++) {
                        const p = state.lines[i][j];
                        p.targetX = xStart + xGap * i;
                        p.targetY = yStart + yGap * j;
                    }
                }

                state.transitioning = true;
                state.transitionProgress = 0.0;
            }

            // Apply colors
            updateColors();
        }

        function updateThemeDescription() {
            const themeDescription = document.getElementById('themeDescription');
            if (!themeDescription) return;

            const descriptions = {
                linear: 'Audio affects: wave distortion, color intensity, path movement',
                neon: 'Audio affects: gradient colors, mesh animation, brightness pulses',
                glitch: 'Audio affects: rotation speed, glitch intensity, RGB separation',
                stars: 'Audio affects: orbit speed (bass slows), brightness (mids), center position (highs)',
                wave: 'Audio affects: grid distortion (bass), orbit speed (mids), glow intensity (highs)'
            };

            themeDescription.textContent = descriptions[state.settings.theme] || '';
        }

        function updateModeVisibility() {
            const backgroundControlsSection = document.getElementById('backgroundControlsSection');
            const modeSection = document.getElementById('modeSection');
            const neonControlsSection = document.getElementById('neonControlsSection');
            const glitchControlsSection = document.getElementById('glitchControlsSection');
            const starsControlsSection = document.getElementById('starsControlsSection');
            const imageControlsSection = document.getElementById('imageControlsSection');
            const imageThemeSelect = document.getElementById('imageThemeSelect');
            const uploadOverlay = document.getElementById('upload-overlay');

            const hasSelectedImage = state.selectedImageIndex !== -1 && state.imageObjects[state.selectedImageIndex];

            // Show background controls when no image is selected
            if (backgroundControlsSection) {
                backgroundControlsSection.style.display = hasSelectedImage ? 'none' : 'block';
            }

            // DISABLED: Old theme-specific controls replaced by unified control system
            // Show/hide theme-specific background controls
            // if (modeSection) {
            //     modeSection.style.display = !hasSelectedImage && state.settings.theme === 'linear' ? 'block' : 'none';
            // }

            // if (neonControlsSection) {
            //     neonControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'neon' ? 'block' : 'none';
            // }

            // if (glitchControlsSection) {
            //     glitchControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'glitch' ? 'block' : 'none';
            // }

            // if (starsControlsSection) {
            //     starsControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'stars' ? 'block' : 'none';
            // }

            // const waveControlsSection = document.getElementById('waveControlsSection');
            // if (waveControlsSection) {
            //     waveControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'wave' ? 'block' : 'none';
            // }

            // // Hide global WAVE settings for STARS and WAVE themes (they have their own controls)
            // const waveSettingsSection = document.getElementById('waveSettingsSection');
            // if (waveSettingsSection) {
            //     const hideWaveSettings = state.settings.theme === 'stars' || state.settings.theme === 'wave';
            //     waveSettingsSection.style.display = !hasSelectedImage && !hideWaveSettings ? 'block' : 'none';
            // }

            // Update theme description
            updateThemeDescription();

            // Show image controls when an image is selected
            // Hide theme controls when image is selected
            if (imageControlsSection) {
                imageControlsSection.style.display = hasSelectedImage ? 'block' : 'none';

                // Hide/show theme controls based on image selection
                const dynamicControls = document.getElementById('dynamicControlsContainer');
                const themeControlSections = [
                    'modeSection',
                    'neonControlsSection',
                    'glitchControlsSection',
                    'starsControlsSection',
                    'waveControlsSection',
                    'waveSettingsSection'
                ];

                if (hasSelectedImage) {
                    // Hide theme controls when image is selected
                    if (dynamicControls) dynamicControls.style.display = 'none';
                    themeControlSections.forEach(id => {
                        const section = document.getElementById(id);
                        if (section) section.style.display = 'none';
                    });
                } else {
                    // Show theme controls when no image is selected
                    if (dynamicControls) dynamicControls.style.display = 'block';
                    // Theme-specific sections will be shown/hidden by updateThemeUI()
                }

                // Update image controls to match selected image's properties
                if (hasSelectedImage) {
                    const imageObj = state.imageObjects[state.selectedImageIndex];

                    // Update all sliders and their value displays
                    if (imageThemeSelect) {
                        imageThemeSelect.value = imageObj.theme;

                        // Hide/show effect settings based on theme
                        const effectSettings = document.getElementById('imageEffectSettings');
                        if (effectSettings) {
                            effectSettings.style.display = imageObj.theme === 'none' ? 'none' : 'block';
                        }
                    }

                    const updateSlider = (sliderId, valueId, value, decimals = 2) => {
                        const slider = document.getElementById(sliderId);
                        const valueEl = document.getElementById(valueId);
                        if (slider) slider.value = value;
                        if (valueEl) valueEl.textContent = decimals === 0 ? value : value.toFixed(decimals);
                    };

                    updateSlider('imageTransparencySlider', 'imageTransparencyValue', imageObj.transparency, 2);
                    updateSlider('imageRotationSlider', 'imageRotationValue', imageObj.rotation, 0);
                    updateSlider('imageBlurSlider', 'imageBlurValue', imageObj.blur, 1);
                    updateSlider('themeOpacitySlider', 'themeOpacityValue', imageObj.themeOpacity, 2);
                    updateSlider('imageScaleSlider', 'imageScaleValue', imageObj.scale || 1.0, 1);

                    // Update video speed slider if this is a video
                    if (imageObj.isVideo) {
                        updateSlider('videoSpeedSlider', 'videoSpeedValue', imageObj.video?.playbackRate || 1.0, 1);
                    }

                    // Update flash effect controls
                    const flashFreqCheck = document.getElementById('flashFrequencyCheck');
                    const flashVolCheck = document.getElementById('flashVolumeCheck');
                    const flashFreqGroup = document.getElementById('flashFrequencySliderGroup');
                    const flashVolGroup = document.getElementById('flashVolumeSliderGroup');

                    if (flashFreqCheck) flashFreqCheck.checked = imageObj.flashFrequencyEnabled || false;
                    if (flashVolCheck) flashVolCheck.checked = imageObj.flashVolumeEnabled || false;
                    if (flashFreqGroup) flashFreqGroup.style.display = imageObj.flashFrequencyEnabled ? 'block' : 'none';
                    if (flashVolGroup) flashVolGroup.style.display = imageObj.flashVolumeEnabled ? 'block' : 'none';

                    updateSlider('flashFrequencySlider', 'flashFrequencyValue', imageObj.flashFrequencyThreshold || 0.5, 2);
                    updateSlider('flashVolumeSlider', 'flashVolumeValue', imageObj.flashVolumeThreshold || 0.5, 2);

                    // Update video controls if this is a video object
                    const videoControlsSection = document.getElementById('videoControlsSection');
                    if (videoControlsSection) {
                        if (imageObj.isVideo) {
                            videoControlsSection.style.display = 'block';

                            // Update loop checkbox
                            const videoLoopCheck = document.getElementById('videoLoopCheck');
                            if (videoLoopCheck) videoLoopCheck.checked = imageObj.loop || false;

                            // Update trim sliders
                            const trimStartSlider = document.getElementById('videoTrimStartSlider');
                            const trimEndSlider = document.getElementById('videoTrimEndSlider');
                            const trimStartValue = document.getElementById('videoTrimStartValue');
                            const trimEndValue = document.getElementById('videoTrimEndValue');

                            if (imageObj.duration) {
                                if (trimStartSlider) {
                                    trimStartSlider.max = imageObj.duration;
                                    trimStartSlider.value = imageObj.trimStart || 0;
                                }
                                if (trimEndSlider) {
                                    trimEndSlider.max = imageObj.duration;
                                    trimEndSlider.value = imageObj.trimEnd || imageObj.duration;
                                }
                                if (trimStartValue) trimStartValue.textContent = `${(imageObj.trimStart || 0).toFixed(1)}s`;
                                if (trimEndValue) trimEndValue.textContent = `${(imageObj.trimEnd || imageObj.duration).toFixed(1)}s`;
                            }
                        } else {
                            videoControlsSection.style.display = 'none';
                        }
                    }
                }
            }

            // Show/hide GLITCH background controls
            const glitchBackgroundControls = document.getElementById('glitchBackgroundControls');
            if (glitchBackgroundControls) {
                const shouldShowGlitchControls = state.settings.theme === 'glitch' && state.glitchImage.loaded;
                glitchBackgroundControls.style.display = shouldShowGlitchControls ? 'block' : 'none';

                // Update GLITCH control values when shown
                if (shouldShowGlitchControls) {
                    const fitModeSelect = document.getElementById('glitchFitModeSelect');
                    const scaleSlider = document.getElementById('glitchScaleSlider');
                    const scaleValue = document.getElementById('glitchScaleValue');
                    const xSlider = document.getElementById('glitchXSlider');
                    const xValue = document.getElementById('glitchXValue');
                    const ySlider = document.getElementById('glitchYSlider');
                    const yValue = document.getElementById('glitchYValue');

                    if (fitModeSelect) fitModeSelect.value = state.glitchImage.fitMode || 'cover';
                    if (scaleSlider) scaleSlider.value = state.glitchImage.scale || 1.0;
                    if (scaleValue) scaleValue.textContent = `${(state.glitchImage.scale || 1.0).toFixed(1)}x`;
                    if (xSlider) xSlider.value = state.glitchImage.x || 0;
                    if (xValue) xValue.textContent = (state.glitchImage.x || 0).toString();
                    if (ySlider) ySlider.value = state.glitchImage.y || 0;
                    if (yValue) yValue.textContent = (state.glitchImage.y || 0).toString();

                    // Show/hide manual controls based on fit mode
                    const isManual = (state.glitchImage.fitMode || 'cover') === 'manual';
                    const scaleGroup = document.getElementById('glitchScaleGroup');
                    const xGroup = document.getElementById('glitchXGroup');
                    const yGroup = document.getElementById('glitchYGroup');
                    if (scaleGroup) scaleGroup.style.display = isManual ? 'block' : 'none';
                    if (xGroup) xGroup.style.display = isManual ? 'block' : 'none';
                    if (yGroup) yGroup.style.display = isManual ? 'block' : 'none';
                }
            }

            if (uploadOverlay) {
                // Show upload overlay for GLITCH theme only when no image is loaded
                const shouldShowOverlay = state.settings.theme === 'glitch' && !state.glitchImage.loaded;
                uploadOverlay.style.display = shouldShowOverlay ? 'flex' : 'none';
            }
        }

        function updateColors() {
            const theme = config.themes[state.settings.theme];

            // Update background
            document.body.style.background = theme.bg;

            // Update mode visibility based on theme
            updateModeVisibility();

            // Handle canvas visibility
            const starsCanvas = document.getElementById('stars-canvas');
            if (starsCanvas) {
                starsCanvas.style.display = state.settings.theme === 'stars' ? 'block' : 'none';
            }

            const waveCanvas = document.getElementById('wave-canvas');
            if (waveCanvas) {
                waveCanvas.style.display = state.settings.theme === 'wave' ? 'block' : 'none';
            }

            // Update line colors based on theme
            if (state.settings.theme === 'linear') {
                // Linear uses gradient colors
                state.paths.forEach((path, i) => {
                    const progress = i / state.paths.length;
                    const colorIndex = Math.floor(progress * theme.colors.length);
                    const color = theme.colors[Math.min(colorIndex, theme.colors.length - 1)];
                    path.setAttribute('stroke', color);
                    path.removeAttribute('filter');
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'neon') {
                // Neon theme colors are set dynamically in drawLinesNeon
                // Just ensure paths are ready
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'glitch') {
                // Glitch theme colors are set dynamically in drawLinesGlitch
                // Reset path attributes
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'stars') {
                // Stars theme: hide SVG paths (stars are rendered on canvas)
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', '0');
                });
            } else if (state.settings.theme === 'wave') {
                // Wave theme: hide SVG paths (wave is rendered on canvas)
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', '0');
                });
            }
        }

        // =====================================================
        // AUDIO CAPTURE
        // =====================================================

        async function startAudioCapture() {
            try {
                console.log('🎤 Requesting microphone access...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Setup audio context
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.microphone = state.audioContext.createMediaStreamSource(stream);

                // Configure analyser
                state.analyser.fftSize = config.fftSize;
                state.analyser.smoothingTimeConstant = state.settings.smoothing;
                state.bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(state.bufferLength);

                // Connect audio graph
                state.microphone.connect(state.analyser);

                // Initialize Meyda for advanced audio analysis
                if (typeof Meyda !== 'undefined') {
                    try {
                        state.meydaAnalyzer = Meyda.createMeydaAnalyzer({
                            audioContext: state.audioContext,
                            source: state.microphone,
                            bufferSize: 512,
                            featureExtractors: [
                                'spectralCentroid',
                                'spectralFlatness',
                                'spectralRolloff',
                                'spectralFlux',
                                'spectralSpread',
                                'loudness',
                                'chroma'
                            ],
                            callback: features => {
                                try {
                                    // Validate features before storing
                                    // spectralFlux may error on first few frames
                                    if (features && typeof features === 'object') {
                                        state.meydaFeatures = features;
                                    }
                                } catch (err) {
                                    // Silently ignore Meyda calculation errors (e.g., spectralFlux on first frames)
                                    // Features will use previous valid values or defaults
                                }
                            }
                        });

                        state.meydaAnalyzer.start();
                        console.log('✨ Meyda analyzer initialized with 7 features');
                    } catch (err) {
                        console.warn('⚠️ Meyda initialization failed:', err);
                        state.meydaAnalyzer = null;
                    }
                } else {
                    console.warn('⚠️ Meyda library not loaded, advanced features disabled');
                    state.meydaAnalyzer = null;
                }

                // Update UI
                state.isActive = true;
                elements.loading.classList.add('hidden');
                elements.statusBar.classList.add('active');

                console.log('✅ Audio capture started');
                console.log('🎤 Analyser config:', {
                    fftSize: state.analyser.fftSize,
                    bufferLength: state.bufferLength,
                    smoothing: state.analyser.smoothingTimeConstant
                });

                // Start idle timeout for controls
                showControls();

                // Start animation loop
                requestAnimationFrame(animate);

            } catch (err) {
                console.error('❌ Microphone access denied:', err);
                elements.loading.classList.add('hidden');
                elements.error.classList.add('show');
            }
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate(time = 0) {
            if (!state.isActive) return;

            // Update mouse smoothing
            updateMouse();

            // Move all points
            movePoints(time);

            // Draw all lines
            drawLines();

            // Continue loop
            requestAnimationFrame(animate);
        }

        function updateMouse() {
            const m = state.mouse;

            // Smooth mouse position
            m.sx += (m.x - m.sx) * 0.1;
            m.sy += (m.y - m.sy) * 0.1;

            // Calculate velocity
            const dx = m.x - m.lx;
            const dy = m.y - m.ly;
            const distance = Math.hypot(dx, dy);

            m.v = distance;
            m.vs += (distance - m.vs) * 0.1;
            m.vs = Math.min(100, m.vs);

            // Store last position
            m.lx = m.x;
            m.ly = m.y;

            // Calculate angle
            m.a = Math.atan2(dy, dx);
        }

        /**
         * Normalize Meyda features to 0-1 range
         * @param {Object} features - Raw Meyda features
         * @returns {Object} Normalized features (0-1)
         */
        function normalizeMeydaFeatures(features) {
            if (!features) return {};

            return {
                // Spectral Centroid: typically 0-10000 Hz
                spectralCentroid: features.spectralCentroid
                    ? Math.min(1, features.spectralCentroid / 10000)
                    : 0,

                // Spectral Flatness: already 0-1
                spectralFlatness: features.spectralFlatness || 0,

                // Spectral Rolloff: typically 0-20000 Hz
                spectralRolloff: features.spectralRolloff
                    ? Math.min(1, features.spectralRolloff / 20000)
                    : 0,

                // Spectral Flux: typically 0-100, varies widely
                spectralFlux: features.spectralFlux
                    ? Math.min(1, features.spectralFlux / 100)
                    : 0,

                // Spectral Spread: typically 0-5000
                spectralSpread: features.spectralSpread
                    ? Math.min(1, features.spectralSpread / 5000)
                    : 0,

                // Loudness: object with total, specific, relative
                // Use total loudness, typically -60 to 0 dB
                loudness: features.loudness?.total
                    ? Math.min(1, Math.max(0, (features.loudness.total + 60) / 60))
                    : 0,

                // Chroma: 12 values, already normalized but average them
                chroma: features.chroma
                    ? features.chroma.reduce((sum, val) => sum + val, 0) / 12
                    : 0
            };
        }

        function movePoints(time) {
            // Store time for theme renderers
            state.currentTime = time;

            // Handle grid transition animation
            if (state.transitioning) {
                state.transitionProgress += 0.05; // Smooth transition speed
                if (state.transitionProgress >= 1.0) {
                    state.transitionProgress = 1.0;
                    state.transitioning = false;
                }

                // Interpolate all points to their target positions
                const easeProgress = easeInOutCubic(state.transitionProgress);
                state.lines.forEach((points) => {
                    points.forEach((p) => {
                        if (p.targetX !== undefined && p.targetY !== undefined) {
                            p.x += (p.targetX - p.x) * easeProgress * 0.2;
                            p.y += (p.targetY - p.y) * easeProgress * 0.2;
                        }
                    });
                });
            }

            // Get audio frequency data with expanded analysis
            let subBassSum = 0, bassSum = 0, lowMidsSum = 0, midsSum = 0,
                highMidsSum = 0, highsSum = 0, brillianceSum = 0;
            let peakValue = 0, sumSquares = 0;

            if (state.analyser) {
                state.analyser.getByteFrequencyData(state.dataArray);

                // Split frequency spectrum into 7 bands
                // Assuming 44.1kHz sample rate, typical FFT size 2048
                // Frequency per bin ≈ 44100 / 2048 ≈ 21.5 Hz
                for (let i = 0; i < state.bufferLength; i++) {
                    const value = state.dataArray[i];
                    const binPercentage = i / state.bufferLength;

                    // Track peak and RMS
                    peakValue = Math.max(peakValue, value);
                    sumSquares += value * value;

                    // Frequency band distribution (approximate Hz ranges)
                    // 0-5%: Sub-Bass (20-60 Hz)
                    // 5-15%: Bass (60-250 Hz)
                    // 15-25%: Low-Mids (250-500 Hz)
                    // 25-50%: Mids (500-2000 Hz)
                    // 50-70%: High-Mids (2000-4000 Hz)
                    // 70-90%: Highs (4000-8000 Hz)
                    // 90-100%: Brilliance (8000-20000 Hz)
                    if (binPercentage < 0.05) subBassSum += value;
                    else if (binPercentage < 0.15) bassSum += value;
                    else if (binPercentage < 0.25) lowMidsSum += value;
                    else if (binPercentage < 0.50) midsSum += value;
                    else if (binPercentage < 0.70) highMidsSum += value;
                    else if (binPercentage < 0.90) highsSum += value;
                    else brillianceSum += value;
                }
            }

            // Calculate normalized frequency levels (0-1)
            const subBassLevel = (subBassSum / (state.bufferLength * 0.05) / 255) * state.settings.lowEmphasis;
            const bassLevel = (bassSum / (state.bufferLength * 0.10) / 255) * state.settings.lowEmphasis;
            const lowMidsLevel = (lowMidsSum / (state.bufferLength * 0.10) / 255) * state.settings.midEmphasis;
            const midsLevel = (midsSum / (state.bufferLength * 0.25) / 255) * state.settings.midEmphasis;
            const highMidsLevel = (highMidsSum / (state.bufferLength * 0.20) / 255) * state.settings.highEmphasis;
            const highsLevel = (highsSum / (state.bufferLength * 0.20) / 255) * state.settings.highEmphasis;
            const brillianceLevel = (brillianceSum / (state.bufferLength * 0.10) / 255) * state.settings.highEmphasis;

            // Calculate amplitude features
            const peakLevel = peakValue / 255;
            const rmsLevel = Math.sqrt(sumSquares / state.bufferLength) / 255;
            const dbLevel = rmsLevel > 0 ? Math.max(0, Math.min(1, (20 * Math.log10(rmsLevel) + 60) / 60)) : 0; // Normalize -60dB to 0dB as 0-1

            // Beat and BPM detection
            const timestamp = performance.now();

            // Detect bass-focused beats (kick drums)
            const bassEnergy = subBassLevel + bassLevel;
            const beatResult = state.beatDetector.detectBeat(bassEnergy, timestamp);

            // Detect onset (any sudden sound start - more sensitive)
            const onsetEnergy = midsLevel + highsLevel;
            const onsetThreshold = 0.6;
            const isOnset = onsetEnergy > onsetThreshold;

            // Update BPM when beat detected
            if (beatResult.isBeat) {
                state.bpmDetector.addBeat(timestamp);
            }

            // Get current BPM (normalized 0-1, where 120 BPM = 0.5)
            const bpmValue = (state.bpmDetector.getBPM() - 60) / 140; // 60-200 BPM -> 0-1
            const bpmConfidence = state.bpmDetector.getConfidence();

            // Normalize Meyda features if available
            const meydaNormalized = normalizeMeydaFeatures(state.meydaFeatures);

            // Store all audio levels for theme renderers and control system
            state.audioLevels = {
                // Original 3-band (for backward compatibility)
                low: bassLevel,
                mid: midsLevel,
                high: highsLevel,

                // Expanded 7-band frequency analysis
                subBass: subBassLevel,
                bass: bassLevel,
                lowMids: lowMidsLevel,
                mids: midsLevel,
                highMids: highMidsLevel,
                highs: highsLevel,
                brilliance: brillianceLevel,

                // Amplitude features
                peak: peakLevel,
                rms: rmsLevel,
                decibels: dbLevel,

                // Rhythm features
                beat: beatResult.strength, // 0-1, decays over time
                onset: isOnset ? 1.0 : 0.0, // 0 or 1 (trigger)
                bpm: bpmValue, // 0-1 (60-200 BPM)

                // Meyda: Spectral features
                centroid: meydaNormalized.spectralCentroid || 0,
                flatness: meydaNormalized.spectralFlatness || 0,
                rolloff: meydaNormalized.spectralRolloff || 0,
                flux: meydaNormalized.spectralFlux || 0,
                spread: meydaNormalized.spectralSpread || 0,

                // Meyda: Perceptual features
                loudness: meydaNormalized.loudness || 0,
                chroma: meydaNormalized.chroma || 0,

                // Combined
                allLevels: (bassLevel + midsLevel + highsLevel) / 3,

                // Metadata (for debugging)
                _bpmActual: state.bpmDetector.getBPM(),
                _bpmConfidence: bpmConfidence,
                _beatDetected: beatResult.isBeat,
                _meydaActive: !!state.meydaAnalyzer
            };

            // Apply audio modulation to controls
            if (audioEngine && state.settings.theme) {
                audioEngine.applyModulation(state.audioLevels, state.settings.theme);
            }

            // Get modulated amplitude (for LINEAR theme physics)
            // Falls back to old intensity control if not available
            const amplitude = (audioEngine && state.settings.theme)
                ? (audioEngine.getValue(state.settings.theme, 'amplitude') || state.settings.intensity)
                : state.settings.intensity;

            // Get visualMode from control system (for LINEAR theme)
            const visualMode = (audioEngine && state.settings.theme === 'linear')
                ? (audioEngine.getValue('linear', 'visualMode') || state.settings.mode)
                : state.settings.mode;

            // Debug logging (every 60 frames ~= 1 second)
            if (Math.random() < 0.016) {
                console.log('🎵 Audio Levels:', {
                    low: bassLevel.toFixed(3),
                    mid: midsLevel.toFixed(3),
                    high: highsLevel.toFixed(3),
                    amplitude: amplitude?.toFixed(3),
                    mode: visualMode,
                    bassSum,
                    midsSum,
                    highsSum
                });
            }

            // Bass creates global background shift - more dramatic
            const bassShiftX = Math.sin(time * 0.001) * bassLevel * 20 * amplitude;
            const bassShiftY = Math.cos(time * 0.0015) * bassLevel * 15 * amplitude;

            // Store background shift for theme renderers
            state.backgroundShift = {
                x: bassShiftX,
                y: bassShiftY
            };

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // MODE-DEPENDENT BEHAVIOR
            let midCursorX, midCursorY, highCursorX, highCursorY;

            if (visualMode === 'hole' || visualMode === 'default') {
                // HOLE/DEFAULT MODE: Follow cursor if on screen, random if not
                if (state.mouse.onScreen) {
                    midCursorX = state.mouse.sx;
                    midCursorY = state.mouse.sy;
                    highCursorX = state.mouse.sx;
                    highCursorY = state.mouse.sy;
                } else {
                    // Random virtual cursor positions
                    midCursorX = canvasWidth * 0.3 + Math.sin(time * 0.002) * midsLevel * 200;
                    midCursorY = canvasHeight * 0.5 + Math.cos(time * 0.003) * midsLevel * 150;

                    highCursorX = canvasWidth * 0.7 + Math.sin(time * 0.0025) * highsLevel * 250;
                    highCursorY = canvasHeight * 0.5 + Math.cos(time * 0.002) * highsLevel * 200;
                }
            }

            // CRUNCH MODE: Calculate wave front positions
            const crunchMidAngle = time * 0.0008 + state.noise(time * 0.0002, 0) * Math.PI * 2;
            const crunchHighAngle = time * 0.001 + state.noise(time * 0.0003, 100) * Math.PI * 2;
            const crunchMidOffset = Math.sin(time * 0.0005) * canvasWidth * 0.5;
            const crunchHighOffset = Math.sin(time * 0.0007) * canvasWidth * 0.5;

            // Update all points
            state.lines.forEach((points) => {
                points.forEach((p) => {
                    // 1. Base wave motion (simplex noise)
                    const timeScale = time * 0.008 * state.settings.speed;
                    const noiseValue = state.noise(
                        (p.x + timeScale) * 0.003,
                        (p.y + timeScale * 0.375) * 0.002
                    ) * 8;

                    p.wave.x = Math.cos(noiseValue) * config.waveAmplitude + bassShiftX;
                    p.wave.y = Math.sin(noiseValue) * (config.waveAmplitude * 0.5) + bassShiftY;

                    let midForceX = 0;
                    let midForceY = 0;
                    let highForceX = 0;
                    let highForceY = 0;

                    if (visualMode === 'hole') {
                        // HOLE MODE: Radial ripples from cursor position
                        // 2. Mids create ripple effect - MORE DRAMATIC
                        const midDx = p.x - midCursorX;
                        const midDy = p.y - midCursorY;
                        const midDist = Math.hypot(midDx, midDy);
                        const midRadius = 400 * midsLevel;

                        if (midDist < midRadius && midDist > 0) {
                            const midStrength = (1 - midDist / midRadius) * midsLevel;
                            const angle = Math.atan2(midDy, midDx);
                            midForceX = Math.cos(angle) * midStrength * 120 * amplitude;
                            midForceY = Math.sin(angle) * midStrength * 120 * amplitude;
                        }

                        // 3. Highs create sharper ripple effect - MORE DRAMATIC
                        const highDx = p.x - highCursorX;
                        const highDy = p.y - highCursorY;
                        const highDist = Math.hypot(highDx, highDy);
                        const highRadius = 250 * highsLevel;

                        if (highDist < highRadius && highDist > 0) {
                            const highStrength = (1 - highDist / highRadius) * highsLevel;
                            const angle = Math.atan2(highDy, highDx);
                            highForceX = Math.cos(angle) * highStrength * 150 * amplitude;
                            highForceY = Math.sin(angle) * highStrength * 150 * amplitude;
                        }
                    } else if (visualMode === 'default') {
                        // DEFAULT MODE: No audio-reactive burst/hole effect
                        // Forces remain 0
                    } else {
                        // CRUNCH MODE: Directional wave sweep across screen - MORE DRAMATIC
                        // Calculate distance from wave front for mids
                        const midWaveX = Math.cos(crunchMidAngle);
                        const midWaveY = Math.sin(crunchMidAngle);
                        const midDistFromFront = (p.x - canvasWidth * 0.5) * midWaveX + (p.y - canvasHeight * 0.5) * midWaveY + crunchMidOffset;
                        const midWaveWidth = 500;

                        if (Math.abs(midDistFromFront) < midWaveWidth) {
                            const midStrength = (1 - Math.abs(midDistFromFront) / midWaveWidth) * midsLevel;
                            const perpAngle = crunchMidAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.01, p.y * 0.01 + time * 0.001) > 0 ? 1 : -1;
                            midForceX = Math.cos(perpAngle) * midStrength * 180 * amplitude * waveDir;
                            midForceY = Math.sin(perpAngle) * midStrength * 180 * amplitude * waveDir;
                        }

                        // Calculate distance from wave front for highs
                        const highWaveX = Math.cos(crunchHighAngle);
                        const highWaveY = Math.sin(crunchHighAngle);
                        const highDistFromFront = (p.x - canvasWidth * 0.5) * highWaveX + (p.y - canvasHeight * 0.5) * highWaveY + crunchHighOffset;
                        const highWaveWidth = 400;

                        if (Math.abs(highDistFromFront) < highWaveWidth) {
                            const highStrength = (1 - Math.abs(highDistFromFront) / highWaveWidth) * highsLevel;
                            const perpAngle = crunchHighAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.015, p.y * 0.015 + time * 0.0015) > 0 ? 1 : -1;
                            highForceX = Math.cos(perpAngle) * highStrength * 220 * amplitude * waveDir;
                            highForceY = Math.sin(perpAngle) * highStrength * 220 * amplitude * waveDir;
                        }
                    }

                    // Combine audio forces
                    p.audio.x = midForceX + highForceX;
                    p.audio.y = midForceY + highForceY;

                    // 4. Mouse interaction
                    const dx = p.x - state.mouse.sx;
                    const dy = p.y - state.mouse.sy;
                    const distance = Math.hypot(dx, dy);
                    const influenceRadius = Math.max(config.cursorRadius, state.mouse.vs);

                    if (distance < influenceRadius) {
                        const strength = 1 - distance / influenceRadius;
                        const force = Math.cos(distance * 0.001) * strength;

                        p.cursor.vx += Math.cos(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                        p.cursor.vy += Math.sin(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                    }

                    // Apply physics
                    p.cursor.vx += (0 - p.cursor.x) * config.restoration;
                    p.cursor.vy += (0 - p.cursor.y) * config.restoration;
                    p.cursor.vx *= config.damping;
                    p.cursor.vy *= config.damping;

                    p.cursor.x += p.cursor.vx;
                    p.cursor.y += p.cursor.vy;

                    // Limit displacement
                    p.cursor.x = Math.min(50, Math.max(-50, p.cursor.x));
                    p.cursor.y = Math.min(50, Math.max(-50, p.cursor.y));
                });
            });
        }

        // =====================================================
        // THEME RENDERERS
        // =====================================================

        function drawLinesLinear() {
            const theme = config.themes.linear;
            const { low, mid, high } = state.audioLevels;

            // Get values from control system (with fallbacks to old config)
            const hue = audioEngine ? (audioEngine.getValue('linear', 'hue') || theme.hue) : theme.hue;
            const saturation = audioEngine ? (audioEngine.getValue('linear', 'saturation') || theme.saturation) : theme.saturation;
            const opacity = audioEngine ? (audioEngine.getValue('linear', 'opacity') || theme.opacity) : theme.opacity;
            const lineWidth = audioEngine ? (audioEngine.getValue('linear', 'lineWidth') || 3) : 3;
            const backgroundShift = audioEngine ? (audioEngine.getValue('linear', 'backgroundShift') || 1.0) : 1.0;

            // Calculate background shift transform
            const shiftX = state.backgroundShift ? state.backgroundShift.x * backgroundShift : 0;
            const shiftY = state.backgroundShift ? state.backgroundShift.y * backgroundShift : 0;
            const transformString = shiftX !== 0 || shiftY !== 0 ? `translate(${shiftX}, ${shiftY})` : '';

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Calculate overall audio energy for dramatic effect
            const totalEnergy = (low + mid + high) / 3;
            const dynamicOpacity = opacity + totalEnergy * theme.opacityMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                // Start path
                const firstPoint = points[0];
                let pathData = `M ${
                    firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x
                } ${
                    firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y
                }`;

                // Draw line segments
                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = p.x + p.wave.x + p.cursor.x + p.audio.x;
                    const y = p.y + p.wave.y + p.cursor.y + p.audio.y;
                    pathData += ` L ${x} ${y}`;
                }

                // Update path with color values from control system
                const path = state.paths[lineIndex];
                path.setAttribute('d', pathData);
                path.removeAttribute('filter');

                // Apply background shift transform
                if (transformString) {
                    path.setAttribute('transform', transformString);
                } else {
                    path.removeAttribute('transform');
                }

                path.setAttribute('opacity', Math.min(1.0, dynamicOpacity));
                path.setAttribute('stroke-width', lineWidth);

                // Update stroke color from control system
                path.setAttribute('stroke', `hsl(${hue}, ${saturation}%, 50%)`);
            });
        }

        function drawLinesNeon() {
            const theme = config.themes.neon;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Get values from control system (with fallbacks)
            const colorMode = audioEngine ? (audioEngine.getValue('neon', 'colorMode') || state.settings.neonMode) : state.settings.neonMode;
            const colorChangeMode = audioEngine ? (audioEngine.getValue('neon', 'colorChangeMode') || 'static') : 'static';
            const cycleSpeed = audioEngine ? (audioEngine.getValue('neon', 'cycleSpeed') || 0.1) : 0.1;
            const warmCool = audioEngine ? (audioEngine.getValue('neon', 'warmCool') || state.settings.colorTemp) : state.settings.colorTemp;
            const burstSize = audioEngine ? (audioEngine.getValue('neon', 'burstSize') || state.settings.burstSize) : state.settings.burstSize;
            const movement = audioEngine ? (audioEngine.getValue('neon', 'movement') || 1.0) : 1.0;
            const glow = audioEngine ? (audioEngine.getValue('neon', 'glow') || 1.5) : 1.5;
            const baseHue = audioEngine ? (audioEngine.getValue('neon', 'hue') || 280) : 280;
            const baseSaturationControl = audioEngine ? (audioEngine.getValue('neon', 'saturation') || 70) : 70;
            const baseLightnessControl = audioEngine ? (audioEngine.getValue('neon', 'lightness') || 50) : 50;
            const blur = audioEngine ? (audioEngine.getValue('neon', 'blur') || 0) : 0;
            const responsiveness = audioEngine ? (audioEngine.getValue('neon', 'responsiveness') || 1.0) : 1.0;
            const smoothing = audioEngine ? (audioEngine.getValue('neon', 'smoothing') || 0.7) : 0.7;
            const meshDensity = audioEngine ? (audioEngine.getValue('neon', 'meshDensity') || 8) : 8;
            const backgroundShift = audioEngine ? (audioEngine.getValue('neon', 'backgroundShift') || 1.0) : 1.0;

            // Initialize NEON state if needed (for smoothing and reactive mode)
            if (!state.neon) {
                state.neon = {
                    smoothedAudio: { low: 0, mid: 0, high: 0 },
                    reactiveHue: baseHue,
                    lastBeatTime: 0,
                    targetHue: baseHue,
                    currentHue: baseHue
                };
            }

            // Apply exponential smoothing to audio levels
            const alpha = 1 - smoothing; // Smoothing factor (0 = full smooth, 1 = no smooth)
            state.neon.smoothedAudio.low = state.neon.smoothedAudio.low + (low - state.neon.smoothedAudio.low) * alpha;
            state.neon.smoothedAudio.mid = state.neon.smoothedAudio.mid + (mid - state.neon.smoothedAudio.mid) * alpha;
            state.neon.smoothedAudio.high = state.neon.smoothedAudio.high + (high - state.neon.smoothedAudio.high) * alpha;

            // Apply responsiveness multiplier to smoothed audio (amplifies/dampens audio response)
            const lowSmooth = state.neon.smoothedAudio.low * responsiveness;
            const midSmooth = state.neon.smoothedAudio.mid * responsiveness;
            const highSmooth = state.neon.smoothedAudio.high * responsiveness;

            // Hide all line paths for NEON theme
            state.paths.forEach(path => {
                path.setAttribute('d', '');
                path.setAttribute('opacity', '0');
            });

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // Always render gradient mesh background
            // Get or create gradient mesh container
            let gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (!gradientMeshGroup) {
                gradientMeshGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gradientMeshGroup.setAttribute('id', 'neon-gradient-mesh');
                elements.svg.appendChild(gradientMeshGroup);
            }

            // Apply background shift transform
            const shiftX = state.backgroundShift ? state.backgroundShift.x * backgroundShift : 0;
            const shiftY = state.backgroundShift ? state.backgroundShift.y * backgroundShift : 0;
            if (shiftX !== 0 || shiftY !== 0) {
                gradientMeshGroup.setAttribute('transform', `translate(${shiftX}, ${shiftY})`);
            } else {
                gradientMeshGroup.removeAttribute('transform');
            }

            // Color settings are now from control system
            const colorTempIntensity = warmCool;

            // Calculate hue based on color change mode
            let hueShift;
            switch (colorChangeMode) {
                case 'static':
                    // No color change - use base hue directly
                    hueShift = baseHue;
                    break;

                case 'cycle':
                    // Continuous rotation through color wheel
                    hueShift = (baseHue + time * cycleSpeed * 100) % 360;
                    break;

                case 'pulse':
                    // Oscillate between complementary colors
                    const pulseOffset = Math.sin(time * cycleSpeed * 2) * 60;
                    hueShift = (baseHue + pulseOffset) % 360;
                    break;

                case 'reactive':
                    // Jump to random hue on beat detection
                    const beatDetected = state.audioLevels.beat > 0.5;
                    if (beatDetected && (time - state.neon.lastBeatTime) > 300) {
                        // Generate new random hue on beat
                        state.neon.targetHue = Math.random() * 360;
                        state.neon.lastBeatTime = time;
                    }
                    // Smoothly interpolate to target hue
                    const lerpSpeed = 0.1;
                    state.neon.currentHue = state.neon.currentHue + (state.neon.targetHue - state.neon.currentHue) * lerpSpeed;
                    hueShift = state.neon.currentHue % 360;
                    break;

                default:
                    hueShift = baseHue;
            }

            // Saturation mapping: use control value as base, modulate with smoothed audio
            const saturationFromLow = lowSmooth * 30; // Bass increases saturation
            const saturationFromHigh = -highSmooth * 20; // Highs decrease saturation
            const saturation = Math.max(0, Math.min(100, baseSaturationControl + saturationFromLow + saturationFromHigh));

            // Lightness: use control value as base, modulate with smoothed audio
            const lightnessFromLow = -lowSmooth * 20; // Darken with bass
            const lightnessFromHigh = highSmooth * 30; // Brighten with highs
            const lightness = Math.max(20, Math.min(90, baseLightnessControl + lightnessFromLow + lightnessFromHigh));

            // Movement: More dramatic with bass - uses movement control value and smoothed audio
            const movementAmplitude = (theme.movementBase + lowSmooth * theme.movementMultiplier) * movement;

            // Size: Dramatic pulsing with all frequencies combined - uses burstSize control value and smoothed audio
            const combinedEnergy = (lowSmooth * 0.5 + midSmooth * 0.3 + highSmooth * 0.2);
            const sizeMultiplier = theme.sizeMultiplierBase + combinedEnergy * theme.sizeMultiplierRange;

            // Debug logging for NEON renderer (every ~1 second)
            if (Math.random() < 0.016) {
                console.log('🎨 NEON Render:', {
                    audioLevels: { low, mid, high },
                    smoothedLevels: { lowSmooth: lowSmooth.toFixed(2), midSmooth: midSmooth.toFixed(2), highSmooth: highSmooth.toFixed(2) },
                    controls: { responsiveness, smoothing: smoothing.toFixed(2), colorChangeMode },
                    hueShift: hueShift.toFixed(1),
                    saturation: saturation.toFixed(1),
                    lightness: lightness.toFixed(1),
                    movementAmplitude: movementAmplitude.toFixed(1),
                    sizeMultiplier: sizeMultiplier.toFixed(2)
                });
            }

            // Create multiple gradient centers for organic look
            // Use meshDensity control to determine number of gradient centers
            const numBaseCenters = Math.floor(meshDensity);
            const numUserCenters = state.userGradientCenters.length;

            // Get or create gradient definitions in defs
            let defsElement = elements.svg.querySelector('defs');
            if (!defsElement) {
                defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                elements.svg.insertBefore(defsElement, elements.svg.firstChild);
            }

            // Clear and recreate gradient mesh
            gradientMeshGroup.innerHTML = '';

            // Render base gradient centers
            for (let i = 0; i < numBaseCenters; i++) {
                // Calculate organic position using noise
                const noiseX = state.noise(time * 0.0005 + i * 10, i * 20) * movementAmplitude;
                const noiseY = state.noise(time * 0.0007 + i * 15, i * 25 + 100) * movementAmplitude;

                // Base position distributed around the screen
                const baseX = canvasWidth * (0.2 + (i / numBaseCenters) * 0.6);
                const baseY = canvasHeight * (0.3 + Math.sin(i * 2) * 0.4);

                const cx = baseX + noiseX;
                const cy = baseY + noiseY;

                // Calculate size based on audio and position
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.6;
                const radius = baseRadius * sizeMultiplier * burstSize;

                // Create radial gradient for this center
                const gradientId = `neon-radial-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Calculate hue for this center based on color mode
                let hue, finalSaturation, finalLightness;

                if (colorMode === 'gray') {
                    // Grayscale mode: no hue, zero saturation, full lightness range
                    hue = 0;
                    finalSaturation = 0;
                    // Expand lightness range for grayscale: 0% (black) to 100% (white)
                    finalLightness = Math.max(0, Math.min(100, lightness));
                } else if (colorMode === 'pastel') {
                    // Pastel mode: Map warm colors to highs, cool colors to lows
                    // Cool (blue/cyan): 180-240, Warm (red/orange/yellow): 0-60
                    const frequencyBalance = (high - low) * colorTempIntensity; // -1 to 1 range
                    // Map: -1 (low/cool) = 210 (cyan-blue), +1 (high/warm) = 30 (orange-red)
                    const frequencyHue = 120 - frequencyBalance * 90; // 210 to 30
                    const baseHueOffset = theme.baseHues[i % theme.baseHues.length];
                    hue = ((frequencyHue + baseHueOffset * 0.3 + hueShift * 0.5) % 360);

                    // Pastel colors: higher saturation but softer
                    finalSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                    finalLightness = Math.max(60, Math.min(85, lightness + 10)); // Lighter for pastel
                } else {
                    // Bright mode (default): Original vibrant colors
                    const baseHueOffset = theme.baseHues[i % theme.baseHues.length];
                    hue = (baseHueOffset + hueShift) % 360;
                    finalSaturation = saturation;
                    finalLightness = lightness;
                }

                // Create gradient stops for smooth fade
                const stops = [
                    { offset: '0%', opacity: 0.8 },
                    { offset: '40%', opacity: 0.6 },
                    { offset: '70%', opacity: 0.3 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${hue}, ${finalSaturation}%, ${finalLightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Render user-created gradient centers
            for (let i = 0; i < numUserCenters; i++) {
                const userCenter = state.userGradientCenters[i];
                const cx = userCenter.x;
                const cy = userCenter.y;

                // Calculate size - larger for user centers to make them more prominent
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.5;
                const radius = baseRadius * sizeMultiplier * 1.2 * state.settings.burstSize; // 20% larger + burst size

                // Create radial gradient for this user center
                const gradientId = `neon-user-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Calculate hue for user center based on color mode
                let userHue, userSaturation, userLightness;

                if (colorMode === 'gray') {
                    // Grayscale mode: full lightness range
                    userHue = 0;
                    userSaturation = 0;
                    userLightness = Math.max(0, Math.min(100, lightness));
                } else if (colorMode === 'pastel') {
                    // Pastel mode with frequency mapping
                    const frequencyBalance = (high - low) * colorTempIntensity;
                    const frequencyHue = 120 - frequencyBalance * 90;
                    const baseHue = theme.baseHues[i % theme.baseHues.length];
                    userHue = ((frequencyHue + baseHue * 0.3 + hueShift * 0.5 + 45) % 360);
                    userSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                    userLightness = Math.max(60, Math.min(85, lightness + 10));
                } else {
                    // Bright mode
                    userHue = (theme.baseHues[i % theme.baseHues.length] + hueShift + 45) % 360;
                    userSaturation = saturation;
                    userLightness = lightness;
                }

                // Create gradient stops with higher initial opacity for user centers
                const stops = [
                    { offset: '0%', opacity: 0.95 },
                    { offset: '30%', opacity: 0.75 },
                    { offset: '60%', opacity: 0.4 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${userHue}, ${userSaturation}%, ${userLightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Update glow filter based on bass and blur control
            const blurRadius = (theme.blurBase + low * theme.blurMultiplier + blur * 2) * glow;
            const filter = elements.svg.querySelector('#neon-glow');
            if (filter) {
                const blur1 = filter.querySelector('feGaussianBlur[result="blur1"]');
                const blur2 = filter.querySelector('feGaussianBlur[result="blur2"]');
                const blur3 = filter.querySelector('feGaussianBlur[result="blur3"]');

                if (blur1) blur1.setAttribute('stdDeviation', blurRadius * 0.5);
                if (blur2) blur2.setAttribute('stdDeviation', blurRadius);
                if (blur3) blur3.setAttribute('stdDeviation', blurRadius * 1.5);

                // Debug blur values
                if (Math.random() < 0.016) {
                    console.log('✨ Blur Filter:', {
                        low,
                        blurRadius: blurRadius.toFixed(2),
                        blur1: (blurRadius * 0.5).toFixed(2),
                        blur2: blurRadius.toFixed(2),
                        blur3: (blurRadius * 1.5).toFixed(2)
                    });
                }
            }
        }

        function renderNeonImage(canvas, theme, low, mid, high, time, canvasWidth, canvasHeight, img, themeBlur = 0, themeOpacity = 1.0) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw base image
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Get color mode settings
            const colorMode = state.settings.neonMode;
            const colorTempIntensity = state.settings.colorTemp;

            // Calculate audio-reactive parameters
            const hueShift = (mid * 360 + time * 0.05) % 360;

            // Saturation mapping
            const baseSaturation = theme.saturationBase + high * theme.saturationMultiplier;
            const saturationFromLow = low * 30;
            const saturationFromHigh = -high * 20;
            const saturation = Math.max(0, Math.min(100, baseSaturation + saturationFromLow + saturationFromHigh));

            // Lightness
            const lightnessFromLow = -low * theme.lightnessRange * 0.5;
            const lightnessFromHigh = high * theme.lightnessRange * 0.7;
            const lightness = theme.lightnessBase + lightnessFromLow + lightnessFromHigh;

            // Blur based on bass
            const blurRadius = theme.blurBase + low * theme.blurMultiplier;

            // Apply gradient overlay effect
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
            );

            // Calculate color based on mode
            let hue, finalSaturation, finalLightness;

            if (colorMode === 'gray') {
                hue = 0;
                finalSaturation = 0;
                // Expand lightness range for grayscale: 0% (black) to 100% (white)
                finalLightness = Math.max(0, Math.min(100, lightness));
            } else if (colorMode === 'pastel') {
                const frequencyBalance = (high - low) * colorTempIntensity;
                const frequencyHue = 120 - frequencyBalance * 90;
                hue = ((frequencyHue + hueShift * 0.5) % 360);
                finalSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                finalLightness = Math.max(60, Math.min(85, lightness + 10));
            } else {
                // Bright mode
                hue = (180 + hueShift) % 360; // Cyan base
                finalSaturation = saturation;
                finalLightness = lightness;
            }

            // Create gradient stops (apply theme opacity)
            gradient.addColorStop(0, `hsla(${hue}, ${finalSaturation}%, ${finalLightness}%, ${0.6 * themeOpacity})`);
            gradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, ${finalSaturation}%, ${finalLightness}%, ${0.3 * themeOpacity})`);
            gradient.addColorStop(1, `hsla(${(hue + 120) % 360}, ${finalSaturation}%, ${finalLightness}%, 0)`);

            // Apply gradient overlay with blend mode
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = themeOpacity;
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            // Apply blur filter if supported
            if (blurRadius > 0) {
                ctx.filter = `blur(${blurRadius}px)`;
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        function drawLinesGlitch() {
            const theme = config.themes.glitch;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Hide all line paths for GLITCH theme (show black background)
            state.paths.forEach((path) => {
                path.setAttribute('d', '');
            });

            // If an image is loaded, render it with glitch effect
            if (state.glitchImage.loaded && state.glitchImage.img) {
                const canvas = document.getElementById('theme-canvas');
                if (canvas) {
                    canvas.style.display = 'block';

                    // Set canvas size to fill entire container
                    canvas.width = state.boundingRect.width;
                    canvas.height = state.boundingRect.height;
                    canvas.style.width = state.boundingRect.width + 'px';
                    canvas.style.height = state.boundingRect.height + 'px';
                    canvas.style.left = '0px';
                    canvas.style.top = '0px';

                    renderGlitchImageBackground(
                        canvas,
                        theme,
                        low,
                        mid,
                        high,
                        time,
                        state.glitchImage.img
                    );
                }
            } else {
                // Hide canvas when no image is loaded
                const canvas = document.getElementById('theme-canvas');
                if (canvas) {
                    canvas.style.display = 'none';
                }
            }
        }

        function renderGlitchImageBackground(canvas, theme, low, mid, high, time, img) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Get values from control system (with fallbacks)
            const rotation = audioEngine ? (audioEngine.getValue('glitch', 'rotation') || state.settings.rotationIntensity) : state.settings.rotationIntensity;
            const glitchIntensityControl = audioEngine ? (audioEngine.getValue('glitch', 'glitchIntensity') || state.settings.glitchEffectIntensity) : state.settings.glitchEffectIntensity;
            const contrast = audioEngine ? (audioEngine.getValue('glitch', 'contrast') || 1.0) : 1.0;
            const channelOffsetControl = audioEngine ? (audioEngine.getValue('glitch', 'channelOffset') || 5) : 5;
            const displacementControl = audioEngine ? (audioEngine.getValue('glitch', 'displacement') || 10) : 10;
            const scanlinesControl = audioEngine ? (audioEngine.getValue('glitch', 'scanlines') || 0) : 0;
            const noiseControl = audioEngine ? (audioEngine.getValue('glitch', 'noise') || 0) : 0;
            const pixelationControl = audioEngine ? (audioEngine.getValue('glitch', 'pixelation') || 1) : 1;
            const backgroundShift = audioEngine ? (audioEngine.getValue('glitch', 'backgroundShift') || 1.0) : 1.0;

            // Calculate glitch parameters with user intensity multipliers
            const glitchEffectIntensity = glitchIntensityControl;
            const channelSeparation = channelOffsetControl;
            const glitchIntensity = displacementControl;
            const quantization = Math.max(1, pixelationControl);

            // Calculate 3D rotation based on audio with user intensity multiplier
            const rotationIntensity = rotation;
            const rotationX = mid * 45 * rotationIntensity;
            const rotationY = high * 45 * rotationIntensity;
            const rotationZ = low * 15 * rotationIntensity;

            // Apply 3D transform to canvas
            const perspective = 1000;
            canvas.style.transformStyle = 'preserve-3d';
            canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply background shift
            const shiftX = state.backgroundShift ? state.backgroundShift.x * backgroundShift : 0;
            const shiftY = state.backgroundShift ? state.backgroundShift.y * backgroundShift : 0;
            ctx.save();
            ctx.translate(shiftX, shiftY);

            // Apply quantization/pixelation by scaling down and up
            const pixelSize = Math.max(1, Math.floor(quantization));
            const scaledWidth = Math.floor(canvas.width / pixelSize);
            const scaledHeight = Math.floor(canvas.height / pixelSize);

            // Create temporary canvas for RGB channel separation
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Use stored image dimensions and position from state.glitchImage
            const drawWidth = state.glitchImage.width;
            const drawHeight = state.glitchImage.height;
            const drawX = state.glitchImage.x;
            const drawY = state.glitchImage.y;

            // Draw pixelated base image with user-defined size
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            tempCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight, drawX, drawY, drawWidth, drawHeight);

            // Get image data for RGB channel manipulation
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply glitch effects (scanlines, blocks, etc) - same as renderGlitchImage
            const scanlineGlitchChance = mid * 0.3 * glitchEffectIntensity;
            for (let y = 0; y < canvas.height; y++) {
                if (Math.random() < scanlineGlitchChance) {
                    const offset = Math.floor((Math.random() - 0.5) * glitchIntensity * 30);
                    if (offset !== 0) {
                        const rowStart = y * canvas.width * 4;
                        const rowData = data.slice(rowStart, rowStart + canvas.width * 4);

                        for (let x = 0; x < canvas.width; x++) {
                            const sourceX = Math.max(0, Math.min(canvas.width - 1, x - offset));
                            const sourceIdx = sourceX * 4;
                            const targetIdx = rowStart + x * 4;

                            data[targetIdx] = rowData[sourceIdx];
                            data[targetIdx + 1] = rowData[sourceIdx + 1];
                            data[targetIdx + 2] = rowData[sourceIdx + 2];
                            data[targetIdx + 3] = rowData[sourceIdx + 3];
                        }
                    }
                }
            }

            // Add random block corruption
            const blockGlitchChance = low * 0.15 * glitchEffectIntensity;
            const numBlocks = Math.floor(low * 10 * glitchEffectIntensity);
            for (let b = 0; b < numBlocks; b++) {
                if (Math.random() < blockGlitchChance) {
                    const blockX = Math.floor(Math.random() * canvas.width);
                    const blockY = Math.floor(Math.random() * canvas.height);
                    const blockWidth = Math.floor(Math.random() * glitchIntensity * 40 + 10);
                    const blockHeight = Math.floor(Math.random() * glitchIntensity * 20 + 5);
                    const glitchType = Math.random();

                    for (let y = blockY; y < Math.min(blockY + blockHeight, canvas.height); y++) {
                        for (let x = blockX; x < Math.min(blockX + blockWidth, canvas.width); x++) {
                            const idx = (y * canvas.width + x) * 4;

                            if (glitchType < 0.33) {
                                data[idx] = 255 - data[idx];
                                data[idx + 1] = 255 - data[idx + 1];
                                data[idx + 2] = 255 - data[idx + 2];
                            } else if (glitchType < 0.66) {
                                const temp = data[idx];
                                data[idx] = data[idx + 2];
                                data[idx + 2] = temp;
                            }
                        }
                    }
                }
            }

            // Put modified image data back
            tempCtx.putImageData(imageData, 0, 0);

            // RGB Channel Separation - use visualMode from control system
            const visualMode = audioEngine ? (audioEngine.getValue('glitch', 'visualMode') || state.settings.glitchMode) : state.settings.glitchMode;
            const glitchMode = visualMode || 'rgb';
            const redCanvas = document.createElement('canvas');
            const greenCanvas = document.createElement('canvas');
            const blueCanvas = document.createElement('canvas');

            redCanvas.width = greenCanvas.width = blueCanvas.width = canvas.width;
            redCanvas.height = greenCanvas.height = blueCanvas.height = canvas.height;

            const redCtx = redCanvas.getContext('2d');
            const greenCtx = greenCanvas.getContext('2d');
            const blueCtx = blueCanvas.getContext('2d');

            const redData = ctx.createImageData(canvas.width, canvas.height);
            const greenData = ctx.createImageData(canvas.width, canvas.height);
            const blueData = ctx.createImageData(canvas.width, canvas.height);

            for (let i = 0; i < data.length; i += 4) {
                if (glitchMode === 'rgb') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = 0;
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                } else if (glitchMode === 'br') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = 0;
                    blueData.data[i + 3] = 0;
                } else if (glitchMode === 'gray') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = data[i + 1];
                    redData.data[i + 2] = data[i + 2];
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = data[i];
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = data[i];
                    blueData.data[i + 1] = data[i + 1];
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                }
            }

            redCtx.putImageData(redData, 0, 0);
            greenCtx.putImageData(greenData, 0, 0);
            blueCtx.putImageData(blueData, 0, 0);

            // Composite the channels with separation
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'lighter';

            // Apply contrast filter (using control system value)
            ctx.filter = `contrast(${contrast})`;

            ctx.drawImage(redCanvas, -channelSeparation, 0);
            ctx.drawImage(greenCanvas, 0, 0);
            ctx.drawImage(blueCanvas, channelSeparation, 0);

            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';

            // Apply scanlines effect (CRT-style horizontal lines)
            if (scanlinesControl > 0) {
                ctx.globalAlpha = scanlinesControl * 0.3;
                ctx.fillStyle = '#000000';
                for (let y = 0; y < canvas.height; y += 4) {
                    ctx.fillRect(0, y, canvas.width, 2);
                }
                ctx.globalAlpha = 1.0;
            }

            // Apply noise overlay (static grain)
            if (noiseControl > 0) {
                const noiseData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = noiseData.data;
                const noiseAmount = noiseControl * 50;
                for (let i = 0; i < pixels.length; i += 4) {
                    const noise = (Math.random() - 0.5) * noiseAmount;
                    pixels[i] += noise;     // R
                    pixels[i + 1] += noise; // G
                    pixels[i + 2] += noise; // B
                }
                ctx.putImageData(noiseData, 0, 0);
            }

            // Restore canvas state
            ctx.restore();
        }

        function renderGlitchImage(canvas, theme, low, mid, high, time, img, themeBlur = 0, themeOpacity = 1.0, baseRotation = 0) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Calculate glitch parameters with user intensity multipliers
            const glitchEffectIntensity = state.settings.glitchEffectIntensity;
            const channelSeparation = (theme.channelSeparationBase + low * theme.channelSeparationMultiplier) * glitchEffectIntensity;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier * glitchEffectIntensity;
            const quantization = Math.max(1, (theme.quantizationBase + high * theme.quantizationMultiplier) * glitchEffectIntensity);

            // Calculate 3D rotation based on audio with user intensity multiplier
            // Use image3DMotion setting for image objects
            const motionIntensity = state.settings.image3DMotion;
            const rotationX = mid * 45 * motionIntensity; // Mids control pitch (X-axis rotation)
            const rotationY = high * 45 * motionIntensity; // Highs control yaw (Y-axis rotation)
            const rotationZ = low * 15 * motionIntensity + baseRotation; // Bass controls roll (Z-axis rotation) + user rotation

            // Apply 3D transform to canvas
            const perspective = 1000;
            canvas.style.transformStyle = 'preserve-3d';
            canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply quantization/pixelation by scaling down and up
            const pixelSize = Math.max(1, Math.floor(quantization));
            const scaledWidth = Math.floor(canvas.width / pixelSize);
            const scaledHeight = Math.floor(canvas.height / pixelSize);

            // Create temporary canvas for RGB channel separation
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw pixelated base image
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            tempCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight, 0, 0, canvas.width, canvas.height);

            // Get image data for RGB channel manipulation
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply random glitch displacement to scan lines (controlled by mids)
            const scanlineGlitchChance = mid * 0.3 * glitchEffectIntensity;
            for (let y = 0; y < canvas.height; y++) {
                if (Math.random() < scanlineGlitchChance) {
                    const offset = Math.floor((Math.random() - 0.5) * glitchIntensity * 30);
                    if (offset !== 0) {
                        const rowStart = y * canvas.width * 4;
                        const rowData = data.slice(rowStart, rowStart + canvas.width * 4);

                        for (let x = 0; x < canvas.width; x++) {
                            const sourceX = Math.max(0, Math.min(canvas.width - 1, x - offset));
                            const sourceIdx = sourceX * 4;
                            const targetIdx = rowStart + x * 4;

                            data[targetIdx] = rowData[sourceIdx];
                            data[targetIdx + 1] = rowData[sourceIdx + 1];
                            data[targetIdx + 2] = rowData[sourceIdx + 2];
                            data[targetIdx + 3] = rowData[sourceIdx + 3];
                        }
                    }
                }
            }

            // Add random block corruption based on bass (creates chunky glitches)
            const blockGlitchChance = low * 0.15 * glitchEffectIntensity;
            const numBlocks = Math.floor(low * 10 * glitchEffectIntensity);
            for (let b = 0; b < numBlocks; b++) {
                if (Math.random() < blockGlitchChance) {
                    const blockX = Math.floor(Math.random() * canvas.width);
                    const blockY = Math.floor(Math.random() * canvas.height);
                    const blockWidth = Math.floor(Math.random() * glitchIntensity * 40 + 10);
                    const blockHeight = Math.floor(Math.random() * glitchIntensity * 20 + 5);

                    // Random glitch type
                    const glitchType = Math.random();

                    for (let y = blockY; y < Math.min(blockY + blockHeight, canvas.height); y++) {
                        for (let x = blockX; x < Math.min(blockX + blockWidth, canvas.width); x++) {
                            const idx = (y * canvas.width + x) * 4;

                            if (glitchType < 0.33) {
                                // Color inversion
                                data[idx] = 255 - data[idx];
                                data[idx + 1] = 255 - data[idx + 1];
                                data[idx + 2] = 255 - data[idx + 2];
                            } else if (glitchType < 0.66) {
                                // Channel swap
                                const temp = data[idx];
                                data[idx] = data[idx + 2];
                                data[idx + 2] = temp;
                            } else {
                                // Random shift within block
                                const shiftX = Math.floor((Math.random() - 0.5) * 20);
                                const sourceX = Math.max(0, Math.min(canvas.width - 1, x + shiftX));
                                const sourceIdx = (y * canvas.width + sourceX) * 4;
                                data[idx] = data[sourceIdx];
                                data[idx + 1] = data[sourceIdx + 1];
                                data[idx + 2] = data[sourceIdx + 2];
                            }
                        }
                    }
                }
            }

            // Add vertical tears based on highs (sudden glitch lines)
            const tearChance = high * 0.2 * glitchEffectIntensity;
            const numTears = Math.floor(high * 5 * glitchEffectIntensity);
            for (let t = 0; t < numTears; t++) {
                if (Math.random() < tearChance) {
                    const tearX = Math.floor(Math.random() * canvas.width);
                    const tearWidth = Math.floor(Math.random() * 5 + 1);
                    const tearOffset = Math.floor((Math.random() - 0.5) * glitchIntensity * 15);

                    for (let y = 0; y < canvas.height; y++) {
                        for (let dx = 0; dx < tearWidth; dx++) {
                            const x = tearX + dx;
                            if (x >= 0 && x < canvas.width) {
                                const sourceY = Math.max(0, Math.min(canvas.height - 1, y + tearOffset));
                                const targetIdx = (y * canvas.width + x) * 4;
                                const sourceIdx = (sourceY * canvas.width + x) * 4;

                                data[targetIdx] = data[sourceIdx];
                                data[targetIdx + 1] = data[sourceIdx + 1];
                                data[targetIdx + 2] = data[sourceIdx + 2];
                                data[targetIdx + 3] = data[sourceIdx + 3];
                            }
                        }
                    }
                }
            }

            // Get glitch mode
            const glitchMode = state.settings.glitchMode;

            // Apply grayscale conversion if in GRAY mode
            if (glitchMode === 'gray') {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
            }

            // Create canvases for channel separation
            const redCanvas = document.createElement('canvas');
            redCanvas.width = canvas.width;
            redCanvas.height = canvas.height;
            const redCtx = redCanvas.getContext('2d');

            const greenCanvas = document.createElement('canvas');
            greenCanvas.width = canvas.width;
            greenCanvas.height = canvas.height;
            const greenCtx = greenCanvas.getContext('2d');

            const blueCanvas = document.createElement('canvas');
            blueCanvas.width = canvas.width;
            blueCanvas.height = canvas.height;
            const blueCtx = blueCanvas.getContext('2d');

            // Extract individual color channels based on mode
            const redData = ctx.createImageData(canvas.width, canvas.height);
            const greenData = ctx.createImageData(canvas.width, canvas.height);
            const blueData = ctx.createImageData(canvas.width, canvas.height);

            for (let i = 0; i < data.length; i += 4) {
                if (glitchMode === 'rgb') {
                    // RGB mode: Full RGB separation
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = 0;
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                } else if (glitchMode === 'br') {
                    // B&R mode: Red and Cyan (like 3D glasses)
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    // Cyan channel (green + blue)
                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    // Blue stays empty for B&R mode
                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = 0;
                    blueData.data[i + 3] = 0;
                } else if (glitchMode === 'gray') {
                    // Grayscale mode: Use grayscale for all channels
                    redData.data[i] = data[i];
                    redData.data[i + 1] = data[i + 1];
                    redData.data[i + 2] = data[i + 2];
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = data[i];
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = data[i];
                    blueData.data[i + 1] = data[i + 1];
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                }
            }

            redCtx.putImageData(redData, 0, 0);
            greenCtx.putImageData(greenData, 0, 0);
            blueCtx.putImageData(blueData, 0, 0);

            // Composite the channels with separation and random variations
            const randomOffsetX = (Math.random() - 0.5) * channelSeparation * 0.5;
            const randomOffsetY = (Math.random() - 0.5) * channelSeparation * 0.5;

            // Apply contrast filter
            const contrast = state.settings.glitchContrast;
            ctx.filter = `contrast(${contrast})`;

            if (glitchMode === 'gray') {
                // GRAY mode: Single render to avoid overexposure
                // Apply subtle offset variations for glitch effect
                ctx.globalCompositeOperation = 'source-over';

                const offsetX = (Math.random() - 0.5) * channelSeparation * 0.5 * low;
                const offsetY = (Math.random() - 0.5) * channelSeparation * 0.5 * mid;

                ctx.putImageData(imageData, offsetX, offsetY);
            } else {
                // RGB and B&R modes: Use lighter blend mode for color separation
                ctx.globalCompositeOperation = 'lighter';

                if (glitchMode === 'rgb') {
                    // RGB mode: All three channels with separation
                    // Red channel (offset left with random variation)
                    const redOffsetX = -channelSeparation + randomOffsetX * low * 2;
                    const redOffsetY = randomOffsetY * mid;
                    ctx.drawImage(redCanvas, redOffsetX, redOffsetY);

                    // Green channel (slightly offset with random jitter)
                    const greenOffsetX = (Math.random() - 0.5) * channelSeparation * 0.3 * mid;
                    const greenOffsetY = (Math.random() - 0.5) * channelSeparation * 0.3 * high;
                    ctx.drawImage(greenCanvas, greenOffsetX, greenOffsetY);

                    // Blue channel (offset right and down with variation)
                    const blueOffsetX = channelSeparation + randomOffsetX * high * 2;
                    const blueOffsetY = channelSeparation * 0.5 + randomOffsetY * low;
                    ctx.drawImage(blueCanvas, blueOffsetX, blueOffsetY);
                } else if (glitchMode === 'br') {
                    // B&R mode: Only red and cyan (like 3D glasses)
                    // Red channel (offset left)
                    const redOffsetX = -channelSeparation + randomOffsetX * low * 2;
                    const redOffsetY = randomOffsetY * mid;
                    ctx.drawImage(redCanvas, redOffsetX, redOffsetY);

                    // Cyan channel (offset right) - stored in greenCanvas
                    const cyanOffsetX = channelSeparation + randomOffsetX * high * 2;
                    const cyanOffsetY = randomOffsetY * low;
                    ctx.drawImage(greenCanvas, cyanOffsetX, cyanOffsetY);
                }
            }

            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';
        }

        function renderGlitchLines(theme, low, mid, high) {
            // Calculate glitch parameters
            const channelSeparation = theme.channelSeparationBase + low * theme.channelSeparationMultiplier;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier;
            const quantization = theme.quantizationBase + high * theme.quantizationMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                const path = state.paths[lineIndex];

                // Random glitch displacement per line (controlled by mids)
                const lineGlitch = (Math.random() < mid * 0.3) ? Math.random() * glitchIntensity * 30 : 0;

                // Quantize position (pixelate effect controlled by highs)
                const quantize = (val) => Math.round(val / quantization) * quantization;

                // Build path with quantized positions
                const firstPoint = points[0];
                const fx = quantize(firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x + lineGlitch);
                const fy = quantize(firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y);

                let pathData = `M ${fx} ${fy}`;

                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = quantize(p.x + p.wave.x + p.cursor.x + p.audio.x + lineGlitch);
                    const y = quantize(p.y + p.wave.y + p.cursor.y + p.audio.y);
                    pathData += ` L ${x} ${y}`;
                }

                // RGB Channel Separation - render same path 3 times with color channels offset
                const colorIndex = lineIndex % theme.colors.length;
                const baseColor = theme.colors[colorIndex];

                // Red channel (offset left)
                const pathR = state.paths[lineIndex];
                pathR.setAttribute('d', pathData);
                pathR.setAttribute('stroke', baseColor);
                pathR.setAttribute('opacity', theme.opacity);
                pathR.setAttribute('transform', `translate(${-channelSeparation}, 0)`);
                pathR.removeAttribute('filter');

                // Create or get additional paths for G and B channels
                let pathG = elements.svg.querySelector(`#glitch-g-${lineIndex}`);
                if (!pathG) {
                    pathG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathG.setAttribute('id', `glitch-g-${lineIndex}`);
                    pathG.setAttribute('fill', 'none');
                    pathG.setAttribute('stroke-width', '1');
                    pathG.setAttribute('stroke-linecap', 'round');
                    pathG.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathG);
                }

                let pathB = elements.svg.querySelector(`#glitch-b-${lineIndex}`);
                if (!pathB) {
                    pathB = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathB.setAttribute('id', `glitch-b-${lineIndex}`);
                    pathB.setAttribute('fill', 'none');
                    pathB.setAttribute('stroke-width', '1');
                    pathB.setAttribute('stroke-linecap', 'round');
                    pathB.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathB);
                }

                // Green channel (no offset)
                const greenColor = theme.colors[(colorIndex + 1) % theme.colors.length];
                pathG.setAttribute('d', pathData);
                pathG.setAttribute('stroke', greenColor);
                pathG.setAttribute('opacity', theme.opacity);
                pathG.setAttribute('transform', 'translate(0, 0)');

                // Blue channel (offset right/down)
                const blueColor = theme.colors[(colorIndex + 2) % theme.colors.length];
                pathB.setAttribute('d', pathData);
                pathB.setAttribute('stroke', blueColor);
                pathB.setAttribute('opacity', theme.opacity);
                pathB.setAttribute('transform', `translate(${channelSeparation}, ${channelSeparation * 0.5})`);
            });

            // Clean up extra glitch paths if lines were reduced
            const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
            allGlitchPaths.forEach(path => {
                const match = path.id.match(/glitch-[gb]-(\d+)/);
                if (match && parseInt(match[1]) >= state.lines.length) {
                    path.remove();
                }
            });
        }

        // =====================================================
        // STARS THEME RENDERER
        // =====================================================

        function initializeStars() {
            const theme = config.themes.stars;
            const w = state.boundingRect.width;
            const h = state.boundingRect.height;

            // Create cached gradient texture for stars
            const gradientCanvas = document.createElement('canvas');
            const gradientCtx = gradientCanvas.getContext('2d');
            gradientCanvas.width = 100;
            gradientCanvas.height = 100;

            state.stars.gradientCanvas = gradientCanvas;
            state.stars.gradientCtx = gradientCtx;

            // Update gradient with current hue
            updateStarGradient();

            // Initialize star array
            state.stars.starArray = [];
            state.stars.count = 0;

            const maxOrbit = Math.round(Math.sqrt(w * w + h * h)) / 2 * state.settings.starDiameter;

            class Star {
                constructor() {
                    this.orbitRadius = Math.floor(Math.random() * maxOrbit);
                    this.baseRadius = Math.floor(Math.random() * (60 - this.orbitRadius / 12) + this.orbitRadius / 12);
                    this.radius = this.baseRadius; // Will be scaled by z
                    this.orbitX = w / 2;
                    this.orbitY = h / 2;
                    this.timePassed = Math.random() * state.settings.starCount;
                    this.baseSpeed = (Math.random() * this.orbitRadius * theme.baseSpeed);
                    // Use user settings for opacity range and brightness
                    this.alpha = (Math.random() * (state.settings.starMaxOpacity - state.settings.starMinOpacity) + state.settings.starMinOpacity) * state.settings.starBrightness;
                    // Z-axis depth (0 = far, 1 = close)
                    this.z = Math.random();
                    state.stars.starArray.push(this);
                }
            }

            // Use user setting for star count
            for (let i = 0; i < state.settings.starCount; i++) {
                new Star();
            }

            // Initialize center position to screen center
            state.stars.centerX = w / 2;
            state.stars.centerY = h / 2;
            state.stars.targetCenterX = w / 2;
            state.stars.targetCenterY = h / 2;

            state.stars.initialized = true;
            console.log(`✨ Initialized ${state.settings.starCount} stars`);
        }

        function updateStarGradient(hue, saturation) {
            const canvas = state.stars.gradientCanvas;
            const ctx = state.stars.gradientCtx;
            // Use parameters if provided, otherwise fallback to state
            const finalHue = hue !== undefined ? hue : (state.settings.starHue || 44);
            const finalSaturation = saturation !== undefined ? saturation : (state.settings.starSaturation || 12);
            const half = canvas.width / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const gradient = ctx.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0.025, '#fff');
            gradient.addColorStop(0.1, `hsl(${finalHue}, ${finalSaturation}%, 33%)`);
            gradient.addColorStop(0.25, `hsl(${finalHue}, ${Math.min(finalSaturation + 3, 100)}%, 6%)`);
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(half, half, half, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawLinesStars() {
            const theme = config.themes.stars;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Get values from control system (with fallbacks to old state)
            const hue = audioEngine ? (audioEngine.getValue('stars', 'hue') || state.settings.starHue) : state.settings.starHue;
            const saturation = audioEngine ? (audioEngine.getValue('stars', 'saturation') || state.settings.starSaturation) : state.settings.starSaturation;
            const speed = audioEngine ? (audioEngine.getValue('stars', 'speed') || state.settings.starSpeed) : state.settings.starSpeed;
            const brightness = audioEngine ? (audioEngine.getValue('stars', 'brightness') || state.settings.starBrightness) : state.settings.starBrightness;
            const zSpeed = audioEngine ? (audioEngine.getValue('stars', 'zSpeed') || state.settings.starZSpeed) : state.settings.starZSpeed;
            const backgroundShift = audioEngine ? (audioEngine.getValue('stars', 'backgroundShift') || 1.0) : 1.0;
            const minOpacity = audioEngine ? (audioEngine.getValue('stars', 'minOpacity') || state.settings.starMinOpacity) : state.settings.starMinOpacity;
            const maxOpacity = audioEngine ? (audioEngine.getValue('stars', 'maxOpacity') || state.settings.starMaxOpacity) : state.settings.starMaxOpacity;
            const diameter = audioEngine ? (audioEngine.getValue('stars', 'diameter') || 1.0) : 1.0;
            const twinkleRate = audioEngine ? (audioEngine.getValue('stars', 'twinkleRate') || state.settings.starTwinkle) : state.settings.starTwinkle;
            const audioBoost = audioEngine ? (audioEngine.getValue('stars', 'audioBoost') || state.settings.starAudioBoost) : state.settings.starAudioBoost;
            const count = audioEngine ? (audioEngine.getValue('stars', 'count') || state.settings.starCount) : state.settings.starCount;
            const trailLength = audioEngine ? (audioEngine.getValue('stars', 'trailLength') || 0) : 0;
            const bloom = audioEngine ? (audioEngine.getValue('stars', 'bloom') || 0) : 0;
            const perspective = audioEngine ? (audioEngine.getValue('stars', 'perspective') || 1.0) : 1.0;
            const smoothing = audioEngine ? (audioEngine.getValue('stars', 'smoothing') || 0.5) : 0.5;

            // Hide SVG paths for STARS theme
            state.paths.forEach(path => path.setAttribute('d', ''));

            // Initialize stars on first render
            if (!state.stars.initialized) {
                initializeStars();
            }

            // Get or create stars canvas
            let starsCanvas = document.getElementById('stars-canvas');
            if (!starsCanvas) {
                starsCanvas = document.createElement('canvas');
                starsCanvas.id = 'stars-canvas';
                starsCanvas.style.position = 'fixed';
                starsCanvas.style.top = '0';
                starsCanvas.style.left = '0';
                starsCanvas.style.width = '100%';
                starsCanvas.style.height = '100%';
                starsCanvas.style.pointerEvents = 'none';
                starsCanvas.style.zIndex = '0';
                document.body.insertBefore(starsCanvas, document.body.firstChild);
            }

            const ctx = starsCanvas.getContext('2d');
            const w = starsCanvas.width = state.boundingRect.width;
            const h = starsCanvas.height = state.boundingRect.height;

            // Update star gradient with current colors from control system
            updateStarGradient(hue, saturation);

            // Clear with fade effect (controlled by trailLength)
            // trailLength: 0 = no trails (alpha 1.0), 1 = long trails (alpha 0.3)
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0 - (trailLength * 0.7);
            ctx.fillStyle = theme.bg;
            ctx.fillRect(0, 0, w, h);

            // Apply background shift
            const shiftX = state.backgroundShift ? state.backgroundShift.x * backgroundShift : 0;
            const shiftY = state.backgroundShift ? state.backgroundShift.y * backgroundShift : 0;
            ctx.save();
            ctx.translate(shiftX, shiftY);

            // Calculate audio-reactive speed multiplier
            // Bass SLOWS DOWN orbit speed using user setting
            const speedBoost = 1.0 - (low * (audioBoost / 10));

            // Smoothly transition center position to target (controlled by smoothing slider)
            state.stars.centerX += (state.stars.targetCenterX - state.stars.centerX) * (1 - smoothing) * 0.1;
            state.stars.centerY += (state.stars.targetCenterY - state.stars.centerY) * (1 - smoothing) * 0.1;

            // STARS theme always uses the original gradient planes mode
            ctx.globalCompositeOperation = 'lighter';

            // PLANES MODE: Original gradient stars
                state.stars.starArray.forEach((star) => {
                    // Update Z position (move towards camera)
                    if (zSpeed > 0) {
                        star.z += zSpeed * 0.001;

                        // Reset star if it passes the camera
                        if (star.z >= 1.0) {
                            star.z = 0;
                            star.timePassed = Math.random() * count;
                        }
                    }

                    // Calculate perspective scale based on Z (0 = far/small, 1 = close/big)
                    // Perspective control adjusts depth effect intensity
                    const baseScale = 0.2;
                    const depthRange = 0.8 * perspective; // perspective multiplier (0-2)
                    const scale = baseScale + star.z * depthRange;

                    // Scale orbit radius and star size by perspective
                    const scaledOrbitRadius = star.orbitRadius * scale;
                    star.radius = star.baseRadius * scale * diameter;

                    // Use smoothed center position (click-to-center feature)
                    const x = Math.sin(star.timePassed) * scaledOrbitRadius + state.stars.centerX;
                    const y = Math.cos(star.timePassed) * scaledOrbitRadius + state.stars.centerY;

                    // Twinkle effect using user setting
                    const twinkle = Math.floor(Math.random() * twinkleRate);
                    if (twinkle === 1 && star.alpha > minOpacity) {
                        star.alpha -= 0.05;
                    } else if (twinkle === 2 && star.alpha < maxOpacity * brightness) {
                        star.alpha += 0.05;
                    }

                    // Mid frequencies add brightness boost
                    const brightnessBoost = mid * 0.3;

                    // Alpha also scales with distance (closer = brighter)
                    const perspectiveAlpha = (star.alpha + brightnessBoost) * scale;

                    ctx.globalAlpha = perspectiveAlpha;

                    // Apply bloom/glow effect if enabled
                    if (bloom > 0) {
                        const blurAmount = bloom * 10; // 0-20px blur range
                        ctx.filter = `blur(${blurAmount}px)`;
                    } else {
                        ctx.filter = 'none';
                    }

                    ctx.drawImage(
                        state.stars.gradientCanvas,
                        x - star.radius / 2,
                        y - star.radius / 2,
                        star.radius,
                        star.radius
                    );

                    // Update orbit with audio-reactive speed
                    star.timePassed += star.baseSpeed * speed * speedBoost;
                });

            ctx.globalAlpha = 1.0;

            // Restore canvas state
            ctx.restore();
        }

        // =====================================================
        // WAVE THEME RENDERING
        // =====================================================

        function initializeWave() {
            const theme = config.themes.wave;
            const w = state.boundingRect.width;
            const h = state.boundingRect.height;

            // Get grid density
            const density = theme.gridDensity[state.settings.waveDensity] || theme.gridDensity.medium;
            const cols = density.cols;
            const rows = density.rows;

            // Initialize grid nodes
            state.wave.gridNodes = [];
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    state.wave.gridNodes.push({
                        i,
                        j,
                        baseX: (i / (cols - 1)) * w,
                        baseY: (j / (rows - 1)) * h
                    });
                }
            }

            // Initialize orbital dots
            state.wave.orbitalDots = [];
            for (let i = 0; i < state.settings.waveDotCount; i++) {
                state.wave.orbitalDots.push({
                    centerX: Math.random() * w,
                    centerY: Math.random() * h,
                    angle: Math.random() * Math.PI * 2,
                    baseRadius: state.settings.waveOrbitSize,
                    speed: (Math.random() * 0.5 + 0.5) * 0.02
                });
            }

            state.wave.initialized = true;
            console.log(`🌊 Initialized WAVE theme: ${cols}x${rows} grid, ${state.settings.waveDotCount} dots`);
        }

        function drawLinesWave() {
            const theme = config.themes.wave;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Get values from control system (with fallbacks)
            const visualMode = audioEngine ? (audioEngine.getValue('wave', 'visualMode') || state.settings.waveMode) : state.settings.waveMode;
            const layers = audioEngine ? (audioEngine.getValue('wave', 'layers') || state.settings.waveLayers) : state.settings.waveLayers;
            const hue = audioEngine ? (audioEngine.getValue('wave', 'hue') || state.settings.waveHue) : state.settings.waveHue;
            const saturation = audioEngine ? (audioEngine.getValue('wave', 'saturation') || state.settings.waveSaturation) : state.settings.waveSaturation;
            const amplitude = audioEngine ? (audioEngine.getValue('wave', 'amplitude') || 1.0) : 1.0;
            const wavelength = audioEngine ? (audioEngine.getValue('wave', 'wavelength') || 1.0) : 1.0;
            const lineWidth = audioEngine ? (audioEngine.getValue('wave', 'lineWidth') || 2) : 2;
            const speed = audioEngine ? (audioEngine.getValue('wave', 'speed') || state.settings.starSpeed || 1.0) : (state.settings.starSpeed || 1.0);
            const rotationX = audioEngine ? (audioEngine.getValue('wave', 'rotationX') || 0) : 0;
            const rotationY = audioEngine ? (audioEngine.getValue('wave', 'rotationY') || 0) : 0;
            const glow = audioEngine ? (audioEngine.getValue('wave', 'glow') || 0) : 0;
            const perspective = audioEngine ? (audioEngine.getValue('wave', 'perspective') || 1.0) : 1.0;
            const depth = audioEngine ? (audioEngine.getValue('wave', 'depth') || 1.0) : 1.0;
            const turbulence = audioEngine ? (audioEngine.getValue('wave', 'turbulence') || 0) : 0;
            const phaseShift = audioEngine ? (audioEngine.getValue('wave', 'phaseShift') || 0) : 0;
            const backgroundShift = audioEngine ? (audioEngine.getValue('wave', 'backgroundShift') || 1.0) : 1.0;

            // Hide SVG paths for WAVE theme
            state.paths.forEach(path => path.setAttribute('d', ''));

            // Initialize stars on first render (we reuse stars array for wave theme)
            if (!state.stars.initialized) {
                initializeStars();
            }

            // Get or create wave canvas
            let waveCanvas = document.getElementById('wave-canvas');
            if (!waveCanvas) {
                waveCanvas = document.createElement('canvas');
                waveCanvas.id = 'wave-canvas';
                waveCanvas.style.position = 'fixed';
                waveCanvas.style.top = '0';
                waveCanvas.style.left = '0';
                waveCanvas.style.width = '100%';
                waveCanvas.style.height = '100%';
                waveCanvas.style.pointerEvents = 'none';
                waveCanvas.style.zIndex = '0';
                document.body.insertBefore(waveCanvas, document.body.firstChild);
            }

            // Hide SVG paths
            state.paths.forEach(path => path.setAttribute('d', ''));

            const ctx = waveCanvas.getContext('2d');
            const w = waveCanvas.width = state.boundingRect.width;
            const h = waveCanvas.height = state.boundingRect.height;

            // Clear canvas
            ctx.clearRect(0, 0, w, h);

            // Apply background shift
            const shiftX = state.backgroundShift ? state.backgroundShift.x * backgroundShift : 0;
            const shiftY = state.backgroundShift ? state.backgroundShift.y * backgroundShift : 0;
            ctx.save();
            ctx.translate(shiftX, shiftY);

            // Audio smoothing and speed boost
            const smoothingFactor = state.settings.starSmoothing; // 0-1, higher = smoother/slower
            state.stars.centerX += (state.stars.targetCenterX - state.stars.centerX) * (1 - smoothingFactor) * 0.1;
            state.stars.centerY += (state.stars.targetCenterY - state.stars.centerY) * (1 - smoothingFactor) * 0.1;

            // Draw based on mode
            ctx.globalCompositeOperation = 'lighter';

            const mode = visualMode;

            if (mode === 'planes') {
                // PLANES MODE: Original gradient stars - simplified for WAVE theme
                const speedBoost = 1.0 + high * amplitude;

                state.stars.starArray.forEach((star) => {
                    // Apply perspective control to depth scaling
                    const baseScale = 0.2;
                    const depthRange = 0.8 * perspective * depth; // perspective and depth multipliers
                    const scale = baseScale + star.z * depthRange;
                    const scaledOrbitRadius = star.orbitRadius * scale * wavelength;

                    // High frequencies shift center position with rotationY control
                    const centerOffsetX = Math.sin(time * 0.001 + rotationX * 0.1) * high * 100;
                    const centerOffsetY = Math.cos(time * 0.001 + rotationY * 0.1) * high * 100;

                    // Calculate base position with phaseShift
                    const phaseAngle = star.timePassed + phaseShift;
                    let x = Math.sin(phaseAngle) * scaledOrbitRadius + state.stars.centerX + centerOffsetX;
                    let y = Math.cos(phaseAngle) * scaledOrbitRadius + state.stars.centerY + centerOffsetY;

                    // Apply turbulence (noise-based displacement)
                    if (turbulence > 0) {
                        const turbulenceX = (state.noise(x * 0.01, y * 0.01 + time * 0.001) - 0.5) * turbulence * 100;
                        const turbulenceY = (state.noise(x * 0.01 + 100, y * 0.01 + time * 0.001) - 0.5) * turbulence * 100;
                        x += turbulenceX;
                        y += turbulenceY;
                    }

                    // Get pre-rendered gradient from cache (with glow effect)
                    const size = 25 * star.size * amplitude * (1 + glow);
                    ctx.drawImage(
                        state.stars.gradientCanvas,
                        0, 0, 50, 50,
                        x - size,
                        y - size,
                        size * 2,
                        size * 2
                    );

                    // Update orbit
                    star.timePassed += star.baseSpeed * speed * speedBoost;
                });

            } else if (mode === 'grids') {
                // GRIDS MODE: Draw layered grid patterns
                const sat = saturation;

                for (let layer = 0; layer < layers; layer++) {
                    const layerDepth = layer / layers;
                    // Apply depth control to layer scaling
                    const layerScale = 0.3 + layerDepth * 0.7 * depth;
                    const cellSize = 40 + layer * 20;

                    // Audio-reactive rotation per layer with phaseShift
                    const rotation = time * 0.0001 * speed + layer * 0.3 + phaseShift * 0.1;

                    ctx.save();
                    ctx.translate(state.stars.centerX, state.stars.centerY);
                    ctx.rotate(rotation + high * 0.5 + rotationY * 0.01);
                    // Apply perspective scaling
                    ctx.scale(layerScale * amplitude * perspective, layerScale * amplitude * perspective);

                    // Draw grid with radial gradient shading
                    const gridSize = Math.max(w, h) / cellSize;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gridSize * cellSize / 2);
                    gradient.addColorStop(0, `hsla(${hue}, ${sat}%, 60%, ${0.3 + mid * 0.2})`);
                    gradient.addColorStop(0.5, `hsla(${hue}, ${sat}%, 40%, ${0.2 + mid * 0.1})`);
                    gradient.addColorStop(1, `hsla(${hue}, ${sat}%, 20%, ${0.05})`);
                    ctx.strokeStyle = gradient;

                    for (let i = -gridSize; i < gridSize; i++) {
                        for (let j = -gridSize; j < gridSize; j++) {
                            const x = i * cellSize;
                            const y = j * cellSize;

                            // Audio-reactive distortion with turbulence
                            let distortion = Math.sin(i * 0.5 + time * 0.001) * Math.cos(j * 0.5 + time * 0.001) * low * 10;

                            // Add turbulence displacement
                            if (turbulence > 0) {
                                const turbX = (state.noise(i * 0.1, j * 0.1 + time * 0.001) - 0.5) * turbulence * 50;
                                const turbY = (state.noise(i * 0.1 + 100, j * 0.1 + time * 0.001) - 0.5) * turbulence * 50;
                                ctx.strokeRect(x + distortion + turbX, y + distortion + turbY, cellSize, cellSize);
                            } else {
                                ctx.strokeRect(x + distortion, y + distortion, cellSize, cellSize);
                            }
                        }
                    }

                    ctx.restore();
                }

            } else if (mode === 'dots') {
                // DOTS MODE: Simple layered dots
                const sat = saturation;
                const speedBoost = 1.0 + high * amplitude;

                state.stars.starArray.forEach((star) => {
                    // Assign layer based on star index
                    const layer = Math.floor(star.z * layers);
                    const layerDepth = layer / layers;

                    // Update Z position
                    if (state.settings.starZSpeed > 0) {
                        star.z += state.settings.starZSpeed * 0.001;
                        if (star.z >= 1.0) {
                            star.z = 0;
                            star.timePassed = Math.random() * state.settings.starCount;
                        }
                    }

                    // Apply depth and perspective to layer scaling
                    const scale = 0.3 + layerDepth * 0.7 * depth * perspective;
                    const scaledOrbitRadius = star.orbitRadius * scale;

                    // Calculate position with phaseShift
                    const phaseAngle = star.timePassed + phaseShift;
                    let x = Math.sin(phaseAngle) * scaledOrbitRadius + state.stars.centerX;
                    let y = Math.cos(phaseAngle) * scaledOrbitRadius + state.stars.centerY;

                    // Apply turbulence displacement
                    if (turbulence > 0) {
                        const turbX = (state.noise(x * 0.01, y * 0.01 + time * 0.001) - 0.5) * turbulence * 100;
                        const turbY = (state.noise(x * 0.01 + 100, y * 0.01 + time * 0.001) - 0.5) * turbulence * 100;
                        x += turbX;
                        y += turbY;
                    }

                    // Draw dot with shading
                    const dotSize = (2 + layerDepth * 4) * amplitude;
                    const brightness = 30 + layerDepth * 50 + mid * 30;

                    // Radial gradient for shading (with glow effect)
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, dotSize * 2 * (1 + glow));
                    gradient.addColorStop(0, `hsla(${hue}, ${sat}%, ${brightness}%, ${star.alpha + mid * 0.3})`);
                    gradient.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${brightness * 0.7}%, ${star.alpha * 0.5})`);
                    gradient.addColorStop(1, `hsla(${hue}, ${sat}%, ${brightness * 0.3}%, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, dotSize * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Update orbit
                    star.timePassed += star.baseSpeed * speed * speedBoost;
                });
            }

            ctx.globalAlpha = 1.0;

            // Restore canvas state
            ctx.restore();
        }

        // Theme renderer dispatcher
        const themeRenderers = {
            linear: drawLinesLinear,
            neon: drawLinesNeon,
            glitch: drawLinesGlitch,
            stars: drawLinesStars,
            wave: drawLinesWave
        };

        function drawLines() {
            // Render background theme
            const renderer = themeRenderers[state.settings.theme] || drawLinesLinear;
            renderer();

            // Render image objects (for all themes)
            renderImageObjects();
        }

        function renderImageObjects() {
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            state.imageObjects.forEach((imageObj, index) => {
                const canvas = imageObj.canvas;
                const ctx = canvas.getContext('2d');

                // Check visibility - hide if explicitly set to false
                if (imageObj.visible === false) {
                    canvas.style.display = 'none';
                    return; // Skip rendering this image
                }

                // Update canvas size and position
                canvas.width = imageObj.width;
                canvas.height = imageObj.height;
                canvas.style.left = `${imageObj.x}px`;
                canvas.style.top = `${imageObj.y}px`;
                canvas.style.display = 'block';

                // Flash effect logic
                let shouldHideFlash = false;

                if (imageObj.flashFrequencyEnabled) {
                    // Calculate average frequency level (0-1 range)
                    const avgFrequency = (low + mid + high) / 3;
                    if (avgFrequency > imageObj.flashFrequencyThreshold) {
                        shouldHideFlash = true;
                    }
                }

                if (imageObj.flashVolumeEnabled && !shouldHideFlash) {
                    // Use high frequency as volume proxy (0-1 range)
                    const volume = Math.max(low, mid, high);
                    if (volume > imageObj.flashVolumeThreshold) {
                        shouldHideFlash = true;
                    }
                }

                // Apply flash visibility
                if (shouldHideFlash) {
                    canvas.style.display = 'none';
                }

                // Apply transparency
                canvas.style.opacity = imageObj.transparency;

                // Apply rotation and 3D motion
                const motion3D = state.settings.image3DMotion;
                if (imageObj.theme !== 'glitch') {
                    // Non-glitch themes: Apply rotation and optional 3D motion
                    if (motion3D > 0) {
                        // Apply 3D motion based on audio
                        const rotationX = mid * 45 * motion3D; // Mids control pitch (X-axis rotation)
                        const rotationY = high * 45 * motion3D; // Highs control yaw (Y-axis rotation)
                        const rotationZ = low * 15 * motion3D + imageObj.rotation; // Bass controls roll + user rotation
                        const perspective = 1000;
                        canvas.style.transformStyle = 'preserve-3d';
                        canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;
                        canvas.style.transformOrigin = 'center center';
                    } else {
                        // No 3D motion, just apply simple rotation
                        canvas.style.transform = `rotate(${imageObj.rotation}deg)`;
                        canvas.style.transformOrigin = 'center center';
                    }
                }

                // Apply blur filter
                if (imageObj.blur > 0) {
                    canvas.style.filter = `blur(${imageObj.blur}px)`;
                } else {
                    canvas.style.filter = 'none';
                }

                // Add selection outline if selected
                if (index === state.selectedImageIndex) {
                    canvas.style.border = '2px solid #ffffff';
                    canvas.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.5)';
                } else {
                    canvas.style.border = 'none';
                    canvas.style.boxShadow = 'none';
                }

                // Handle video trimming and looping
                if (imageObj.isVideo && imageObj.video) {
                    const video = imageObj.video;
                    video.loop = imageObj.loop || false;

                    // Apply trimming
                    if (video.currentTime < imageObj.trimStart || video.currentTime > imageObj.trimEnd) {
                        video.currentTime = imageObj.trimStart;
                    }

                    // If we reach the trim end, loop back to trim start
                    if (imageObj.loop && video.currentTime >= imageObj.trimEnd) {
                        video.currentTime = imageObj.trimStart;
                    }
                }

                // Get the source (video or image)
                const source = imageObj.isVideo ? imageObj.video : imageObj.img;

                // Render based on image's assigned theme
                if (imageObj.theme === 'none') {
                    // No effect - just draw the plain image/video
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
                } else if (imageObj.theme === 'neon') {
                    renderNeonImage(canvas, config.themes.neon, low, mid, high, time, imageObj.width, imageObj.height, source, imageObj.themeBlur, imageObj.themeOpacity);
                } else if (imageObj.theme === 'glitch') {
                    renderGlitchImage(canvas, config.themes.glitch, low, mid, high, time, source, imageObj.themeBlur, imageObj.themeOpacity, imageObj.rotation);
                } else if (imageObj.theme === 'linear') {
                    // For LINEAR theme on image/video, just draw with some audio-reactive effects
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Apply audio-reactive opacity combined with theme opacity
                    ctx.globalAlpha = (0.8 + (mid * 0.2)) * imageObj.themeOpacity;
                    ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        // =====================================================
        // CONTROL VISIBILITY
        // =====================================================

        function showControls() {
            if (!state.controlsVisible) {
                state.controlsVisible = true;
                elements.statusBar.classList.remove('hidden-control');
                elements.sidebarToggle.classList.remove('hidden-control');

                const fullscreenToggle = document.getElementById('fullscreenToggle');
                if (fullscreenToggle) {
                    fullscreenToggle.classList.remove('hidden-control');
                }

                const addImageBtn = document.getElementById('addImageButton');
                if (addImageBtn) {
                    addImageBtn.classList.remove('hidden-control');
                }

                const pairingCodeDisplay = document.getElementById('pairingCodeDisplay');
                if (pairingCodeDisplay) {
                    pairingCodeDisplay.classList.remove('hidden-control');
                }
            }

            // Reset idle timeout
            clearTimeout(state.idleTimeout);
            state.idleTimeout = setTimeout(hideControls, 2000); // Hide after 2 seconds of no movement
        }

        function hideControls() {
            // Don't hide if sidebar is open
            const sidebarOpen = elements.sidebar.classList.contains('open');
            if (sidebarOpen) {
                // Restart the timeout to check again later
                state.idleTimeout = setTimeout(hideControls, 2000);
                return;
            }

            state.controlsVisible = false;
            elements.statusBar.classList.add('hidden-control');
            elements.sidebarToggle.classList.add('hidden-control');

            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle) {
                fullscreenToggle.classList.add('hidden-control');
            }

            const addImageBtn = document.getElementById('addImageButton');
            if (addImageBtn) {
                addImageBtn.classList.add('hidden-control');
            }

            const pairingCodeDisplay = document.getElementById('pairingCodeDisplay');
            if (pairingCodeDisplay) {
                pairingCodeDisplay.classList.add('hidden-control');
            }
        }

        // =====================================================
        // SAVE/LOAD STATE
        // =====================================================

        function setupImageInteraction(canvas, imageIndex) {
            canvas.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();

                // Select this image
                state.selectedImageIndex = imageIndex;
                updateModeVisibility(); // Update UI to show image theme selector

                const imageObj = state.imageObjects[imageIndex];
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if clicking near edges for resize (within 20px)
                const edgeThreshold = 20;
                const nearRightEdge = mouseX > canvas.width - edgeThreshold;
                const nearBottomEdge = mouseY > canvas.height - edgeThreshold;

                if (nearRightEdge || nearBottomEdge) {
                    // Start resize
                    imageObj.isResizing = true;
                    imageObj.dragStartX = e.clientX;
                    imageObj.dragStartY = e.clientY;
                    imageObj.dragStartWidth = imageObj.width;
                    imageObj.dragStartHeight = imageObj.height;
                    canvas.style.cursor = 'nwse-resize';
                } else {
                    // Start drag
                    imageObj.isDragging = true;
                    imageObj.dragStartX = e.clientX - imageObj.x;
                    imageObj.dragStartY = e.clientY - imageObj.y;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const imageObj = state.imageObjects[imageIndex];
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Update cursor based on position
                if (!imageObj.isDragging && !imageObj.isResizing) {
                    const edgeThreshold = 20;
                    const nearRightEdge = mouseX > canvas.width - edgeThreshold;
                    const nearBottomEdge = mouseY > canvas.height - edgeThreshold;

                    if (nearRightEdge || nearBottomEdge) {
                        canvas.style.cursor = 'nwse-resize';
                    } else {
                        canvas.style.cursor = 'move';
                    }
                }
            });
        }

        async function saveCanvasState() {
            try {
                // Collect all state data
                const canvasState = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    background: {
                        theme: state.settings.theme,
                        mode: state.settings.mode,
                        glitchMode: state.settings.glitchMode,
                        rotationIntensity: state.settings.rotationIntensity,
                        glitchEffectIntensity: state.settings.glitchEffectIntensity,
                        neonColorMode: state.settings.neonColorMode,
                        neonWarmCool: state.settings.neonWarmCool,
                        neonSatRange: state.settings.neonSatRange,
                        neonBurstSize: state.settings.neonBurstSize
                    },
                    audioSettings: {
                        lowEmphasis: state.settings.lowEmphasis,
                        midEmphasis: state.settings.midEmphasis,
                        highEmphasis: state.settings.highEmphasis
                    },
                    waveSettings: {
                        intensity: state.settings.waveIntensity,
                        speed: state.settings.waveSpeed,
                        smoothing: state.settings.waveSmoothing
                    },
                    density: state.settings.density,
                    imageObjects: []
                };

                // Convert each image object to serializable format
                for (const imageObj of state.imageObjects) {
                    // Convert image to base64
                    const canvas = document.createElement('canvas');
                    canvas.width = imageObj.img.width;
                    canvas.height = imageObj.img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(imageObj.img, 0, 0);
                    const imageData = canvas.toDataURL('image/png');

                    canvasState.imageObjects.push({
                        x: imageObj.x,
                        y: imageObj.y,
                        width: imageObj.width,
                        height: imageObj.height,
                        originalWidth: imageObj.originalWidth || imageObj.width,
                        originalHeight: imageObj.originalHeight || imageObj.height,
                        scale: imageObj.scale || 1.0,
                        theme: imageObj.theme,
                        transparency: imageObj.transparency,
                        rotation: imageObj.rotation,
                        blur: imageObj.blur,
                        themeBlur: imageObj.themeBlur,
                        themeOpacity: imageObj.themeOpacity,
                        flashFrequencyEnabled: imageObj.flashFrequencyEnabled,
                        flashFrequencyThreshold: imageObj.flashFrequencyThreshold,
                        flashVolumeEnabled: imageObj.flashVolumeEnabled,
                        flashVolumeThreshold: imageObj.flashVolumeThreshold,
                        imageData: imageData
                    });
                }

                // Convert to JSON and download
                const jsonString = JSON.stringify(canvasState, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `soundscape-${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('✅ Canvas state saved successfully');
            } catch (error) {
                console.error('❌ Error saving canvas state:', error);
                alert('Error saving canvas state. Check console for details.');
            }
        }

        function loadCanvasStateFromFile(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const canvasState = JSON.parse(event.target.result);
                    restoreCanvasState(canvasState);
                } catch (error) {
                    console.error('❌ Error loading canvas state:', error);
                    alert('Error loading canvas state. Check console for details.');
                }
            };
            reader.readAsText(file);
        }

        async function restoreCanvasState(canvasState) {
            try {
                console.log('🔄 Restoring canvas state...');

                // Clear existing image objects
                state.imageObjects.forEach(obj => {
                    if (obj.canvas && obj.canvas.parentNode) {
                        obj.canvas.parentNode.removeChild(obj.canvas);
                    }
                });
                state.imageObjects = [];
                state.selectedImageIndex = -1;

                // Restore background theme
                state.settings.theme = canvasState.background.theme;
                state.settings.mode = canvasState.background.mode;
                state.settings.glitchMode = canvasState.background.glitchMode || 'rgb';
                state.settings.rotationIntensity = canvasState.background.rotationIntensity || 1.0;
                state.settings.glitchEffectIntensity = canvasState.background.glitchEffectIntensity || 1.0;
                state.settings.neonColorMode = canvasState.background.neonColorMode || 'rainbow';
                state.settings.neonWarmCool = canvasState.background.neonWarmCool || 0.5;
                state.settings.neonSatRange = canvasState.background.neonSatRange || 0.5;

                // Restore audio settings
                state.settings.lowEmphasis = canvasState.audioSettings.lowEmphasis;
                state.settings.midEmphasis = canvasState.audioSettings.midEmphasis;
                state.settings.highEmphasis = canvasState.audioSettings.highEmphasis;

                // Restore wave settings
                state.settings.waveIntensity = canvasState.waveSettings.intensity;
                state.settings.waveSpeed = canvasState.waveSettings.speed;
                state.settings.waveSmoothing = canvasState.waveSettings.smoothing;

                // Restore density
                state.settings.density = canvasState.density;

                // Derive burst size from density
                const densityToBurstSize = {
                    'low': 0.5,
                    'medium': 1.0,
                    'high': 1.5
                };
                state.settings.neonBurstSize = densityToBurstSize[state.settings.density] || 1.0;

                // Restore image objects
                for (const imageObjData of canvasState.imageObjects) {
                    await restoreImageObject(imageObjData);
                }

                // Update UI to reflect loaded state
                updateModeVisibility();
                syncControlsWithState();

                console.log('✅ Canvas state restored successfully');
            } catch (error) {
                console.error('❌ Error restoring canvas state:', error);
                alert('Error restoring canvas state. Check console for details.');
            }
        }

        function restoreImageObject(imageObjData) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                canvas.style.position = 'absolute';
                canvas.style.cursor = 'move';
                canvas.style.pointerEvents = 'auto';
                canvas.className = 'image-object-canvas';
                document.getElementById('visualization-container').appendChild(canvas);

                if (imageObjData.imageData) {
                    // Image data exists - load it
                    const img = new Image();
                    img.onload = () => {
                        const imageObject = {
                            img: img,
                            x: imageObjData.x,
                            y: imageObjData.y,
                            width: imageObjData.width,
                            height: imageObjData.height,
                            originalWidth: imageObjData.originalWidth || imageObjData.width,
                            originalHeight: imageObjData.originalHeight || imageObjData.height,
                            scale: imageObjData.scale || 1.0,
                            theme: imageObjData.theme,
                            transparency: imageObjData.transparency,
                            rotation: imageObjData.rotation,
                            blur: imageObjData.blur,
                            themeBlur: imageObjData.themeBlur,
                            themeOpacity: imageObjData.themeOpacity,
                            flashFrequencyEnabled: imageObjData.flashFrequencyEnabled || false,
                            flashFrequencyThreshold: imageObjData.flashFrequencyThreshold || 0.5,
                            flashVolumeEnabled: imageObjData.flashVolumeEnabled || false,
                            flashVolumeThreshold: imageObjData.flashVolumeThreshold || 0.5,
                            canvas: canvas,
                            isDragging: false,
                            isResizing: false,
                            dragStartX: 0,
                            dragStartY: 0,
                            dragStartWidth: 0,
                            dragStartHeight: 0
                        };

                        state.imageObjects.push(imageObject);
                        const imageIndex = state.imageObjects.length - 1;
                        setupImageInteraction(canvas, imageIndex);

                        console.log(`✅ Image object restored: ${imageObjData.width.toFixed(0)}x${imageObjData.height.toFixed(0)}, theme: ${imageObject.theme}`);
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('❌ Failed to load image data, creating placeholder');
                        createImagePlaceholder(canvas, imageObjData);
                        resolve();
                    };
                    img.src = imageObjData.imageData;
                } else {
                    // No image data - create placeholder
                    createImagePlaceholder(canvas, imageObjData);
                    resolve();
                }
            });
        }

        function createImagePlaceholder(canvas, imageObjData) {
            // Create a placeholder image object
            const placeholderCanvas = document.createElement('canvas');
            placeholderCanvas.width = 200;
            placeholderCanvas.height = 200;
            const ctx = placeholderCanvas.getContext('2d');

            // Draw placeholder (gray box with dashed border)
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 200, 200);
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.strokeRect(0, 0, 200, 200);
            ctx.setLineDash([]);

            // Add text
            ctx.fillStyle = '#999999';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('DROP IMAGE', 100, 90);
            ctx.fillText('HERE', 100, 110);

            const placeholderImg = new Image();
            placeholderImg.onload = () => {
                const imageObject = {
                    img: placeholderImg,
                    x: imageObjData.x,
                    y: imageObjData.y,
                    width: imageObjData.width,
                    height: imageObjData.height,
                    originalWidth: imageObjData.originalWidth || imageObjData.width,
                    originalHeight: imageObjData.originalHeight || imageObjData.height,
                    scale: imageObjData.scale || 1.0,
                    theme: imageObjData.theme,
                    transparency: imageObjData.transparency,
                    rotation: imageObjData.rotation,
                    blur: imageObjData.blur,
                    themeBlur: imageObjData.themeBlur,
                    themeOpacity: imageObjData.themeOpacity,
                    flashFrequencyEnabled: imageObjData.flashFrequencyEnabled || false,
                    flashFrequencyThreshold: imageObjData.flashFrequencyThreshold || 0.5,
                    flashVolumeEnabled: imageObjData.flashVolumeEnabled || false,
                    flashVolumeThreshold: imageObjData.flashVolumeThreshold || 0.5,
                    canvas: canvas,
                    isDragging: false,
                    isResizing: false,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragStartWidth: 0,
                    dragStartHeight: 0,
                    isPlaceholder: true
                };

                state.imageObjects.push(imageObject);
                const imageIndex = state.imageObjects.length - 1;
                setupImageInteraction(canvas, imageIndex);
                setupPlaceholderDropZone(canvas, imageIndex);

                console.log(`⚠️ Placeholder created at ${imageObjData.x.toFixed(0)}, ${imageObjData.y.toFixed(0)}`);
            };
            placeholderImg.src = placeholderCanvas.toDataURL();
        }

        function setupPlaceholderDropZone(canvas, imageIndex) {
            // Add drag & drop functionality to placeholder
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '0.5';
            });

            canvas.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '1.0';
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '1.0';

                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    replacePlaceholderWithImage(imageIndex, files[0]);
                }
            });
        }

        function replacePlaceholderWithImage(imageIndex, file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const imageObj = state.imageObjects[imageIndex];
                    imageObj.img = img;
                    imageObj.isPlaceholder = false;
                    console.log(`✅ Placeholder replaced with image at index ${imageIndex}`);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function syncControlsWithState() {
            // Sync theme dropdown
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) themeSelect.value = state.settings.theme;

            // Sync mode buttons
            const modeButtons = document.querySelectorAll('[data-mode]');
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === state.settings.mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync density buttons
            const densityButtons = document.querySelectorAll('[data-density]');
            densityButtons.forEach(btn => {
                if (btn.dataset.density === state.settings.density) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync sliders
            const sliderMappings = [
                { id: 'lowEmphasis', value: state.settings.lowEmphasis, display: 'lowValue' },
                { id: 'midEmphasis', value: state.settings.midEmphasis, display: 'midValue' },
                { id: 'highEmphasis', value: state.settings.highEmphasis, display: 'highValue' },
                { id: 'intensitySlider', value: state.settings.waveIntensity, display: 'intensityValue' },
                { id: 'speedSlider', value: state.settings.waveSpeed, display: 'speedValue' },
                { id: 'smoothingSlider', value: state.settings.waveSmoothing, display: 'smoothingValue' },
                { id: 'rotationSlider', value: state.settings.rotationIntensity, display: 'rotationValue' },
                { id: 'glitchSlider', value: state.settings.glitchEffectIntensity, display: 'glitchValue' },
                { id: 'neonWarmCoolSlider', value: state.settings.neonWarmCool, display: 'neonWarmCoolValue' },
                { id: 'neonSatRangeSlider', value: state.settings.neonSatRange, display: 'neonSatRangeValue' }
            ];

            sliderMappings.forEach(mapping => {
                const slider = document.getElementById(mapping.id);
                const display = document.getElementById(mapping.display);
                if (slider) slider.value = mapping.value;
                if (display) display.textContent = mapping.value.toFixed(1);
            });

            // Sync glitch mode
            const glitchModeButtons = document.querySelectorAll('[data-glitch-mode]');
            glitchModeButtons.forEach(btn => {
                if (btn.dataset.glitchMode === state.settings.glitchMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync neon color mode
            const neonColorModeButtons = document.querySelectorAll('[data-neon-mode]');
            neonColorModeButtons.forEach(btn => {
                if (btn.dataset.neonMode === state.settings.neonColorMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // =====================================================
        // CONTROLS SETUP
        // =====================================================

        function setupControls() {
            // Sidebar toggle
            elements.sidebarToggle.addEventListener('click', () => {
                elements.sidebar.classList.toggle('open');

                // Also toggle class on buttons for animation
                const sidebarOpen = elements.sidebar.classList.contains('open');
                const sidebarToggle = document.getElementById('sidebarToggle');
                const addImageButton = document.getElementById('addImageButton');
                const addImageDropdown = document.getElementById('addImageDropdown');

                if (sidebarOpen) {
                    if (sidebarToggle) sidebarToggle.classList.add('sidebar-is-open');
                    if (addImageButton) addImageButton.classList.add('sidebar-is-open');
                    if (addImageDropdown) addImageDropdown.classList.add('sidebar-is-open');
                } else {
                    if (sidebarToggle) sidebarToggle.classList.remove('sidebar-is-open');
                    if (addImageButton) addImageButton.classList.remove('sidebar-is-open');
                    if (addImageDropdown) addImageDropdown.classList.remove('sidebar-is-open');
                }
            });

            // Fullscreen toggle
            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle) {
                fullscreenToggle.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        // Enter fullscreen
                        document.documentElement.requestFullscreen().catch(err => {
                            console.error(`Error attempting to enable fullscreen: ${err.message}`);
                        });
                    } else {
                        // Exit fullscreen
                        document.exitFullscreen();
                    }
                });

                // Update button icon when fullscreen state changes
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        fullscreenToggle.textContent = '⛶'; // Exit fullscreen icon
                    } else {
                        fullscreenToggle.textContent = '⛶'; // Enter fullscreen icon
                    }
                });
            }

            // Pairing code display click - show pairing panel
            const pairingCodeDisplay = document.getElementById('pairingCodeDisplay');
            const pairingPanel = document.getElementById('pairingPanel');
            const pairingClose = document.getElementById('pairingClose');

            if (pairingCodeDisplay && pairingPanel) {
                pairingCodeDisplay.addEventListener('click', () => {
                    pairingPanel.style.display = 'flex';
                });
            }

            if (pairingClose && pairingPanel) {
                pairingClose.addEventListener('click', () => {
                    pairingPanel.style.display = 'none';
                });
            }

            // 'h' key to toggle UI visibility (all nav icons)
            document.addEventListener('keydown', (e) => {
                // 'h' key - toggle UI visibility
                if (e.key === 'h' || e.key === 'H') {
                    const statusBar = document.getElementById('statusBar');
                    const fullscreenBtn = document.getElementById('fullscreenToggle');
                    const pairingCodeDisplay = document.getElementById('pairingCodeDisplay');
                    const addImageBtn = document.getElementById('addImageButton');
                    const sidebarToggle = document.getElementById('sidebarToggle');

                    // Check if UI is currently hidden
                    const isHidden = statusBar && statusBar.classList.contains('hidden-control');

                    if (isHidden) {
                        // Show UI and cursor
                        if (statusBar) statusBar.classList.remove('hidden-control');
                        if (fullscreenBtn) fullscreenBtn.classList.remove('hidden-control');
                        if (pairingCodeDisplay) pairingCodeDisplay.classList.remove('hidden-control');
                        if (addImageBtn) addImageBtn.classList.remove('hidden-control');
                        if (sidebarToggle) sidebarToggle.classList.remove('hidden-control');
                        document.body.classList.remove('hide-cursor');
                    } else {
                        // Hide UI and cursor
                        if (statusBar) statusBar.classList.add('hidden-control');
                        if (fullscreenBtn) fullscreenBtn.classList.add('hidden-control');
                        if (pairingCodeDisplay) pairingCodeDisplay.classList.add('hidden-control');
                        if (addImageBtn) addImageBtn.classList.add('hidden-control');
                        if (sidebarToggle) sidebarToggle.classList.add('hidden-control');
                        document.body.classList.add('hide-cursor');
                    }
                }

                // 'Escape' key - deselect image
                if (e.key === 'Escape' && state.selectedImageIndex !== -1) {
                    state.selectedImageIndex = -1;
                    updateModeVisibility();
                    console.log('🔲 Image deselected');
                }

                // 'Delete' or 'Backspace' key - remove selected image
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedImageIndex !== -1) {
                    // Prevent default browser back navigation on Backspace
                    e.preventDefault();

                    const imageIndex = state.selectedImageIndex;
                    const imageObj = state.imageObjects[imageIndex];

                    // Remove canvas from DOM
                    if (imageObj.canvas && imageObj.canvas.parentNode) {
                        imageObj.canvas.parentNode.removeChild(imageObj.canvas);
                    }

                    // Remove from array
                    state.imageObjects.splice(imageIndex, 1);

                    // Deselect
                    state.selectedImageIndex = -1;
                    updateModeVisibility();

                    console.log(`🗑️ Image removed at index ${imageIndex}`);

                    // Send updated state to companion
                    sendStateToMobile();
                }
            });

            // Theme selector
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    state.settings.theme = e.target.value;
                    console.log(`🎨 Theme changed to: ${state.settings.theme.toUpperCase()}`);

                    // Clean up NEON theme elements
                    const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
                    if (gradientMeshGroup) {
                        gradientMeshGroup.innerHTML = '';
                    }

                    // Clean up GLITCH theme paths
                    const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
                    allGlitchPaths.forEach(path => path.remove());

                    // Clean up STARS theme
                    if (state.stars.initialized) {
                        state.stars.initialized = false;
                        state.stars.starArray = [];
                        state.stars.count = 0;
                    }

                    // Clean up WAVE theme
                    if (state.wave.initialized) {
                        state.wave.initialized = false;
                        state.wave.gridNodes = [];
                        state.wave.orbitalDots = [];
                    }

                    // Reset LINEAR theme path attributes
                    state.paths.forEach((path) => {
                        path.removeAttribute('filter');
                        path.removeAttribute('transform');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('stroke', '#ffffff');
                        // Clear path data to remove any lingering visuals
                        path.setAttribute('d', '');
                    });

                    // Clear theme canvas (used by GLITCH theme)
                    const themeCanvas = document.getElementById('theme-canvas');
                    if (themeCanvas) {
                        const ctx = themeCanvas.getContext('2d');
                        ctx.clearRect(0, 0, themeCanvas.width, themeCanvas.height);
                    }

                    // Clear STARS canvas
                    const starsCanvas = document.getElementById('stars-canvas');
                    if (starsCanvas) {
                        const starsCtx = starsCanvas.getContext('2d');
                        starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
                    }

                    // Clear WAVE canvas
                    const waveCanvas = document.getElementById('wave-canvas');
                    if (waveCanvas) {
                        const waveCtx = waveCanvas.getContext('2d');
                        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
                    }

                    // Update colors for new theme
                    updateColors();

                    console.log(`✅ Theme switched to ${state.settings.theme.toUpperCase()}`);
                });
            }

            // Image theme selector
            const imageThemeSelect = document.getElementById('imageThemeSelect');
            if (imageThemeSelect) {
                imageThemeSelect.addEventListener('change', (e) => {
                    if (state.selectedImageIndex === -1) return;

                    const imageObj = state.imageObjects[state.selectedImageIndex];
                    if (imageObj) {
                        imageObj.theme = e.target.value;
                        console.log(`🎨 Image theme changed to: ${imageObj.theme.toUpperCase()}`);

                        // Hide/show effect settings based on theme
                        const effectSettings = document.getElementById('imageEffectSettings');
                        if (effectSettings) {
                            if (e.target.value === 'none') {
                                effectSettings.style.display = 'none';
                            } else {
                                effectSettings.style.display = 'block';
                            }
                        }
                    }
                });
            }

            // Image transparency slider
            setupSlider('imageTransparencySlider', 'imageTransparencyValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.transparency = value;
                }
            });

            // Image rotation slider
            setupSlider('imageRotationSlider', 'imageRotationValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.rotation = value;
                }
            });

            // Image blur slider
            setupSlider('imageBlurSlider', 'imageBlurValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.blur = value;
                }
            });

            // 3D Motion slider (global setting for all images)
            setupSlider('image3DMotionSlider', 'image3DMotionValue', (value) => {
                state.settings.image3DMotion = value;
            });

            // Flash effect controls
            const flashFrequencyCheck = document.getElementById('flashFrequencyCheck');
            const flashFrequencySliderGroup = document.getElementById('flashFrequencySliderGroup');
            const flashVolumeCheck = document.getElementById('flashVolumeCheck');
            const flashVolumeSliderGroup = document.getElementById('flashVolumeSliderGroup');

            flashFrequencyCheck.addEventListener('change', (e) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashFrequencyEnabled = e.target.checked;
                    flashFrequencySliderGroup.style.display = e.target.checked ? 'block' : 'none';
                }
            });

            flashVolumeCheck.addEventListener('change', (e) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashVolumeEnabled = e.target.checked;
                    flashVolumeSliderGroup.style.display = e.target.checked ? 'block' : 'none';
                }
            });

            setupSlider('flashFrequencySlider', 'flashFrequencyValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashFrequencyThreshold = value;
                }
            });

            setupSlider('flashVolumeSlider', 'flashVolumeValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashVolumeThreshold = value;
                }
            });

            // Video controls
            const videoLoopCheck = document.getElementById('videoLoopCheck');
            if (videoLoopCheck) {
                videoLoopCheck.addEventListener('change', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo) {
                        videoObj.loop = e.target.checked;
                    }
                });
            }

            // Video trim sliders with scrubbing
            const videoTrimStartSlider = document.getElementById('videoTrimStartSlider');
            const videoTrimStartValue = document.getElementById('videoTrimStartValue');
            if (videoTrimStartSlider && videoTrimStartValue) {
                videoTrimStartSlider.addEventListener('input', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo && videoObj.video) {
                        const value = parseFloat(e.target.value);
                        videoObj.trimStart = value;
                        videoTrimStartValue.textContent = `${value.toFixed(1)}s`;
                        // Scrub to this position
                        videoObj.video.currentTime = value;
                    }
                });
            }

            const videoTrimEndSlider = document.getElementById('videoTrimEndSlider');
            const videoTrimEndValue = document.getElementById('videoTrimEndValue');
            if (videoTrimEndSlider && videoTrimEndValue) {
                videoTrimEndSlider.addEventListener('input', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo && videoObj.video) {
                        const value = parseFloat(e.target.value);
                        videoObj.trimEnd = value;
                        videoTrimEndValue.textContent = `${value.toFixed(1)}s`;
                        // Scrub to this position
                        videoObj.video.currentTime = value;
                    }
                });
            }

            // Image scale slider
            setupSlider('imageScaleSlider', 'imageScaleValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.scale = value;
                    imageObj.width = imageObj.originalWidth * value;
                    imageObj.height = imageObj.originalHeight * value;
                }
            }, 'x');

            // Video playback speed slider
            setupSlider('videoSpeedSlider', 'videoSpeedValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const videoObj = state.imageObjects[state.selectedImageIndex];
                if (videoObj && videoObj.isVideo && videoObj.video) {
                    videoObj.video.playbackRate = value;
                }
            }, 'x');

            // Theme opacity slider
            setupSlider('themeOpacitySlider', 'themeOpacityValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.themeOpacity = value;
                }
            });

            // GLITCH background image controls
            const glitchFitModeSelect = document.getElementById('glitchFitModeSelect');
            const glitchScaleGroup = document.getElementById('glitchScaleGroup');
            const glitchXGroup = document.getElementById('glitchXGroup');
            const glitchYGroup = document.getElementById('glitchYGroup');
            const glitchResetBtn = document.getElementById('glitchResetBtn');

            if (glitchFitModeSelect) {
                glitchFitModeSelect.addEventListener('change', (e) => {
                    state.glitchImage.fitMode = e.target.value;

                    // Show/hide scale and position controls based on fit mode
                    const isManual = e.target.value === 'manual';
                    if (glitchScaleGroup) glitchScaleGroup.style.display = isManual ? 'block' : 'none';
                    if (glitchXGroup) glitchXGroup.style.display = isManual ? 'block' : 'none';
                    if (glitchYGroup) glitchYGroup.style.display = isManual ? 'block' : 'none';

                    // Reapply fit mode
                    if (state.glitchImage.loaded && state.glitchImage.img) {
                        applyGlitchImageFitMode();
                    }
                });
            }

            setupSlider('glitchScaleSlider', 'glitchScaleValue', (value) => {
                if (!state.glitchImage.loaded) return;
                state.glitchImage.scale = value;
                state.glitchImage.width = state.glitchImage.originalWidth * value;
                state.glitchImage.height = state.glitchImage.originalHeight * value;
            }, 'x');

            setupSlider('glitchXSlider', 'glitchXValue', (value) => {
                if (!state.glitchImage.loaded) return;
                state.glitchImage.x = value;
            });

            setupSlider('glitchYSlider', 'glitchYValue', (value) => {
                if (!state.glitchImage.loaded) return;
                state.glitchImage.y = value;
            });

            if (glitchResetBtn) {
                glitchResetBtn.addEventListener('click', () => {
                    if (!state.glitchImage.loaded || !state.glitchImage.img) return;

                    // Reset to center and default scale
                    state.glitchImage.scale = 1.0;
                    state.glitchImage.x = 0;
                    state.glitchImage.y = 0;

                    // Update sliders
                    const scaleSlider = document.getElementById('glitchScaleSlider');
                    const scaleValue = document.getElementById('glitchScaleValue');
                    const xSlider = document.getElementById('glitchXSlider');
                    const xValue = document.getElementById('glitchXValue');
                    const ySlider = document.getElementById('glitchYSlider');
                    const yValue = document.getElementById('glitchYValue');

                    if (scaleSlider) scaleSlider.value = 1.0;
                    if (scaleValue) scaleValue.textContent = '1.0x';
                    if (xSlider) xSlider.value = 0;
                    if (xValue) xValue.textContent = '0';
                    if (ySlider) ySlider.value = 0;
                    if (yValue) yValue.textContent = '0';

                    // Reapply fit mode
                    applyGlitchImageFitMode();
                });
            }

            // Frequency emphasis sliders
            setupSlider('lowEmphasis', 'lowValue', (value) => {
                state.settings.lowEmphasis = value;
            });

            setupSlider('midEmphasis', 'midValue', (value) => {
                state.settings.midEmphasis = value;
            });

            setupSlider('highEmphasis', 'highValue', (value) => {
                state.settings.highEmphasis = value;
            });

            // Wave settings sliders
            setupSlider('intensitySlider', 'intensityValue', (value) => {
                state.settings.intensity = value;
            });

            setupSlider('speedSlider', 'speedValue', (value) => {
                state.settings.speed = value;
            });

            setupSlider('smoothingSlider', 'smoothingValue', (value) => {
                state.settings.smoothing = value;
                if (state.analyser) {
                    state.analyser.smoothingTimeConstant = value;
                }
            });

            // NEON color temperature slider
            setupSlider('colorTempSlider', 'colorTempValue', (value) => {
                state.settings.colorTemp = value;
            });


            // GLITCH rotation intensity slider
            setupSlider('rotationIntensitySlider', 'rotationIntensityValue', (value) => {
                state.settings.rotationIntensity = value;
            });

            // GLITCH effect intensity slider
            setupSlider('glitchIntensitySlider', 'glitchIntensityValue', (value) => {
                state.settings.glitchEffectIntensity = value;
            });

            // GLITCH contrast slider
            setupSlider('glitchContrastSlider', 'glitchContrastValue', (value) => {
                state.settings.glitchContrast = value;
            });

            // STARS hue slider
            const starHueSlider = document.getElementById('starHueSlider');
            const starHueValue = document.getElementById('starHueValue');
            if (starHueSlider && starHueValue) {
                starHueSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starHue = value;
                    starHueValue.textContent = `${Math.round(value)}°`;
                    // Update star gradient with new hue
                    if (state.stars.initialized) {
                        updateStarGradient();
                    }
                });
            }

            // STARS saturation slider
            const starSaturationSlider = document.getElementById('starSaturationSlider');
            const starSaturationValue = document.getElementById('starSaturationValue');
            if (starSaturationSlider && starSaturationValue) {
                starSaturationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starSaturation = value;
                    starSaturationValue.textContent = `${Math.round(value)}%`;
                    // Update star gradient with new saturation
                    if (state.stars.initialized) {
                        updateStarGradient();
                    }
                });
            }

            // STARS speed slider
            const starSpeedSlider = document.getElementById('starSpeedSlider');
            const starSpeedValue = document.getElementById('starSpeedValue');
            if (starSpeedSlider && starSpeedValue) {
                starSpeedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starSpeed = value;
                    starSpeedValue.textContent = value.toFixed(1);
                    // Speed affects orbit velocity, no need to reinitialize
                });
            }

            // STARS count slider
            const starCountSlider = document.getElementById('starCountSlider');
            const starCountValue = document.getElementById('starCountValue');
            if (starCountSlider && starCountValue) {
                starCountSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.starCount = value;
                    starCountValue.textContent = value;
                    // Star count change requires reinitialization
                    if (state.stars.initialized) {
                        state.stars.initialized = false;
                    }
                });
            }

            // STARS brightness slider
            const starBrightnessSlider = document.getElementById('starBrightnessSlider');
            const starBrightnessValue = document.getElementById('starBrightnessValue');
            if (starBrightnessSlider && starBrightnessValue) {
                starBrightnessSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starBrightness = value;
                    starBrightnessValue.textContent = value.toFixed(2);
                    // Brightness change requires reinitialization to update star alphas
                    if (state.stars.initialized) {
                        state.stars.initialized = false;
                    }
                });
            }

            // STARS audio boost slider
            const starAudioBoostSlider = document.getElementById('starAudioBoostSlider');
            const starAudioBoostValue = document.getElementById('starAudioBoostValue');
            if (starAudioBoostSlider && starAudioBoostValue) {
                starAudioBoostSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starAudioBoost = value;
                    starAudioBoostValue.textContent = `${value.toFixed(1)}x`;
                    // Audio boost affects rendering, no reinit needed
                });
            }

            // STARS twinkle slider
            const starTwinkleSlider = document.getElementById('starTwinkleSlider');
            const starTwinkleValue = document.getElementById('starTwinkleValue');
            if (starTwinkleSlider && starTwinkleValue) {
                starTwinkleSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.starTwinkle = value;
                    starTwinkleValue.textContent = value;
                    // Twinkle affects rendering, no reinit needed
                });
            }

            // STARS min opacity slider
            const starMinOpacitySlider = document.getElementById('starMinOpacitySlider');
            const starMinOpacityValue = document.getElementById('starMinOpacityValue');
            if (starMinOpacitySlider && starMinOpacityValue) {
                starMinOpacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starMinOpacity = value;
                    starMinOpacityValue.textContent = value.toFixed(2);
                    // Opacity change requires reinitialization to update star alphas
                    if (state.stars.initialized) {
                        state.stars.initialized = false;
                    }
                });
            }

            // STARS max opacity slider
            const starMaxOpacitySlider = document.getElementById('starMaxOpacitySlider');
            const starMaxOpacityValue = document.getElementById('starMaxOpacityValue');
            if (starMaxOpacitySlider && starMaxOpacityValue) {
                starMaxOpacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starMaxOpacity = value;
                    starMaxOpacityValue.textContent = value.toFixed(2);
                    // Opacity change requires reinitialization to update star alphas
                    if (state.stars.initialized) {
                        state.stars.initialized = false;
                    }
                });
            }

            // STARS Z-axis speed slider
            const starZSpeedSlider = document.getElementById('starZSpeedSlider');
            const starZSpeedValue = document.getElementById('starZSpeedValue');
            if (starZSpeedSlider && starZSpeedValue) {
                starZSpeedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starZSpeed = value;
                    starZSpeedValue.textContent = value.toFixed(1);
                    // Z-speed affects rendering in real-time, no reinit needed
                });
            }

            // STARS SMOOTHING slider
            const starSmoothingSlider = document.getElementById('starSmoothingSlider');
            const starSmoothingValue = document.getElementById('starSmoothingValue');
            if (starSmoothingSlider && starSmoothingValue) {
                starSmoothingSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starSmoothing = value;
                    starSmoothingValue.textContent = value.toFixed(1);
                    // Smoothing affects rendering in real-time, no reinit needed
                });
            }

            // STARS DIAMETER slider
            const starDiameterSlider = document.getElementById('starDiameterSlider');
            const starDiameterValue = document.getElementById('starDiameterValue');
            if (starDiameterSlider && starDiameterValue) {
                starDiameterSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starDiameter = value;
                    starDiameterValue.textContent = `${value.toFixed(1)}x`;
                    // Reinitialize stars to apply new diameter
                    state.stars.initialized = false;
                });
            }

            // STARS MODE selector
            const starModeSelect = document.getElementById('starModeSelect');
            const starLayersControl = document.getElementById('starLayersControl');
            if (starModeSelect && starLayersControl) {
                // Initialize visibility based on current mode
                if (state.settings.starMode === 'grids' || state.settings.starMode === 'dots') {
                    starLayersControl.style.display = 'block';
                } else {
                    starLayersControl.style.display = 'none';
                }

                starModeSelect.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    state.settings.starMode = mode;

                    // Show/hide layers control based on mode
                    if (mode === 'grids' || mode === 'dots') {
                        starLayersControl.style.display = 'block';
                    } else {
                        starLayersControl.style.display = 'none';
                    }

                    // Reinitialize stars for new mode
                    state.stars.initialized = false;
                });
            }

            // STARS LAYERS slider
            const starLayersSlider = document.getElementById('starLayersSlider');
            const starLayersValue = document.getElementById('starLayersValue');
            if (starLayersSlider && starLayersValue) {
                starLayersSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.starLayers = value;
                    starLayersValue.textContent = value.toString();
                    // Reinitialize stars to apply new layer count
                    state.stars.initialized = false;
                });
            }

            // WAVE MODE selector
            const waveModeSelect = document.getElementById('waveModeSelect');
            const waveLayersControl = document.getElementById('waveLayersControl');
            if (waveModeSelect && waveLayersControl) {
                // Initialize visibility based on current mode
                if (state.settings.waveMode === 'grids' || state.settings.waveMode === 'dots') {
                    waveLayersControl.style.display = 'block';
                } else {
                    waveLayersControl.style.display = 'none';
                }

                waveModeSelect.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    state.settings.waveMode = mode;

                    // Show/hide layers control based on mode
                    if (mode === 'grids' || mode === 'dots') {
                        waveLayersControl.style.display = 'block';
                    } else {
                        waveLayersControl.style.display = 'none';
                    }
                });
            }

            // WAVE LAYERS slider
            const waveLayersSlider = document.getElementById('waveLayersSlider');
            const waveLayersValue = document.getElementById('waveLayersValue');
            if (waveLayersSlider && waveLayersValue) {
                waveLayersSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.waveLayers = value;
                    waveLayersValue.textContent = value.toString();
                });
            }

            // WAVE HUE slider
            const waveHueSlider = document.getElementById('waveHueSlider');
            const waveHueValue = document.getElementById('waveHueValue');
            if (waveHueSlider && waveHueValue) {
                waveHueSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.waveHue = value;
                    waveHueValue.textContent = value + '°';
                });
            }

            // WAVE SATURATION slider
            const waveSaturationSlider = document.getElementById('waveSaturationSlider');
            const waveSaturationValue = document.getElementById('waveSaturationValue');
            if (waveSaturationSlider && waveSaturationValue) {
                waveSaturationSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    state.settings.waveSaturation = value;
                    waveSaturationValue.textContent = value + '%';
                });
            }

            // Density and mode options
            document.querySelectorAll('.density-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Handle density change
                    if (option.dataset.density) {
                        document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.density = option.dataset.density;
                        setupWaveGrid();

                        // Map density to burst size for NEON theme
                        const densityToBurstSize = {
                            'low': 0.5,
                            'medium': 1.0,
                            'high': 1.5
                        };
                        state.settings.neonBurstSize = densityToBurstSize[option.dataset.density] || 1.0;
                        console.log(`🎨 NEON burst size set to: ${state.settings.neonBurstSize} (density: ${option.dataset.density})`);
                    }

                    // Handle mode change
                    if (option.dataset.mode) {
                        document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.mode = option.dataset.mode;
                        console.log(`🔄 Mode changed to: ${state.settings.mode.toUpperCase()}`);
                    }

                    // Handle glitch mode change
                    if (option.dataset.glitchMode) {
                        document.querySelectorAll('[data-glitch-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.glitchMode = option.dataset.glitchMode;
                        console.log(`🎨 GLITCH mode changed to: ${state.settings.glitchMode.toUpperCase()}`);
                    }

                    // Handle neon mode change
                    if (option.dataset.neonMode) {
                        document.querySelectorAll('[data-neon-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.neonMode = option.dataset.neonMode;
                        console.log(`🎨 NEON mode changed to: ${state.settings.neonMode.toUpperCase()}`);
                    }
                });
            });

            // Reset button
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetToDefaults);
            }

            // Click-to-center feature for STARS theme
            document.addEventListener('click', (e) => {
                // Only activate for STARS theme and when not clicking on controls
                if (state.settings.theme === 'stars' && !elements.sidebar.contains(e.target)) {
                    state.stars.targetCenterX = e.clientX;
                    state.stars.targetCenterY = e.clientY;
                }
            });

            // Add media button and dropdown
            const addImageButton = document.getElementById('addImageButton');
            const addImageDropdown = document.getElementById('addImageDropdown');
            const addMediaMenuItem = document.getElementById('addMediaMenuItem');

            if (addImageButton && addImageDropdown && addMediaMenuItem) {
                // Toggle dropdown on button click
                addImageButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addImageDropdown.classList.toggle('show');
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!addImageButton.contains(e.target) && !addImageDropdown.contains(e.target)) {
                        addImageDropdown.classList.remove('show');
                    }
                });

                // Unified media modal handlers
                const mediaPopup = document.getElementById('mediaPopup');
                const mediaPopupAdd = document.getElementById('mediaPopupAdd');
                const mediaPopupCancel = document.getElementById('mediaPopupCancel');
                const mediaUrlInput = document.getElementById('mediaUrlInput');
                const mediaBrowseLink = document.getElementById('mediaBrowseLink');
                const mediaFileInput = document.getElementById('mediaFileInput');

                function openMediaModal(type) {
                    const mediaPopupTitle = document.getElementById('mediaPopupTitle');

                    if (type === 'background') {
                        mediaPopupTitle.textContent = 'UPLOAD BACKGROUND IMAGE';
                        mediaUrlInput.placeholder = 'Enter image URL (direct .jpg, .png file only)';
                        mediaFileInput.accept = 'image/*';
                    } else {
                        // Default: combined media (both image and video)
                        mediaPopupTitle.textContent = 'ADD MEDIA';
                        mediaUrlInput.placeholder = 'Enter media URL (direct image or video file)';
                        mediaFileInput.accept = 'image/*,video/*';
                    }

                    mediaUrlInput.value = '';
                    mediaPopup.style.display = 'flex';
                    mediaUrlInput.focus();
                }

                // Handle "Add Media" menu item click
                addMediaMenuItem.addEventListener('click', () => {
                    addImageDropdown.classList.remove('show');
                    openMediaModal('media');
                });

                if (mediaPopupAdd && mediaPopup && mediaUrlInput) {
                    mediaPopupAdd.addEventListener('click', () => {
                        const url = mediaUrlInput.value.trim();
                        if (url) {
                            // Auto-detect media type from URL extension
                            const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov'];
                            const isVideo = videoExtensions.some(ext => url.toLowerCase().includes(ext));

                            if (isVideo) {
                                loadVideoFromUrl(url);
                            } else {
                                loadImageFromUrl(url);
                            }
                            mediaPopup.style.display = 'none';
                        }
                    });
                }

                if (mediaPopupCancel && mediaPopup) {
                    mediaPopupCancel.addEventListener('click', () => {
                        mediaPopup.style.display = 'none';
                    });
                }

                if (mediaBrowseLink && mediaFileInput) {
                    mediaBrowseLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        mediaFileInput.click();
                    });

                    mediaFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            if (file.type.startsWith('video/')) {
                                loadVideoFile(file);
                            } else if (file.type.startsWith('image/')) {
                                loadImageFile(file);
                            }
                            mediaPopup.style.display = 'none';
                            mediaFileInput.value = ''; // Reset for next use
                        }
                    });
                }

                // Close media popup on Escape key and Enter key
                if (mediaPopup && mediaUrlInput) {
                    mediaUrlInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            mediaPopup.style.display = 'none';
                        } else if (e.key === 'Enter') {
                            const url = mediaUrlInput.value.trim();
                            if (url) {
                                // Auto-detect media type from URL extension
                                const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov'];
                                const isVideo = videoExtensions.some(ext => url.toLowerCase().includes(ext));

                                if (isVideo) {
                                    loadVideoFromUrl(url);
                                } else {
                                    loadImageFromUrl(url);
                                }
                                mediaPopup.style.display = 'none';
                            }
                        }
                    });

                    // Close popup when clicking outside
                    mediaPopup.addEventListener('click', (e) => {
                        if (e.target === mediaPopup) {
                            mediaPopup.style.display = 'none';
                        }
                    });
                }

                // Handle "Save Canvas" menu item click
                const saveCanvasMenuItem = document.getElementById('saveCanvasMenuItem');
                if (saveCanvasMenuItem) {
                    saveCanvasMenuItem.addEventListener('click', () => {
                        addImageDropdown.classList.remove('show');
                        saveCanvasState();
                    });
                }

                // Handle "Load Canvas" menu item click
                const loadCanvasMenuItem = document.getElementById('loadCanvasMenuItem');
                const loadCanvasInput = document.getElementById('loadCanvasInput');
                if (loadCanvasMenuItem && loadCanvasInput) {
                    loadCanvasMenuItem.addEventListener('click', () => {
                        addImageDropdown.classList.remove('show');
                        loadCanvasInput.click();
                    });

                    loadCanvasInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadCanvasStateFromFile(file);
                        }
                    });
                }
            }

            // Mouse tracking
            window.addEventListener('mousemove', (e) => {
                state.mouse.x = e.clientX;
                state.mouse.y = e.clientY;
                state.mouse.onScreen = true;

                if (!state.mouse.set) {
                    state.mouse.sx = state.mouse.x;
                    state.mouse.sy = state.mouse.y;
                    state.mouse.lx = state.mouse.x;
                    state.mouse.ly = state.mouse.y;
                    state.mouse.set = true;
                }

                // Show controls on mouse movement
                showControls();
            });

            // Track when mouse leaves the screen
            window.addEventListener('mouseleave', () => {
                state.mouse.onScreen = false;
            });

            window.addEventListener('mouseenter', () => {
                state.mouse.onScreen = true;
            });

            // Window resize
            window.addEventListener('resize', () => {
                setupWaveGrid();
            });

            // Image upload overlay click handler
            const uploadOverlay = document.getElementById('upload-overlay');
            if (uploadOverlay) {
                uploadOverlay.addEventListener('click', () => {
                    // Open unified media modal for background image upload
                    openMediaModal('background');
                });
            }

            // Drag & drop image upload
            const dragOverlay = document.getElementById('drag-overlay');
            const visualizationContainer = document.getElementById('visualization-container');

            if (visualizationContainer && dragOverlay) {
                // Prevent default drag behavior
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    visualizationContainer.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Show drag overlay when dragging over
                visualizationContainer.addEventListener('dragenter', (e) => {
                    if (!state.glitchImage.loaded) {
                        dragOverlay.style.display = 'flex';
                    }
                });

                visualizationContainer.addEventListener('dragleave', (e) => {
                    // Only hide if we're leaving the container entirely
                    if (e.target === visualizationContainer) {
                        dragOverlay.style.display = 'none';
                    }
                });

                visualizationContainer.addEventListener('drop', (e) => {
                    dragOverlay.style.display = 'none';

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        // Check if it's a JSON file (canvas state)
                        if (file.type === 'application/json' || file.name.endsWith('.json')) {
                            console.log('📁 Loading canvas state from dropped JSON file');
                            loadCanvasStateFromFile(file);
                        } else if (file.type.startsWith('image/')) {
                            // It's an image file
                            loadImageFile(file);
                        }
                    }
                });
            }

            // Helper function to load image file
            function loadVideoFromUrl(url) {
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.muted = true; // Muted by default for autoplay compatibility

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.createElement('canvas');
                    canvas.style.position = 'absolute';
                    canvas.style.cursor = 'move';
                    canvas.style.pointerEvents = 'auto';
                    canvas.className = 'image-object-canvas';
                    document.getElementById('visualization-container').appendChild(canvas);

                    // Scale to reasonable size
                    const width = Math.min(video.videoWidth, 600);
                    const height = (width / video.videoWidth) * video.videoHeight;
                    const x = (state.boundingRect.width - width) / 2;
                    const y = (state.boundingRect.height - height) / 2;

                    // Create video object (similar to image object but with video element)
                    const videoObject = {
                        video: video,
                        isVideo: true,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        originalWidth: width,
                        originalHeight: height,
                        scale: 1.0,
                        theme: 'none',
                        transparency: 1.0,
                        rotation: 0,
                        blur: 0,
                        themeBlur: 0,
                        themeOpacity: 1.0,
                        flashFrequencyEnabled: false,
                        flashFrequencyThreshold: 0.5,
                        flashVolumeEnabled: false,
                        flashVolumeThreshold: 0.5,
                        loop: true,
                        trimStart: 0,
                        trimEnd: video.duration,
                        duration: video.duration,
                        canvas: canvas,
                        isDragging: false,
                        isResizing: false,
                        dragStartX: 0,
                        dragStartY: 0,
                        dragStartWidth: 0,
                        dragStartHeight: 0
                    };

                    state.imageObjects.push(videoObject);
                    const videoIndex = state.imageObjects.length - 1;
                    state.selectedImageIndex = videoIndex;

                    // Add event listeners for selection and dragging
                    setupImageInteraction(canvas, videoIndex);

                    // Start playing the video
                    video.loop = true;
                    video.play().catch(e => console.warn('Video autoplay prevented:', e));

                    console.log(`✅ Video object created: ${video.videoWidth}x${video.videoHeight} → ${width.toFixed(0)}x${height.toFixed(0)}, duration: ${video.duration.toFixed(2)}s`);

                    // Update mode visibility
                    updateModeVisibility();

                    // Send updated state to companion
                    sendStateToMobile();
                });

                video.addEventListener('error', (e) => {
                    console.error('❌ Failed to load video:', url, e);
                    alert('Failed to load video. Please check the URL and ensure CORS is enabled.');
                });

                video.src = url;
                video.load();
            }

            function loadImageFromUrl(url) {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = () => {
                    if (state.settings.theme === 'glitch') {
                        // GLITCH theme: Load into glitchImage for background replacement
                        state.glitchImage.img = img;
                        state.glitchImage.loaded = true;

                        // Apply fit mode (cover by default)
                        applyGlitchImageFitMode();

                        // Show GLITCH controls
                        updateModeVisibility();

                        console.log(`✅ GLITCH image loaded from URL: ${img.width}x${img.height} → ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                    } else {
                        // LINEAR/NEON theme: Create image object overlay
                        const canvas = document.createElement('canvas');
                        canvas.style.position = 'absolute';
                        canvas.style.cursor = 'move';
                        canvas.style.pointerEvents = 'auto';
                        canvas.className = 'image-object-canvas';
                        document.getElementById('visualization-container').appendChild(canvas);

                        // Scale to reasonable size
                        const width = Math.min(img.width, 600);
                        const height = (width / img.width) * img.height;
                        const x = (state.boundingRect.width - width) / 2;
                        const y = (state.boundingRect.height - height) / 2;

                        // Create image object
                        const imageObject = {
                            img: img,
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            originalWidth: width,
                            originalHeight: height,
                            scale: 1.0,
                            theme: 'none',
                            transparency: 1.0,
                            rotation: 0,
                            blur: 0,
                            themeBlur: 0,
                            themeOpacity: 1.0,
                            flashFrequencyEnabled: false,
                            flashFrequencyThreshold: 0.5,
                            flashVolumeEnabled: false,
                            flashVolumeThreshold: 0.5,
                            canvas: canvas,
                            isDragging: false,
                            isResizing: false,
                            dragStartX: 0,
                            dragStartY: 0,
                            dragStartWidth: 0,
                            dragStartHeight: 0
                        };

                        state.imageObjects.push(imageObject);
                        const imageIndex = state.imageObjects.length - 1;
                        state.selectedImageIndex = imageIndex;

                        // Add event listeners for selection and dragging
                        setupImageInteraction(canvas, imageIndex);

                        console.log(`✅ Image object created from URL: ${img.width}x${img.height} → ${width.toFixed(0)}x${height.toFixed(0)}`);

                        // Update mode visibility
                        updateModeVisibility();

                        // Send updated state to companion
                        sendStateToMobile();
                    }
                };

                img.onerror = (e) => {
                    console.error('❌ Failed to load image from URL:', url, e);

                    // Detect error type
                    let errorMsg = 'Failed to load image';
                    if (url.startsWith('http://') && window.location.protocol === 'https:') {
                        errorMsg = 'Mixed content blocked. Use HTTPS URL';
                    } else if (e.type === 'error') {
                        errorMsg = 'Invalid image URL or CORS error';
                    }

                    showToast(errorMsg, 'error');
                };

                // Validate URL before loading
                if (!url || url.trim() === '') {
                    showToast('Please enter a valid image URL', 'error');
                    return;
                }

                img.src = url;
            }

            function loadVideoFile(file) {
                // Validate file type
                if (!file.type.startsWith('video/')) {
                    showToast('Invalid file type. Please select a video file', 'error');
                    return;
                }

                // Validate file size (50MB limit)
                const maxSize = 50 * 1024 * 1024; // 50MB in bytes
                if (file.size > maxSize) {
                    showToast('File too large. Maximum size is 50MB', 'error');
                    return;
                }

                const video = document.createElement('video');
                video.muted = true;

                const fileURL = URL.createObjectURL(file);

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.createElement('canvas');
                    canvas.style.position = 'absolute';
                    canvas.style.cursor = 'move';
                    canvas.style.pointerEvents = 'auto';
                    canvas.className = 'image-object-canvas';
                    document.getElementById('visualization-container').appendChild(canvas);

                    // Scale to reasonable size
                    const width = Math.min(video.videoWidth, 600);
                    const height = (width / video.videoWidth) * video.videoHeight;
                    const x = (state.boundingRect.width - width) / 2;
                    const y = (state.boundingRect.height - height) / 2;

                    // Create video object
                    const videoObject = {
                        video: video,
                        isVideo: true,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        originalWidth: width,
                        originalHeight: height,
                        scale: 1.0,
                        theme: 'none',
                        transparency: 1.0,
                        rotation: 0,
                        blur: 0,
                        themeBlur: 0,
                        themeOpacity: 1.0,
                        flashFrequencyEnabled: false,
                        flashFrequencyThreshold: 0.5,
                        flashVolumeEnabled: false,
                        flashVolumeThreshold: 0.5,
                        loop: true,
                        trimStart: 0,
                        trimEnd: video.duration,
                        duration: video.duration,
                        canvas: canvas,
                        isDragging: false,
                        isResizing: false,
                        dragStartX: 0,
                        dragStartY: 0,
                        dragStartWidth: 0,
                        dragStartHeight: 0
                    };

                    state.imageObjects.push(videoObject);
                    const videoIndex = state.imageObjects.length - 1;
                    state.selectedImageIndex = videoIndex;

                    // Add event listeners for selection and dragging
                    setupImageInteraction(canvas, videoIndex);

                    // Start playing the video
                    video.loop = true;
                    video.play().catch(e => console.warn('Video autoplay prevented:', e));

                    console.log(`✅ Video file loaded: ${video.videoWidth}x${video.videoHeight} → ${width.toFixed(0)}x${height.toFixed(0)}, duration: ${video.duration.toFixed(2)}s`);

                    // Update mode visibility
                    updateModeVisibility();

                    // Send updated state to companion
                    sendStateToMobile();
                });

                video.addEventListener('error', (e) => {
                    console.error('❌ Failed to load video file:', e);
                    let errorMsg = 'Failed to load video file';
                    if (e.target.error) {
                        switch (e.target.error.code) {
                            case e.target.error.MEDIA_ERR_ABORTED:
                                errorMsg = 'Video loading aborted';
                                break;
                            case e.target.error.MEDIA_ERR_NETWORK:
                                errorMsg = 'Network error loading video';
                                break;
                            case e.target.error.MEDIA_ERR_DECODE:
                                errorMsg = 'Video codec not supported';
                                break;
                            case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                errorMsg = 'Video format not supported';
                                break;
                        }
                    }
                    showToast(errorMsg, 'error');
                    URL.revokeObjectURL(fileURL);
                });

                video.src = fileURL;
                video.load();
            }

            function loadImageFile(file) {
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    showToast('Invalid file type. Please select an image file', 'error');
                    return;
                }

                // Validate file size (50MB limit)
                const maxSize = 50 * 1024 * 1024; // 50MB in bytes
                if (file.size > maxSize) {
                    showToast('File too large. Maximum size is 50MB', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (state.settings.theme === 'glitch') {
                            // GLITCH theme: Load into glitchImage for background replacement
                            state.glitchImage.img = img;
                            state.glitchImage.loaded = true;

                            // Apply fit mode (cover by default)
                            applyGlitchImageFitMode();

                            // Show GLITCH controls
                            updateModeVisibility();

                            console.log(`✅ GLITCH image loaded: ${img.width}x${img.height} → ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                        } else {
                            // LINEAR/NEON theme: Create image object overlay
                            const canvas = document.createElement('canvas');
                            canvas.style.position = 'absolute';
                            canvas.style.cursor = 'move';
                            canvas.style.pointerEvents = 'auto';
                            canvas.className = 'image-object-canvas';
                            document.getElementById('visualization-container').appendChild(canvas);

                            // Scale to reasonable size
                            const width = Math.min(img.width, 600);
                            const height = (width / img.width) * img.height;
                            const x = (state.boundingRect.width - width) / 2;
                            const y = (state.boundingRect.height - height) / 2;

                            // Create image object
                            const imageObject = {
                                img: img,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                originalWidth: width,
                                originalHeight: height,
                                scale: 1.0,
                                theme: 'none', // Default to no effect
                                transparency: 1.0, // Default to fully opaque
                                rotation: 0, // Rotation in degrees
                                blur: 0, // Blur amount in pixels
                                themeBlur: 0, // Blur on theme effect
                                themeOpacity: 1.0, // Opacity of theme effect
                                flashFrequencyEnabled: false,
                                flashFrequencyThreshold: 0.5,
                                flashVolumeEnabled: false,
                                flashVolumeThreshold: 0.5,
                                canvas: canvas,
                                isDragging: false,
                                isResizing: false,
                                dragStartX: 0,
                                dragStartY: 0,
                                dragStartWidth: 0,
                                dragStartHeight: 0
                            };

                            state.imageObjects.push(imageObject);
                            const imageIndex = state.imageObjects.length - 1;
                            state.selectedImageIndex = imageIndex; // Select the newly added image

                            // Add event listeners for selection and dragging
                            setupImageInteraction(canvas, imageIndex);

                            console.log(`✅ Image object created: ${img.width}x${img.height} → ${width.toFixed(0)}x${height.toFixed(0)}, theme: ${imageObject.theme}`);

                            // Send updated state to companion
                            sendStateToMobile();
                        }

                        // Hide upload overlay
                        updateModeVisibility();
                    };

                    img.onerror = () => {
                        console.error('❌ Failed to load image from file:', file.name);
                        showToast('Failed to load image file. File may be corrupted', 'error');
                    };

                    img.src = event.target.result;
                };

                reader.onerror = () => {
                    console.error('❌ Failed to read file:', file.name);
                    showToast('Failed to read file. Please try again', 'error');
                };

                reader.readAsDataURL(file);
            }

            // Global mouse handlers for dragging and resizing
            window.addEventListener('mousemove', (e) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (!imageObj) return;

                if (imageObj.isDragging) {
                    // Drag to move
                    imageObj.x = e.clientX - imageObj.dragStartX;
                    imageObj.y = e.clientY - imageObj.dragStartY;
                } else if (imageObj.isResizing) {
                    // Drag to resize
                    const deltaX = e.clientX - imageObj.dragStartX;
                    const deltaY = e.clientY - imageObj.dragStartY;

                    const newWidth = Math.max(100, imageObj.dragStartWidth + deltaX);
                    const newHeight = Math.max(100, imageObj.dragStartHeight + deltaY);

                    // Maintain aspect ratio
                    let aspectRatio;
                    if (imageObj.isVideo && imageObj.video) {
                        aspectRatio = imageObj.video.videoWidth / imageObj.video.videoHeight;
                    } else if (imageObj.img) {
                        aspectRatio = imageObj.img.width / imageObj.img.height;
                    } else {
                        aspectRatio = 1;
                    }
                    imageObj.width = newWidth;
                    imageObj.height = newWidth / aspectRatio;
                }
            });

            window.addEventListener('mouseup', (e) => {
                // Stop dragging/resizing for all image objects
                state.imageObjects.forEach((imageObj) => {
                    if (imageObj.isDragging || imageObj.isResizing) {
                        imageObj.isDragging = false;
                        imageObj.isResizing = false;
                        imageObj.canvas.style.cursor = 'move';
                    }
                });
            });

            // Click on background to deselect images (reuse visualizationContainer from above)
            if (visualizationContainer) {
                visualizationContainer.addEventListener('click', (e) => {
                    // Only deselect if clicking directly on the container (not on an image canvas)
                    if (e.target === visualizationContainer || e.target.id === 'wave-svg') {
                        state.selectedImageIndex = -1;
                        updateModeVisibility(); // Update UI to hide image theme selector
                    }
                });
            }

            // Click to add gradient centers (NEON theme only)
            window.addEventListener('click', (e) => {
                // Only add gradient centers for NEON theme
                if (state.settings.theme !== 'neon') return;

                // Don't add if clicking on UI elements or image canvases
                if (e.target.closest('.sidebar') || e.target.closest('.sidebar-toggle') || e.target.classList.contains('image-object-canvas')) return;

                // Add new gradient center at click position
                const newCenter = {
                    x: e.clientX,
                    y: e.clientY,
                    createdAt: Date.now()
                };

                state.userGradientCenters.push(newCenter);

                // Keep only the most recent 3 centers
                if (state.userGradientCenters.length > 3) {
                    state.userGradientCenters.shift(); // Remove the oldest
                }

                console.log(`✨ Added gradient center at (${e.clientX}, ${e.clientY}). Total: ${state.userGradientCenters.length}`);
            });

            // Click & drag to resize GLITCH background image
            const themeCanvas = document.getElementById('theme-canvas');

            if (themeCanvas) {
                themeCanvas.addEventListener('mousedown', (e) => {
                    // Only handle resize when GLITCH theme is active and image is loaded
                    if (state.settings.theme !== 'glitch' || !state.glitchImage.loaded) return;

                    state.glitchImage.isDragging = true;
                    state.glitchImage.dragStartX = e.clientX;
                    state.glitchImage.dragStartY = e.clientY;
                    state.glitchImage.dragStartWidth = state.glitchImage.width;
                    state.glitchImage.dragStartHeight = state.glitchImage.height;

                    themeCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            }

            // Handle mouse move for resize
            window.addEventListener('mousemove', (e) => {
                if (!state.glitchImage.isDragging) return;

                // Calculate drag distance
                const dx = e.clientX - state.glitchImage.dragStartX;
                const dy = e.clientY - state.glitchImage.dragStartY;
                const dragDistance = Math.hypot(dx, dy);
                const dragDirection = dx + dy > 0 ? 1 : -1;

                // Calculate new size (proportional to drag distance)
                const scaleFactor = 1 + (dragDirection * dragDistance / 500);
                const newWidth = Math.max(100, state.glitchImage.dragStartWidth * scaleFactor);
                const aspectRatio = state.glitchImage.img.height / state.glitchImage.img.width;
                const newHeight = newWidth * aspectRatio;

                // Update image dimensions
                state.glitchImage.width = newWidth;
                state.glitchImage.height = newHeight;

                // Re-center the image
                state.glitchImage.x = (state.boundingRect.width - newWidth) / 2;
                state.glitchImage.y = (state.boundingRect.height - newHeight) / 2;
            });

            // Handle mouse up to finish resize
            window.addEventListener('mouseup', () => {
                if (state.glitchImage.isDragging) {
                    state.glitchImage.isDragging = false;

                    // Reset cursor on theme canvas
                    if (themeCanvas) themeCanvas.style.cursor = 'grab';

                    console.log(`🖼️ GLITCH image resized to ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                }
            });
        }

        /**
         * Show toast notification
         * @param {string} message - Message to display
         * @param {string} type - 'error' or 'success' (default: 'error')
         * @param {number} duration - How long to show (ms, default: 4000)
         */
        function showToast(message, type = 'error', duration = 4000) {
            const toast = document.createElement('div');
            toast.className = `toast${type === 'success' ? ' success' : ''}`;
            toast.textContent = message;

            const container = document.getElementById('toastContainer');
            container.appendChild(toast);

            // Trigger reflow to enable transition
            toast.offsetHeight;

            // Show toast
            toast.classList.add('show');

            // Auto-hide after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300); // Match CSS transition duration
            }, duration);
        }

        /**
         * Apply fit mode to GLITCH background image
         */
        function applyGlitchImageFitMode() {
            if (!state.glitchImage.loaded || !state.glitchImage.img) return;

            const img = state.glitchImage.img;
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;
            const canvasAspect = canvasWidth / canvasHeight;
            const imgAspect = img.width / img.height;

            const fitMode = state.glitchImage.fitMode || 'cover';

            switch (fitMode) {
                case 'cover':
                    // Fill canvas completely (may crop)
                    if (imgAspect > canvasAspect) {
                        // Image is wider - fit to height
                        state.glitchImage.originalHeight = canvasHeight;
                        state.glitchImage.originalWidth = canvasHeight * imgAspect;
                    } else {
                        // Image is taller - fit to width
                        state.glitchImage.originalWidth = canvasWidth;
                        state.glitchImage.originalHeight = canvasWidth / imgAspect;
                    }
                    // Center the image
                    state.glitchImage.scale = 1.0;
                    state.glitchImage.width = state.glitchImage.originalWidth;
                    state.glitchImage.height = state.glitchImage.originalHeight;
                    state.glitchImage.x = (canvasWidth - state.glitchImage.width) / 2;
                    state.glitchImage.y = (canvasHeight - state.glitchImage.height) / 2;
                    break;

                case 'contain':
                    // Fit entirely within canvas (may letterbox)
                    if (imgAspect > canvasAspect) {
                        // Image is wider - fit to width
                        state.glitchImage.originalWidth = canvasWidth;
                        state.glitchImage.originalHeight = canvasWidth / imgAspect;
                    } else {
                        // Image is taller - fit to height
                        state.glitchImage.originalHeight = canvasHeight;
                        state.glitchImage.originalWidth = canvasHeight * imgAspect;
                    }
                    // Center the image
                    state.glitchImage.scale = 1.0;
                    state.glitchImage.width = state.glitchImage.originalWidth;
                    state.glitchImage.height = state.glitchImage.originalHeight;
                    state.glitchImage.x = (canvasWidth - state.glitchImage.width) / 2;
                    state.glitchImage.y = (canvasHeight - state.glitchImage.height) / 2;
                    break;

                case 'fill':
                    // Stretch to exactly fill canvas
                    state.glitchImage.originalWidth = canvasWidth;
                    state.glitchImage.originalHeight = canvasHeight;
                    state.glitchImage.scale = 1.0;
                    state.glitchImage.width = canvasWidth;
                    state.glitchImage.height = canvasHeight;
                    state.glitchImage.x = 0;
                    state.glitchImage.y = 0;
                    break;

                case 'manual':
                    // User-controlled scale and position
                    // Keep existing originalWidth/Height or set from image
                    if (state.glitchImage.originalWidth === 0) {
                        state.glitchImage.originalWidth = img.width;
                        state.glitchImage.originalHeight = img.height;
                    }
                    state.glitchImage.width = state.glitchImage.originalWidth * state.glitchImage.scale;
                    state.glitchImage.height = state.glitchImage.originalHeight * state.glitchImage.scale;
                    // Keep existing x/y positions
                    break;
            }
        }

        function setupSlider(sliderId, valueId, callback) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                callback(value);
                valueDisplay.textContent = value.toFixed(1);
            });
        }

        function resetToDefaults() {
            // Reset settings
            state.settings = {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.5,
                density: 'medium',
                gradient: 'default',
                mode: 'default',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0,
                glitchContrast: 1.0,
                glitchMode: 'rgb',
                neonMode: 'bright',
                colorTemp: 1.0,
                image3DMotion: 0.0,
                starHue: 44,
                starSaturation: 12,
                starSpeed: 1.0,
                starCount: 1200,
                starBrightness: 0.8,
                starAudioBoost: 3.0,
                starTwinkle: 20,
                starMinOpacity: 0.2,
                starMaxOpacity: 1.0,
                starZSpeed: 0,
                starSmoothing: 0.5,
                starDiameter: 1.0,
                starMode: 'planes',
                starLayers: 3,
                waveMode: 'planes',
                waveLayers: 3,
                waveHue: 280,
                waveSaturation: 70
            };

            // Update UI
            document.getElementById('lowEmphasis').value = 1.0;
            document.getElementById('midEmphasis').value = 1.0;
            document.getElementById('highEmphasis').value = 1.0;
            document.getElementById('intensitySlider').value = 2.5;
            document.getElementById('speedSlider').value = 1.0;
            document.getElementById('smoothingSlider').value = 0.5;
            document.getElementById('colorTempSlider').value = 1.0;
            document.getElementById('rotationIntensitySlider').value = 1.0;
            document.getElementById('glitchIntensitySlider').value = 1.0;
            document.getElementById('glitchContrastSlider').value = 1.0;
            document.getElementById('image3DMotionSlider').value = 0.0;
            document.getElementById('starHueSlider').value = 44;
            document.getElementById('starSaturationSlider').value = 12;
            document.getElementById('starSpeedSlider').value = 1.0;
            document.getElementById('starCountSlider').value = 1200;
            document.getElementById('starBrightnessSlider').value = 0.8;
            document.getElementById('starAudioBoostSlider').value = 3.0;
            document.getElementById('starTwinkleSlider').value = 200;
            document.getElementById('starMinOpacitySlider').value = 0.2;
            document.getElementById('starMaxOpacitySlider').value = 1.0;
            document.getElementById('starZSpeedSlider').value = 0;
            document.getElementById('starSmoothingSlider').value = 0.5;
            document.getElementById('starDiameterSlider').value = 1.0;
            document.getElementById('starModeSelect').value = 'planes';
            document.getElementById('starLayersSlider').value = 3;
            document.getElementById('waveModeSelect').value = 'planes';
            document.getElementById('waveLayersSlider').value = 3;

            document.getElementById('lowValue').textContent = '1.0';
            document.getElementById('midValue').textContent = '1.0';
            document.getElementById('highValue').textContent = '1.0';
            document.getElementById('intensityValue').textContent = '2.5';
            document.getElementById('speedValue').textContent = '1.0';
            document.getElementById('smoothingValue').textContent = '0.5';
            document.getElementById('colorTempValue').textContent = '1.0';
            document.getElementById('rotationIntensityValue').textContent = '1.0';
            document.getElementById('glitchIntensityValue').textContent = '1.0';
            document.getElementById('glitchContrastValue').textContent = '1.0';
            document.getElementById('image3DMotionValue').textContent = '0.0';
            document.getElementById('starHueValue').textContent = '44°';
            document.getElementById('starSaturationValue').textContent = '12%';
            document.getElementById('starSpeedValue').textContent = '1.0';
            document.getElementById('starCountValue').textContent = '1200';
            document.getElementById('starBrightnessValue').textContent = '0.80';
            document.getElementById('starAudioBoostValue').textContent = '3.0x';
            document.getElementById('starTwinkleValue').textContent = '200';
            document.getElementById('starMinOpacityValue').textContent = '0.20';
            document.getElementById('starMaxOpacityValue').textContent = '1.00';
            document.getElementById('starZSpeedValue').textContent = '0.0';
            document.getElementById('starSmoothingValue').textContent = '0.5';
            document.getElementById('starDiameterValue').textContent = '1.0x';
            document.getElementById('starLayersValue').textContent = '3';
            document.getElementById('waveLayersValue').textContent = '3';
            document.getElementById('waveHueSlider').value = 280;
            document.getElementById('waveSaturationSlider').value = 70;
            document.getElementById('waveHueValue').textContent = '280°';
            document.getElementById('waveSaturationValue').textContent = '70%';

            // Update analyser if active
            if (state.analyser) {
                state.analyser.smoothingTimeConstant = 0.3;
            }

            // Clear user-created gradient centers
            state.userGradientCenters = [];

            // Reset density
            document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-density="medium"]').classList.add('active');

            // Reset mode
            document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-mode="hole"]').classList.add('active');

            // Reset glitch mode
            document.querySelectorAll('[data-glitch-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-glitch-mode="rgb"]').classList.add('active');

            // Reset neon mode
            document.querySelectorAll('[data-neon-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-neon-mode="bright"]').classList.add('active');

            // Reset theme
            document.getElementById('themeSelect').value = 'linear';

            // Rebuild grid and colors
            setupWaveGrid();
            updateColors();

            console.log('🔄 Reset to defaults');
        }

        // =====================================================
        // COMPANION DEVICE PAIRING (WebSocket)
        // =====================================================

        let socket = null;
        let pairingCode = null;
        let mobileConnected = false;

        // Connect to WebSocket server
        function initializePairing() {
            // Determine WebSocket server URL
            let socketUrl;
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                // Local development
                socketUrl = 'http://localhost:3000';
            } else {
                // Production: Always use Render deployment for WebSocket server
                // GitHub Pages can't run WebSocket servers, so we use Render
                socketUrl = 'https://fikei-github-io.onrender.com';
            }

            console.log('🔌 Connecting to WebSocket server:', socketUrl);
            socket = io(socketUrl);

            socket.on('connect', () => {
                console.log('🔌 Connected to WebSocket server');

                // Request pairing code from server
                socket.emit('desktop:create-session', (response) => {
                    if (response.success) {
                        pairingCode = response.code;
                        console.log('📱 Pairing code generated:', pairingCode);

                        // Update the pairing code display
                        const pairingCodeValue = document.getElementById('pairingCodeValue');
                        if (pairingCodeValue) {
                            pairingCodeValue.textContent = pairingCode;
                        }

                        // Update the pairing panel
                        const pairingCodeElement = document.getElementById('pairingCode');
                        if (pairingCodeElement) {
                            pairingCodeElement.textContent = pairingCode;
                        }

                        const pairingUrlElement = document.getElementById('pairingUrl');
                        if (pairingUrlElement) {
                            const companionUrl = `${window.location.origin}${window.location.pathname.replace('index.html', '')}companion.html`;
                            pairingUrlElement.textContent = companionUrl;
                        }
                    } else {
                        console.error('❌ Failed to create session');
                    }
                });
            });

            socket.on('disconnect', () => {
                console.log('🔌 Disconnected from WebSocket server');
                mobileConnected = false;

                // Restore pairing code display
                const pairingCodeValue = document.getElementById('pairingCodeValue');
                if (pairingCodeValue && pairingCode) {
                    pairingCodeValue.textContent = pairingCode;
                }
            });

            socket.on('mobile:connected', () => {
                console.log('📱 Mobile device connected');
                mobileConnected = true;

                // Close pairing panel
                const pairingPanel = document.getElementById('pairingPanel');
                if (pairingPanel) {
                    pairingPanel.style.display = 'none';
                }

                // Update pairing code display to show "Connected"
                const pairingCodeValue = document.getElementById('pairingCodeValue');
                if (pairingCodeValue) {
                    pairingCodeValue.textContent = 'CONNECTED';
                }

                // Send initial state to mobile
                sendStateToMobile();
            });

            socket.on('mobile:disconnected', () => {
                console.log('📱 Mobile device disconnected');
                mobileConnected = false;

                // Restore pairing code display
                const pairingCodeValue = document.getElementById('pairingCodeValue');
                if (pairingCodeValue && pairingCode) {
                    pairingCodeValue.textContent = pairingCode;
                }
            });

            socket.on('control-update', (update) => {
                console.log('📱 Received control update from mobile:', update);
                applyMobileUpdates(update);
            });

            socket.on('connect_error', (error) => {
                console.error('❌ WebSocket connection error:', error);
                console.error('Make sure the WebSocket server is running at:', socketUrl);

                // Update pairing code display
                const pairingCodeValue = document.getElementById('pairingCodeValue');
                if (pairingCodeValue) {
                    pairingCodeValue.textContent = 'ERROR';
                }
            });
        }

        // Send current state to mobile
        function sendStateToMobile() {
            if (!socket || !mobileConnected) return;

            const stateSnapshot = {
                settings: {
                    intensity: state.settings.intensity,
                    speed: state.settings.speed,
                    smoothing: state.settings.smoothing,
                    mode: state.settings.mode,
                    theme: state.settings.theme,
                    freqEmphasis: state.settings.freqEmphasis
                },
                imageObjects: state.imageObjects.map((obj, index) => ({
                    isVideo: obj.isVideo || false,
                    src: obj.element ? obj.element.src : '',  // Include media URL for companion
                    transparency: obj.transparency,
                    rotation: obj.rotation,
                    blur: obj.blur,
                    theme: obj.theme,
                    visible: obj.visible !== false // Default to true if not set
                }))
            };

            socket.emit('desktop:state-update', stateSnapshot);
        }

        // Update shared state (called when desktop controls change)
        function updateSharedState(updates) {
            if (!socket || !mobileConnected) return;
            socket.emit('desktop:state-update', updates);
        }

        // Listen for state changes from mobile
        function startListeningForMobileUpdates() {
            // WebSocket listeners are already set up in initializePairing()
            // This function kept for compatibility
        }

        function applyMobileUpdates(updates) {
            // Handle actions
            if (updates.action) {
                switch (updates.action) {
                    case 'addMediaFromCompanion':
                        // Add media from companion device
                        if (updates.mediaUrl) {
                            const imageObject = {
                                element: updates.isVideo ? document.createElement('video') : new Image(),
                                x: window.innerWidth / 2,
                                y: window.innerHeight / 2,
                                width: 300,
                                height: 300,
                                originalWidth: 300,
                                originalHeight: 300,
                                scale: 1.0,
                                rotation: 0,
                                transparency: 1.0,
                                theme: 'none',
                                isVideo: updates.isVideo || false,
                                blur: 0
                            };

                            imageObject.element.src = updates.mediaUrl;

                            if (updates.isVideo) {
                                imageObject.element.loop = true;
                                imageObject.element.muted = true;
                                imageObject.element.play();
                            }

                            state.imageObjects.push(imageObject);
                            console.log('📱 Media added from companion');

                            // Send updated state back to mobile
                            sendStateToMobile();
                        }
                        break;

                    case 'deleteMedia':
                        // Delete media item
                        if (typeof updates.mediaIndex === 'number' && updates.mediaIndex >= 0) {
                            state.imageObjects.splice(updates.mediaIndex, 1);
                            state.selectedImageIndex = -1;
                            console.log('📱 Media deleted from companion');

                            // Send updated state back to mobile
                            sendStateToMobile();
                        }
                        break;

                    case 'updateMedia':
                        // Update media property
                        if (typeof updates.mediaIndex === 'number' && updates.mediaIndex >= 0) {
                            const imageObj = state.imageObjects[updates.mediaIndex];
                            if (imageObj && updates.property) {
                                imageObj[updates.property] = updates.value;
                                console.log(`📱 Media ${updates.property} updated to ${updates.value}`);
                            }
                        }
                        break;
                }
                return;
            }

            // Apply settings updates from mobile
            if (updates.settings) {
                Object.assign(state.settings, updates.settings);

                // Update UI elements to reflect changes
                Object.entries(updates.settings).forEach(([key, value]) => {
                    const slider = document.getElementById(`${key}Slider`);
                    const valueEl = document.getElementById(`${key}Value`);

                    if (slider) slider.value = value;

                    if (valueEl) {
                        if (typeof value === 'number') {
                            valueEl.textContent = value.toFixed(1);
                        } else {
                            valueEl.textContent = value;
                        }
                    }

                    // Handle mode buttons
                    if (key === 'mode') {
                        document.querySelectorAll('.density-option').forEach(opt => {
                            opt.classList.toggle('active', opt.dataset.mode === value);
                        });
                    }

                    // Handle theme selector
                    if (key === 'theme') {
                        const themeSelect = document.getElementById('themeSelect');
                        if (themeSelect && themeSelect.value !== value) {
                            themeSelect.value = value;
                        }
                    }
                });
            }
        }

        // Setup pairing UI event handlers
        function setupPairingUI() {
            // Update the pairing code display when code is received
            // The code is automatically updated by the WebSocket connection handler
        }

        // =====================================================
        // START APPLICATION
        // =====================================================

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        console.log('🌊 Soundscape loaded');
    </script>

    <!-- Unified Control System -->
    <script src="control-system.js"></script>

    <!-- Toast Notification Container -->
    <div id="toastContainer"></div>
</body>
</html>
