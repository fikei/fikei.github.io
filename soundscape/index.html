<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soundscape â€” Audio-Reactive Wave Visualization</title>
    <meta name="description" content="Real-time audio visualization using simplex-noise wave grid that reacts to microphone input">
    <link rel="icon" type="image/png" href="https://cdn.glitch.me/597fe374-3d18-46a5-b99c-ceff1f8ffd79%2Ffavicon.png"/>

    <!-- Space Grotesk Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">

    <!-- Socket.io for WebSocket communication -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', monospace;
            font-size: 10px;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* ===== SVG VISUALIZATION CONTAINER ===== */
        #visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #wave-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-screen h1 {
            font-size: 10px;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #ffffff;
        }

        .loading-screen p {
            display: none;
        }

        .loading-spinner {
            margin-top: 1rem;
            width: 20px;
            height: 20px;
            border: 1px solid #333333;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== STATUS INDICATOR ===== */
        .status-bar {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 20;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #ffffff;
            font-size: 10px;
            display: none;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 1;
            transition: opacity 0.5s ease;
            cursor: auto;
        }

        .status-bar.active {
            display: flex;
        }

        .status-bar.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            background: #ffffff;
            animation: blink 1s step-start infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        /* ===== PAIRING PANEL ===== */
        .pairing-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pairing-content {
            background: #000000;
            border: 1px solid #ffffff;
            padding: 3rem 2rem;
            text-align: center;
            min-width: 350px;
        }

        .pairing-content h3 {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
        }

        .pairing-instruction {
            font-size: 10px;
            color: #999999;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pairing-url {
            font-family: monospace;
            font-size: 12px;
            color: #ffffff;
            margin-bottom: 2rem;
            padding: 0.75rem;
            background: #111111;
            border: 1px solid #333333;
        }

        .pairing-code {
            font-family: monospace;
            font-size: 48px;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: #ffffff;
            margin-bottom: 2rem;
            padding: 1rem;
            border: 2px solid #ffffff;
        }

        .pairing-close {
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.75rem 2rem;
            font-size: 10px;
            font-family: monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.15s ease;
        }

        .pairing-close:hover {
            background: #ffffff;
            color: #000000;
        }

        .pairing-toggle {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 20;
            width: 40px;
            height: 40px;
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: all 0.15s ease;
        }

        .pairing-toggle:hover {
            background: #ffffff;
            transform: scale(1.05);
        }

        .pairing-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        /* ===== SIDEBAR TOGGLE BUTTON ===== */
        .sidebar-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease, right 0.2s ease;
        }

        .sidebar-toggle .caret {
            display: inline-block;
            transition: transform 0.2s ease;
        }

        .sidebar-toggle:hover {
            background: #ffffff;
            color: #000000;
        }

        .sidebar-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .sidebar-toggle.sidebar-is-open {
            right: calc(200px + 1rem); /* Float to left of sidebar */
        }

        .sidebar-toggle.sidebar-is-open .caret {
            transform: rotate(180deg); /* Flip caret to point left */
        }

        /* ===== FULLSCREEN TOGGLE BUTTON ===== */
        .fullscreen-toggle {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease, right 0.2s ease;
        }

        .fullscreen-toggle:hover {
            background: #ffffff;
            color: #000000;
        }

        .fullscreen-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .fullscreen-toggle.sidebar-is-open {
            right: calc(200px + 1rem); /* Float to left of sidebar */
        }

        /* ===== ADD IMAGE BUTTON & DROPDOWN ===== */
        .add-image-button {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            border-radius: 0;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease;
        }

        .add-image-button:hover {
            background: #ffffff;
            color: #000000;
        }

        .add-image-button.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        body.hide-cursor {
            cursor: none !important;
        }

        body.hide-cursor * {
            cursor: none !important;
        }

        .add-image-dropdown {
            position: fixed;
            bottom: 3rem;
            left: 1rem;
            z-index: 100;
            background: #000000;
            border: 1px solid #ffffff;
            display: none;
            min-width: 120px;
        }

        .add-image-dropdown.show {
            display: block;
        }

        .add-image-dropdown-item {
            padding: 0.5rem 1rem;
            font-size: 10px;
            color: #ffffff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background 0.15s ease;
        }

        .add-image-dropdown-item:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== VIDEO POPUP ===== */
        .video-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-popup-content {
            background: #000000;
            border: 1px solid #ffffff;
            padding: 2rem;
            min-width: 300px;
            max-width: 500px;
        }

        .video-popup-content h3 {
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 1.5rem;
        }

        .video-popup-content input[type="text"] {
            width: 100%;
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.75rem;
            font-size: 10px;
            font-family: monospace;
            margin-bottom: 1.5rem;
            outline: none;
        }

        .video-popup-content input[type="text"]:focus {
            border-color: #999999;
        }

        .video-popup-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .video-popup-buttons button {
            background: #000000;
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 0.5rem 1.5rem;
            font-size: 10px;
            font-family: monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.15s ease;
        }

        .video-popup-buttons button:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== CONTROLS SIDEBAR ===== */
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100vh;
            background: #000000;
            border-left: 1px solid #ffffff;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            overflow-y: auto;
            padding: 1rem;
            cursor: auto;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar h2 {
            font-size: 10px;
            margin-bottom: 2rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
            border-top: 1px solid #333333;
            padding-top: 1rem;
        }

        .control-section h3 {
            font-size: 10px;
            font-weight: 400;
            margin-bottom: 1rem;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 10px;
            color: #999999;
        }

        .control-value {
            color: #ffffff;
            font-weight: 400;
        }

        /* Range Sliders */
        input[type="range"] {
            width: 100%;
            height: 1px;
            background: #333333;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #000000;
        }

        input[type="range"]::-moz-range-thumb {
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        /* Checkboxes */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 10px;
            color: #999999;
        }

        input[type="checkbox"] {
            width: 12px;
            height: 12px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid #ffffff;
            background: #000000;
        }

        input[type="checkbox"]:checked {
            background: #ffffff;
        }

        input[type="checkbox"]:hover {
            border-color: #999999;
        }

        /* Gradient Presets Grid */
        .gradient-grid {
            display: none;
        }

        /* Grid Density Controls */
        .density-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .density-option {
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .density-option:hover {
            border-color: #ffffff;
        }

        .density-option.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
        }

        /* Theme Dropdown */
        .theme-select {
            width: 100%;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            color: #ffffff;
            font-size: 10px;
            font-family: 'Space Grotesk', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }

        .theme-select:hover {
            border-color: #ffffff;
        }

        .theme-select:focus {
            outline: none;
            border-color: #ffffff;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.5rem;
            font-size: 10px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-reset {
            background: #000000;
            border: 1px solid #ffffff;
            color: white;
            margin-top: 1.5rem;
        }

        .btn-reset:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== ERROR SCREEN ===== */
        .error-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 2rem;
            background: #000000;
            border: 1px solid #ffffff;
            text-align: center;
            max-width: 300px;
            display: none;
        }

        .error-screen.show {
            display: block;
        }

        .error-screen h2 {
            color: #ffffff;
            margin-bottom: 1rem;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .error-screen p {
            color: #999999;
            line-height: 1.4;
            font-size: 10px;
        }

        /* ===== SCROLLBAR STYLING ===== */
        .sidebar::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #000000;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #333333;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #ffffff;
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- SVG Visualization Container -->
    <div id="visualization-container">
        <svg id="wave-svg" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Neon glow filter -->
                <filter id="neon-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur1"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur2"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur3"/>
                    <feMerge>
                        <feMergeNode in="blur3"/>
                        <feMergeNode in="blur2"/>
                        <feMergeNode in="blur1"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        </svg>
        <!-- Canvas for theme images -->
        <canvas id="theme-canvas" style="display: none; position: absolute; cursor: grab;"></canvas>
        <!-- Upload overlay (GLITCH only) -->
        <div id="upload-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10; cursor: pointer; align-items: center; justify-content: center;">
            <div style="text-align: center;">
                <p id="upload-text" style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload Image...</p>
            </div>
        </div>
        <!-- Drag overlay for GLITCH theme -->
        <div id="drag-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 15; pointer-events: none; align-items: center; justify-content: center; border: 3px dashed #ffffff; box-sizing: border-box;">
            <div style="text-align: center;">
                <p style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload</p>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1>SOUNDSCAPE</h1>
        <div class="loading-spinner"></div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
        <div class="status-indicator"></div>
        <span>activ</span>
    </div>

    <!-- Pairing Code Display -->
    <div class="pairing-panel" id="pairingPanel" style="display: none;">
        <div class="pairing-content">
            <h3>MOBILE CONTROL</h3>
            <p class="pairing-instruction">Open on mobile:</p>
            <p class="pairing-url" id="pairingUrl">Loading...</p>
            <p class="pairing-instruction">Enter code:</p>
            <div class="pairing-code" id="pairingCode">------</div>
            <button class="pairing-close" id="pairingClose">CLOSE</button>
        </div>
    </div>

    <!-- Pairing Toggle Button -->
    <button class="pairing-toggle" id="pairingToggle" aria-label="Mobile control">ðŸ“±</button>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle controls"><span class="caret">â€º</span></button>

    <!-- Fullscreen Toggle -->
    <button class="fullscreen-toggle" id="fullscreenToggle" aria-label="Toggle fullscreen">â›¶</button>

    <!-- Add Image Button & Dropdown -->
    <button class="add-image-button" id="addImageButton" aria-label="Add image">+</button>
    <div class="add-image-dropdown" id="addImageDropdown">
        <div class="add-image-dropdown-item" id="addImageMenuItem">Add Image</div>
        <div class="add-image-dropdown-item" id="addVideoMenuItem">Add Video</div>
        <div class="add-image-dropdown-item" id="saveCanvasMenuItem" style="display: none;">Save Canvas</div>
        <div class="add-image-dropdown-item" id="loadCanvasMenuItem" style="display: none;">Load Canvas</div>
    </div>

    <!-- Video URL Popup -->
    <div class="video-popup" id="videoPopup" style="display: none;">
        <div class="video-popup-content">
            <h3>ADD VIDEO BY URL</h3>
            <input type="text" id="videoUrlInput" placeholder="Enter video URL" />
            <div class="video-popup-buttons">
                <button id="videoPopupAdd">ADD</button>
                <button id="videoPopupCancel">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs for canvas load -->
    <input type="file" id="loadCanvasInput" accept=".json" style="display: none;">

    <!-- Controls Sidebar -->
    <aside class="sidebar" id="sidebar">
        <h2>CTRL</h2>

        <!-- Image Controls (visible when image is selected) -->
        <section class="control-section" id="imageControlsSection" style="display: none;">
            <h3>EFFECT</h3>
            <select class="theme-select" id="imageThemeSelect">
                <option value="none">NONE</option>
                <option value="linear">LINEAR</option>
                <option value="neon">NEON</option>
                <option value="glitch">GLITCH</option>
            </select>

            <h3 style="margin-top: 2rem;">IMAGE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>TRANSPARENCY</span>
                    <span class="control-value" id="imageTransparencyValue">1.0</span>
                </div>
                <input type="range" id="imageTransparencySlider" min="0" max="1" step="0.05" value="1">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>ROTATION</span>
                    <span class="control-value" id="imageRotationValue">0</span>
                </div>
                <input type="range" id="imageRotationSlider" min="0" max="360" step="1" value="0">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>BLUR</span>
                    <span class="control-value" id="imageBlurValue">0</span>
                </div>
                <input type="range" id="imageBlurSlider" min="0" max="20" step="0.5" value="0">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>3D MOTION</span>
                    <span class="control-value" id="image3DMotionValue">0.0</span>
                </div>
                <input type="range" id="image3DMotionSlider" min="0" max="2" step="0.1" value="0">
            </div>

            <h3 style="margin-top: 2rem;">FLASH EFFECT</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQUENCY FLASH</span>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="flashFrequencyCheck">
                    <span>Enable</span>
                </label>
            </div>
            <div class="control-group" id="flashFrequencySliderGroup" style="display: none;">
                <div class="control-label">
                    <span>FREQ THRESHOLD</span>
                    <span class="control-value" id="flashFrequencyValue">0.5</span>
                </div>
                <input type="range" id="flashFrequencySlider" min="0" max="1" step="0.05" value="0.5">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>VOLUME FLASH</span>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="flashVolumeCheck">
                    <span>Enable</span>
                </label>
            </div>
            <div class="control-group" id="flashVolumeSliderGroup" style="display: none;">
                <div class="control-label">
                    <span>VOL THRESHOLD</span>
                    <span class="control-value" id="flashVolumeValue">0.5</span>
                </div>
                <input type="range" id="flashVolumeSlider" min="0" max="1" step="0.05" value="0.5">
            </div>

            <!-- Video Controls (visible only for videos) -->
            <div id="videoControlsSection" style="display: none;">
                <h3 style="margin-top: 2rem;">VIDEO</h3>
                <div class="control-group">
                    <div class="control-label">
                        <span>LOOP</span>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="videoLoopCheck">
                        <span>Enable</span>
                    </label>
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>TRIM START</span>
                        <span class="control-value" id="videoTrimStartValue">0.0s</span>
                    </div>
                    <input type="range" id="videoTrimStartSlider" min="0" max="100" step="0.1" value="0">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>TRIM END</span>
                        <span class="control-value" id="videoTrimEndValue">0.0s</span>
                    </div>
                    <input type="range" id="videoTrimEndSlider" min="0" max="100" step="0.1" value="100">
                </div>
            </div>

            <div id="imageEffectSettings">
                <h3 style="margin-top: 2rem;">EFFECT SETTINGS</h3>
                <div class="control-group">
                <div class="control-label">
                    <span>THEME OPACITY</span>
                    <span class="control-value" id="themeOpacityValue">1.0</span>
                </div>
                <input type="range" id="themeOpacitySlider" min="0" max="1" step="0.05" value="1">
            </div>

            <!-- Frequency Emphasis (for image theme) -->
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ LOW</span>
                    <span class="control-value" id="imageLowValue">1.0</span>
                </div>
                <input type="range" id="imageLowEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ MID</span>
                    <span class="control-value" id="imageMidValue">1.0</span>
                </div>
                <input type="range" id="imageMidEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>FREQ HIGH</span>
                    <span class="control-value" id="imageHighValue">1.0</span>
                </div>
                <input type="range" id="imageHighEmphasis" min="0" max="3" step="0.1" value="1">
            </div>

            <!-- Wave Settings (for image theme) -->
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE INTENSITY</span>
                    <span class="control-value" id="imageIntensityValue">2.5</span>
                </div>
                <input type="range" id="imageIntensitySlider" min="0" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE SPEED</span>
                    <span class="control-value" id="imageSpeedValue">1.0</span>
                </div>
                <input type="range" id="imageSpeedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WAVE SMOOTHING</span>
                    <span class="control-value" id="imageSmoothingValue">0.3</span>
                </div>
                <input type="range" id="imageSmoothingSlider" min="0" max="1" step="0.1" value="0.3">
            </div>

                <!-- Density (for image theme) -->
                <div class="control-label" style="margin-top: 1rem;">
                    <span>DENSITY</span>
                </div>
                <div class="density-options">
                    <div class="density-option" data-image-density="low">L</div>
                    <div class="density-option active" data-image-density="medium">M</div>
                    <div class="density-option" data-image-density="high">H</div>
                </div>
            </div>
        </section>

        <!-- Background Controls (visible when no image selected) -->
        <section class="control-section" id="backgroundControlsSection">
            <h3>BACKGROUND THEME</h3>
            <select class="theme-select" id="themeSelect">
                <option value="linear">LINEAR</option>
                <option value="neon">NEON</option>
                <option value="glitch">GLITCH</option>
                <option value="stars">STARS</option>
            </select>
        </section>

        <!-- Mode Selection (LINEAR theme only) -->
        <section class="control-section" id="modeSection">
            <h3>MODE</h3>
            <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                <div class="density-option active" data-mode="default">FLOW</div>
                <div class="density-option" data-mode="hole">HOLE</div>
                <div class="density-option" data-mode="crunch">CRUNCH</div>
            </div>
        </section>

        <!-- NEON Theme Controls -->
        <section class="control-section" id="neonControlsSection" style="display: none;">
            <h3>NEON</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>COLOR MODE</span>
                </div>
                <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="density-option active" data-neon-mode="bright">BRIGHT</div>
                    <div class="density-option" data-neon-mode="gray">GRAY</div>
                    <div class="density-option" data-neon-mode="pastel">PASTEL</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>WARM/COOL</span>
                    <span class="control-value" id="colorTempValue">1.0</span>
                </div>
                <input type="range" id="colorTempSlider" min="0" max="2.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- GLITCH Theme Controls -->
        <section class="control-section" id="glitchControlsSection" style="display: none;">
            <h3>GLITCH</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>MODE</span>
                </div>
                <div class="density-options" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="density-option active" data-glitch-mode="rgb">RGB</div>
                    <div class="density-option" data-glitch-mode="br">B&R</div>
                    <div class="density-option" data-glitch-mode="gray">GRAY</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>ROTATION</span>
                    <span class="control-value" id="rotationIntensityValue">1.0</span>
                </div>
                <input type="range" id="rotationIntensitySlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>GLITCH</span>
                    <span class="control-value" id="glitchIntensityValue">1.0</span>
                </div>
                <input type="range" id="glitchIntensitySlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>CONTRAST</span>
                    <span class="control-value" id="glitchContrastValue">1.0</span>
                </div>
                <input type="range" id="glitchContrastSlider" min="0" max="3.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- STARS Theme Controls -->
        <section class="control-section" id="starsControlsSection" style="display: none;">
            <h3>STARS</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>COLOR HUE</span>
                    <span class="control-value" id="starHueValue">217Â°</span>
                </div>
                <input type="range" id="starHueSlider" min="0" max="360" step="1" value="217">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SATURATION</span>
                    <span class="control-value" id="starSaturationValue">61%</span>
                </div>
                <input type="range" id="starSaturationSlider" min="0" max="100" step="1" value="61">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>BASE SPEED</span>
                    <span class="control-value" id="starSpeedValue">1.0</span>
                </div>
                <input type="range" id="starSpeedSlider" min="0" max="5.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- Frequency Emphasis -->
        <section class="control-section">
            <h3>FREQ</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>LOW</span>
                    <span class="control-value" id="lowValue">1.0</span>
                </div>
                <input type="range" id="lowEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>MID</span>
                    <span class="control-value" id="midValue">1.0</span>
                </div>
                <input type="range" id="midEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>HIGH</span>
                    <span class="control-value" id="highValue">1.0</span>
                </div>
                <input type="range" id="highEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
        </section>

        <!-- Wave Settings -->
        <section class="control-section">
            <h3>WAVE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>INTENSITY</span>
                    <span class="control-value" id="intensityValue">2.5</span>
                </div>
                <input type="range" id="intensitySlider" min="0" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SPEED</span>
                    <span class="control-value" id="speedValue">1.0</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SMOOTHING</span>
                    <span class="control-value" id="smoothingValue">0.5</span>
                </div>
                <input type="range" id="smoothingSlider" min="0" max="1" step="0.1" value="0.5">
            </div>
        </section>

        <!-- Grid Density -->
        <section class="control-section">
            <h3>DENSITY</h3>
            <div class="density-options">
                <div class="density-option" data-density="low">L</div>
                <div class="density-option active" data-density="medium">M</div>
                <div class="density-option" data-density="high">H</div>
            </div>
        </section>

        <!-- Reset Button -->
        <button class="btn btn-reset" id="resetBtn">RESET</button>
    </aside>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <h2>MIC ACCESS REQUIRED</h2>
        <p>Allow microphone permissions and reload</p>
    </div>

    <script>
        // =====================================================
        // SOUNDSCAPE: Audio-Reactive Wave Visualization
        // =====================================================

        // Simple 2D noise function (Perlin-like)
        function createNoise2D() {
            const permutation = [];
            for (let i = 0; i < 256; i++) permutation[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
            }
            const p = [...permutation, ...permutation];

            const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return function(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = fade(x);
                const v = fade(y);
                const a = p[X] + Y;
                const b = p[X + 1] + Y;
                return lerp(v,
                    lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                    lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1))
                );
            };
        }

        // ===== DOM ELEMENTS =====
        const elements = {
            svg: document.getElementById('wave-svg'),
            container: document.getElementById('visualization-container'),
            loading: document.getElementById('loadingScreen'),
            sidebar: document.getElementById('sidebar'),
            sidebarToggle: document.getElementById('sidebarToggle'),
            statusBar: document.getElementById('statusBar'),
            error: document.getElementById('errorScreen')
        };

        // ===== CONFIGURATION =====
        const config = {
            // Audio settings
            fftSize: 128, // Reduced from 256 for lower latency
            smoothing: 0.5, // Default smoothing value

            // Grid settings
            densityPresets: {
                low: { xGap: 20, yGap: 20 },
                medium: { xGap: 12, yGap: 12 },
                high: { xGap: 8, yGap: 8 }
            },

            // Wave physics
            waveAmplitude: 12,
            cursorInfluence: 0.00035,
            cursorRadius: 175,
            damping: 0.95,
            restoration: 0.01,

            // Color gradients (grayscale only)
            gradients: {
                default: { colors: ['#ffffff', '#999999'], bg: '#000000' }
            },

            // Theme configurations
            themes: {
                linear: {
                    colors: ['#ffffff', '#999999'],
                    bg: '#000000',
                    opacity: 0.6,
                    opacityMultiplier: 0.4 // Dynamic opacity range
                },
                neon: {
                    blurBase: 3,
                    blurMultiplier: 20,
                    saturationBase: 85,
                    saturationMultiplier: 15,
                    lightnessBase: 55,
                    lightnessRange: 35, // Will range from (55-35) to (55+35) = 20-90%
                    bg: '#000000',
                    opacity: 0.9,
                    baseHues: [180, 300, 60, 120, 340], // cyan, magenta, yellow, lime, pink
                    sizeMultiplierBase: 1.0,
                    sizeMultiplierRange: 1.5, // Will multiply size by 1.0-2.5x
                    movementBase: 150,
                    movementMultiplier: 300
                },
                glitch: {
                    bg: '#000000',
                    opacity: 0.85,
                    colors: ['#FF0000', '#00FFFF', '#FF00FF', '#00FF00'], // R, C, M, G
                    channelSeparationBase: 2,
                    channelSeparationMultiplier: 12, // Bass increases RGB separation
                    glitchIntensityMultiplier: 8, // Mids control random displacement
                    quantizationBase: 1,
                    quantizationMultiplier: 8 // Highs increase pixelation
                },
                stars: {
                    bg: '#000000',
                    opacity: 1.0,
                    maxStars: 1200,
                    hue: 217, // Base color hue (0-360)
                    brightness: 0.8, // Overall star brightness (0-1)
                    baseSpeed: 0.00002, // Base orbit speed
                    speedMultiplier: 3.0, // Audio-reactive speed boost
                    twinkleIntensity: 20, // How often stars twinkle (higher = less frequent)
                    alphaMin: 0.2, // Minimum alpha for stars
                    alphaMax: 1.0 // Maximum alpha for stars
                }
            }
        };

        // ===== STATE =====
        const state = {
            // User settings
            settings: {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.5,
                density: 'medium',
                gradient: 'default',
                mode: 'default',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0,
                glitchContrast: 1.0,
                glitchMode: 'rgb',
                neonMode: 'bright',
                colorTemp: 1.0,
                image3DMotion: 0.0,  // 3D motion intensity for image objects (0 = off)
                starHue: 217,  // Star base color hue (0-360)
                starSaturation: 61,  // Star color saturation (0-100%)
                starSpeed: 1.0  // Star base speed multiplier (0-5)
            },

            // Audio
            audioContext: null,
            analyser: null,
            microphone: null,
            dataArray: null,
            bufferLength: 0,
            isActive: false,

            // Wave grid
            paths: [],
            lines: [],
            noise: null,
            boundingRect: null,
            transitioning: false,
            transitionProgress: 1.0,

            // Mouse tracking
            mouse: {
                x: -10,
                y: 0,
                lx: 0,
                ly: 0,
                sx: 0,
                sy: 0,
                v: 0,
                vs: 0,
                a: 0,
                set: false,
                onScreen: false
            },

            // Control visibility
            controlsVisible: true,
            idleTimeout: null,

            // Audio levels (for theme renderers)
            audioLevels: {
                low: 0,
                mid: 0,
                high: 0
            },
            currentTime: 0,

            // User-created gradient centers (for NEON theme)
            userGradientCenters: [],

            // GLITCH theme image state (for background replacement)
            glitchImage: {
                img: null,
                loaded: false,
                width: 400,
                height: 300,
                x: 0,
                y: 0,
                rotation3D: { x: 0, y: 0, z: 0 },
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragStartWidth: 0,
                dragStartHeight: 0
            },

            // STARS theme state
            stars: {
                initialized: false,
                starArray: [],
                gradientCanvas: null,
                gradientCtx: null,
                count: 0
            },

            // Image objects (for LINEAR/NEON overlay images)
            imageObjects: [],
            selectedImageIndex: -1
        };

        // =====================================================
        // INITIALIZATION
        // =====================================================

        async function init() {
            console.log('ðŸŽ¨ Initializing Soundscape...');

            // Initialize noise generator
            state.noise = createNoise2D();

            // Setup wave grid
            setupWaveGrid();

            // Setup all controls
            setupControls();

            // Auto-start audio capture
            await startAudioCapture();

            // Initialize mobile companion pairing
            initializePairing();
            setupPairingUI();
            startListeningForMobileUpdates();
        }

        // =====================================================
        // WAVE GRID SETUP
        // =====================================================

        function setupWaveGrid() {
            // Store old grid for transition
            const oldLines = state.lines.length > 0 ? state.lines.map(line =>
                line.map(p => ({ x: p.x, y: p.y }))
            ) : null;

            // Get container dimensions
            state.boundingRect = elements.container.getBoundingClientRect();
            const { width, height } = state.boundingRect;

            // Set SVG dimensions
            elements.svg.style.width = `${width}px`;
            elements.svg.style.height = `${height}px`;
            elements.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Get density settings
            const density = config.densityPresets[state.settings.density];
            const { xGap, yGap } = density;

            // Calculate grid dimensions - oversized to hide edges
            const padding = 400; // Increased padding to ensure edges are never visible
            const oWidth = width + padding;
            const oHeight = height + padding;
            const totalLines = Math.ceil(oWidth / xGap);
            const totalPoints = Math.ceil(oHeight / yGap);
            const xStart = (width - xGap * totalLines) / 2;
            const yStart = (height - yGap * totalPoints) / 2;

            console.log(`ðŸ“Š Creating ${totalLines} lines with ${totalPoints} points each`);

            // Check if we need to rebuild or just transition
            const needsRebuild = state.lines.length !== totalLines ||
                                (state.lines.length > 0 && state.lines[0].length !== totalPoints);

            if (needsRebuild) {
                // Clear existing grid
                state.paths.forEach(path => path.remove());
                state.paths = [];
                state.lines = [];

                // Create grid lines
                for (let i = 0; i < totalLines; i++) {
                    const points = [];

                    // Create points for this line
                    for (let j = 0; j < totalPoints; j++) {
                        const targetX = xStart + xGap * i;
                        const targetY = yStart + yGap * j;

                        // Try to find nearest old point for smooth transition
                        let startX = targetX;
                        let startY = targetY;

                        if (oldLines && oldLines.length > 0) {
                            const oldLineIndex = Math.min(i, oldLines.length - 1);
                            const oldLine = oldLines[oldLineIndex];
                            if (oldLine && oldLine.length > 0) {
                                const oldPointIndex = Math.min(j, oldLine.length - 1);
                                startX = oldLine[oldPointIndex].x;
                                startY = oldLine[oldPointIndex].y;
                            }
                        }

                        points.push({
                            x: startX,
                            y: startY,
                            targetX: targetX,
                            targetY: targetY,
                            wave: { x: 0, y: 0 },
                            cursor: { x: 0, y: 0, vx: 0, vy: 0 },
                            audio: { x: 0, y: 0 }
                        });
                    }

                    // Create SVG path
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-width', '1');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('opacity', '0.6');
                    elements.svg.appendChild(path);

                    state.paths.push(path);
                    state.lines.push(points);
                }

                // Start transition if we had an old grid
                if (oldLines) {
                    state.transitioning = true;
                    state.transitionProgress = 0.0;
                }
            } else {
                // Just update target positions
                for (let i = 0; i < totalLines; i++) {
                    for (let j = 0; j < totalPoints; j++) {
                        const p = state.lines[i][j];
                        p.targetX = xStart + xGap * i;
                        p.targetY = yStart + yGap * j;
                    }
                }

                state.transitioning = true;
                state.transitionProgress = 0.0;
            }

            // Apply colors
            updateColors();
        }

        function updateModeVisibility() {
            const backgroundControlsSection = document.getElementById('backgroundControlsSection');
            const modeSection = document.getElementById('modeSection');
            const neonControlsSection = document.getElementById('neonControlsSection');
            const glitchControlsSection = document.getElementById('glitchControlsSection');
            const starsControlsSection = document.getElementById('starsControlsSection');
            const imageControlsSection = document.getElementById('imageControlsSection');
            const imageThemeSelect = document.getElementById('imageThemeSelect');
            const uploadOverlay = document.getElementById('upload-overlay');

            const hasSelectedImage = state.selectedImageIndex !== -1 && state.imageObjects[state.selectedImageIndex];

            // Show background controls when no image is selected
            if (backgroundControlsSection) {
                backgroundControlsSection.style.display = hasSelectedImage ? 'none' : 'block';
            }

            // Show/hide theme-specific background controls
            if (modeSection) {
                modeSection.style.display = !hasSelectedImage && state.settings.theme === 'linear' ? 'block' : 'none';
            }

            if (neonControlsSection) {
                neonControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'neon' ? 'block' : 'none';
            }

            if (glitchControlsSection) {
                glitchControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'glitch' ? 'block' : 'none';
            }

            if (starsControlsSection) {
                starsControlsSection.style.display = !hasSelectedImage && state.settings.theme === 'stars' ? 'block' : 'none';
            }

            // Show image controls when an image is selected
            if (imageControlsSection) {
                imageControlsSection.style.display = hasSelectedImage ? 'block' : 'none';

                // Update image controls to match selected image's properties
                if (hasSelectedImage) {
                    const imageObj = state.imageObjects[state.selectedImageIndex];

                    // Update all sliders and their value displays
                    if (imageThemeSelect) {
                        imageThemeSelect.value = imageObj.theme;

                        // Hide/show effect settings based on theme
                        const effectSettings = document.getElementById('imageEffectSettings');
                        if (effectSettings) {
                            effectSettings.style.display = imageObj.theme === 'none' ? 'none' : 'block';
                        }
                    }

                    const updateSlider = (sliderId, valueId, value, decimals = 2) => {
                        const slider = document.getElementById(sliderId);
                        const valueEl = document.getElementById(valueId);
                        if (slider) slider.value = value;
                        if (valueEl) valueEl.textContent = decimals === 0 ? value : value.toFixed(decimals);
                    };

                    updateSlider('imageTransparencySlider', 'imageTransparencyValue', imageObj.transparency, 2);
                    updateSlider('imageRotationSlider', 'imageRotationValue', imageObj.rotation, 0);
                    updateSlider('imageBlurSlider', 'imageBlurValue', imageObj.blur, 1);
                    updateSlider('themeOpacitySlider', 'themeOpacityValue', imageObj.themeOpacity, 2);

                    // Update flash effect controls
                    const flashFreqCheck = document.getElementById('flashFrequencyCheck');
                    const flashVolCheck = document.getElementById('flashVolumeCheck');
                    const flashFreqGroup = document.getElementById('flashFrequencySliderGroup');
                    const flashVolGroup = document.getElementById('flashVolumeSliderGroup');

                    if (flashFreqCheck) flashFreqCheck.checked = imageObj.flashFrequencyEnabled || false;
                    if (flashVolCheck) flashVolCheck.checked = imageObj.flashVolumeEnabled || false;
                    if (flashFreqGroup) flashFreqGroup.style.display = imageObj.flashFrequencyEnabled ? 'block' : 'none';
                    if (flashVolGroup) flashVolGroup.style.display = imageObj.flashVolumeEnabled ? 'block' : 'none';

                    updateSlider('flashFrequencySlider', 'flashFrequencyValue', imageObj.flashFrequencyThreshold || 0.5, 2);
                    updateSlider('flashVolumeSlider', 'flashVolumeValue', imageObj.flashVolumeThreshold || 0.5, 2);

                    // Update video controls if this is a video object
                    const videoControlsSection = document.getElementById('videoControlsSection');
                    if (videoControlsSection) {
                        if (imageObj.isVideo) {
                            videoControlsSection.style.display = 'block';

                            // Update loop checkbox
                            const videoLoopCheck = document.getElementById('videoLoopCheck');
                            if (videoLoopCheck) videoLoopCheck.checked = imageObj.loop || false;

                            // Update trim sliders
                            const trimStartSlider = document.getElementById('videoTrimStartSlider');
                            const trimEndSlider = document.getElementById('videoTrimEndSlider');
                            const trimStartValue = document.getElementById('videoTrimStartValue');
                            const trimEndValue = document.getElementById('videoTrimEndValue');

                            if (imageObj.duration) {
                                if (trimStartSlider) {
                                    trimStartSlider.max = imageObj.duration;
                                    trimStartSlider.value = imageObj.trimStart || 0;
                                }
                                if (trimEndSlider) {
                                    trimEndSlider.max = imageObj.duration;
                                    trimEndSlider.value = imageObj.trimEnd || imageObj.duration;
                                }
                                if (trimStartValue) trimStartValue.textContent = `${(imageObj.trimStart || 0).toFixed(1)}s`;
                                if (trimEndValue) trimEndValue.textContent = `${(imageObj.trimEnd || imageObj.duration).toFixed(1)}s`;
                            }
                        } else {
                            videoControlsSection.style.display = 'none';
                        }
                    }
                }
            }

            if (uploadOverlay) {
                // Show upload overlay for GLITCH theme only when no image is loaded
                const shouldShowOverlay = state.settings.theme === 'glitch' && !state.glitchImage.loaded;
                uploadOverlay.style.display = shouldShowOverlay ? 'flex' : 'none';
            }
        }

        function updateColors() {
            const theme = config.themes[state.settings.theme];

            // Update background
            document.body.style.background = theme.bg;

            // Update mode visibility based on theme
            updateModeVisibility();

            // Handle stars canvas visibility
            const starsCanvas = document.getElementById('stars-canvas');
            if (starsCanvas) {
                starsCanvas.style.display = state.settings.theme === 'stars' ? 'block' : 'none';
            }

            // Update line colors based on theme
            if (state.settings.theme === 'linear') {
                // Linear uses gradient colors
                state.paths.forEach((path, i) => {
                    const progress = i / state.paths.length;
                    const colorIndex = Math.floor(progress * theme.colors.length);
                    const color = theme.colors[Math.min(colorIndex, theme.colors.length - 1)];
                    path.setAttribute('stroke', color);
                    path.removeAttribute('filter');
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'neon') {
                // Neon theme colors are set dynamically in drawLinesNeon
                // Just ensure paths are ready
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'glitch') {
                // Glitch theme colors are set dynamically in drawLinesGlitch
                // Reset path attributes
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'stars') {
                // Stars theme: hide SVG paths (stars are rendered on canvas)
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', '0');
                });
            }
        }

        // =====================================================
        // AUDIO CAPTURE
        // =====================================================

        async function startAudioCapture() {
            try {
                console.log('ðŸŽ¤ Requesting microphone access...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Setup audio context
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.microphone = state.audioContext.createMediaStreamSource(stream);

                // Configure analyser
                state.analyser.fftSize = config.fftSize;
                state.analyser.smoothingTimeConstant = state.settings.smoothing;
                state.bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(state.bufferLength);

                // Connect audio graph
                state.microphone.connect(state.analyser);

                // Update UI
                state.isActive = true;
                elements.loading.classList.add('hidden');
                elements.statusBar.classList.add('active');

                console.log('âœ… Audio capture started');
                console.log('ðŸŽ¤ Analyser config:', {
                    fftSize: state.analyser.fftSize,
                    bufferLength: state.bufferLength,
                    smoothing: state.analyser.smoothingTimeConstant
                });

                // Start idle timeout for controls
                showControls();

                // Start animation loop
                requestAnimationFrame(animate);

            } catch (err) {
                console.error('âŒ Microphone access denied:', err);
                elements.loading.classList.add('hidden');
                elements.error.classList.add('show');
            }
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate(time = 0) {
            if (!state.isActive) return;

            // Update mouse smoothing
            updateMouse();

            // Move all points
            movePoints(time);

            // Draw all lines
            drawLines();

            // Continue loop
            requestAnimationFrame(animate);
        }

        function updateMouse() {
            const m = state.mouse;

            // Smooth mouse position
            m.sx += (m.x - m.sx) * 0.1;
            m.sy += (m.y - m.sy) * 0.1;

            // Calculate velocity
            const dx = m.x - m.lx;
            const dy = m.y - m.ly;
            const distance = Math.hypot(dx, dy);

            m.v = distance;
            m.vs += (distance - m.vs) * 0.1;
            m.vs = Math.min(100, m.vs);

            // Store last position
            m.lx = m.x;
            m.ly = m.y;

            // Calculate angle
            m.a = Math.atan2(dy, dx);
        }

        function movePoints(time) {
            // Store time for theme renderers
            state.currentTime = time;

            // Handle grid transition animation
            if (state.transitioning) {
                state.transitionProgress += 0.05; // Smooth transition speed
                if (state.transitionProgress >= 1.0) {
                    state.transitionProgress = 1.0;
                    state.transitioning = false;
                }

                // Interpolate all points to their target positions
                const easeProgress = easeInOutCubic(state.transitionProgress);
                state.lines.forEach((points) => {
                    points.forEach((p) => {
                        if (p.targetX !== undefined && p.targetY !== undefined) {
                            p.x += (p.targetX - p.x) * easeProgress * 0.2;
                            p.y += (p.targetY - p.y) * easeProgress * 0.2;
                        }
                    });
                });
            }

            // Get audio frequency data
            let lowSum = 0, midSum = 0, highSum = 0;

            if (state.analyser) {
                state.analyser.getByteFrequencyData(state.dataArray);

                for (let i = 0; i < state.bufferLength; i++) {
                    const value = state.dataArray[i];
                    if (i < state.bufferLength * 0.3) lowSum += value;
                    else if (i < state.bufferLength * 0.7) midSum += value;
                    else highSum += value;
                }
            }

            // Calculate frequency levels with emphasis
            const lowLevel = (lowSum / (state.bufferLength * 0.3) / 255) * state.settings.lowEmphasis;
            const midLevel = (midSum / (state.bufferLength * 0.4) / 255) * state.settings.midEmphasis;
            const highLevel = (highSum / (state.bufferLength * 0.3) / 255) * state.settings.highEmphasis;

            // Store audio levels for theme renderers
            state.audioLevels.low = lowLevel;
            state.audioLevels.mid = midLevel;
            state.audioLevels.high = highLevel;

            // Debug logging (every 60 frames ~= 1 second)
            if (Math.random() < 0.016) {
                console.log('ðŸŽµ Audio Levels:', {
                    low: lowLevel.toFixed(3),
                    mid: midLevel.toFixed(3),
                    high: highLevel.toFixed(3),
                    lowSum,
                    midSum,
                    highSum
                });
            }

            // Bass creates global background shift - more dramatic
            const bassShiftX = Math.sin(time * 0.001) * lowLevel * 60 * state.settings.intensity;
            const bassShiftY = Math.cos(time * 0.0015) * lowLevel * 50 * state.settings.intensity;

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // MODE-DEPENDENT BEHAVIOR
            let midCursorX, midCursorY, highCursorX, highCursorY;

            if (state.settings.mode === 'hole' || state.settings.mode === 'default') {
                // HOLE/DEFAULT MODE: Follow cursor if on screen, random if not
                if (state.mouse.onScreen) {
                    midCursorX = state.mouse.sx;
                    midCursorY = state.mouse.sy;
                    highCursorX = state.mouse.sx;
                    highCursorY = state.mouse.sy;
                } else {
                    // Random virtual cursor positions
                    midCursorX = canvasWidth * 0.3 + Math.sin(time * 0.002) * midLevel * 200;
                    midCursorY = canvasHeight * 0.5 + Math.cos(time * 0.003) * midLevel * 150;

                    highCursorX = canvasWidth * 0.7 + Math.sin(time * 0.0025) * highLevel * 250;
                    highCursorY = canvasHeight * 0.5 + Math.cos(time * 0.002) * highLevel * 200;
                }
            }

            // CRUNCH MODE: Calculate wave front positions
            const crunchMidAngle = time * 0.0008 + state.noise(time * 0.0002, 0) * Math.PI * 2;
            const crunchHighAngle = time * 0.001 + state.noise(time * 0.0003, 100) * Math.PI * 2;
            const crunchMidOffset = Math.sin(time * 0.0005) * canvasWidth * 0.5;
            const crunchHighOffset = Math.sin(time * 0.0007) * canvasWidth * 0.5;

            // Update all points
            state.lines.forEach((points) => {
                points.forEach((p) => {
                    // 1. Base wave motion (simplex noise)
                    const timeScale = time * 0.008 * state.settings.speed;
                    const noiseValue = state.noise(
                        (p.x + timeScale) * 0.003,
                        (p.y + timeScale * 0.375) * 0.002
                    ) * 8;

                    p.wave.x = Math.cos(noiseValue) * config.waveAmplitude + bassShiftX;
                    p.wave.y = Math.sin(noiseValue) * (config.waveAmplitude * 0.5) + bassShiftY;

                    let midForceX = 0;
                    let midForceY = 0;
                    let highForceX = 0;
                    let highForceY = 0;

                    if (state.settings.mode === 'hole') {
                        // HOLE MODE: Radial ripples from cursor position
                        // 2. Mids create ripple effect - MORE DRAMATIC
                        const midDx = p.x - midCursorX;
                        const midDy = p.y - midCursorY;
                        const midDist = Math.hypot(midDx, midDy);
                        const midRadius = 400 * midLevel;

                        if (midDist < midRadius && midDist > 0) {
                            const midStrength = (1 - midDist / midRadius) * midLevel;
                            const angle = Math.atan2(midDy, midDx);
                            midForceX = Math.cos(angle) * midStrength * 120 * state.settings.intensity;
                            midForceY = Math.sin(angle) * midStrength * 120 * state.settings.intensity;
                        }

                        // 3. Highs create sharper ripple effect - MORE DRAMATIC
                        const highDx = p.x - highCursorX;
                        const highDy = p.y - highCursorY;
                        const highDist = Math.hypot(highDx, highDy);
                        const highRadius = 250 * highLevel;

                        if (highDist < highRadius && highDist > 0) {
                            const highStrength = (1 - highDist / highRadius) * highLevel;
                            const angle = Math.atan2(highDy, highDx);
                            highForceX = Math.cos(angle) * highStrength * 150 * state.settings.intensity;
                            highForceY = Math.sin(angle) * highStrength * 150 * state.settings.intensity;
                        }
                    } else if (state.settings.mode === 'default') {
                        // DEFAULT MODE: No audio-reactive burst/hole effect
                        // Forces remain 0
                    } else {
                        // CRUNCH MODE: Directional wave sweep across screen - MORE DRAMATIC
                        // Calculate distance from wave front for mids
                        const midWaveX = Math.cos(crunchMidAngle);
                        const midWaveY = Math.sin(crunchMidAngle);
                        const midDistFromFront = (p.x - canvasWidth * 0.5) * midWaveX + (p.y - canvasHeight * 0.5) * midWaveY + crunchMidOffset;
                        const midWaveWidth = 500;

                        if (Math.abs(midDistFromFront) < midWaveWidth) {
                            const midStrength = (1 - Math.abs(midDistFromFront) / midWaveWidth) * midLevel;
                            const perpAngle = crunchMidAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.01, p.y * 0.01 + time * 0.001) > 0 ? 1 : -1;
                            midForceX = Math.cos(perpAngle) * midStrength * 180 * state.settings.intensity * waveDir;
                            midForceY = Math.sin(perpAngle) * midStrength * 180 * state.settings.intensity * waveDir;
                        }

                        // Calculate distance from wave front for highs
                        const highWaveX = Math.cos(crunchHighAngle);
                        const highWaveY = Math.sin(crunchHighAngle);
                        const highDistFromFront = (p.x - canvasWidth * 0.5) * highWaveX + (p.y - canvasHeight * 0.5) * highWaveY + crunchHighOffset;
                        const highWaveWidth = 400;

                        if (Math.abs(highDistFromFront) < highWaveWidth) {
                            const highStrength = (1 - Math.abs(highDistFromFront) / highWaveWidth) * highLevel;
                            const perpAngle = crunchHighAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.015, p.y * 0.015 + time * 0.0015) > 0 ? 1 : -1;
                            highForceX = Math.cos(perpAngle) * highStrength * 220 * state.settings.intensity * waveDir;
                            highForceY = Math.sin(perpAngle) * highStrength * 220 * state.settings.intensity * waveDir;
                        }
                    }

                    // Combine audio forces
                    p.audio.x = midForceX + highForceX;
                    p.audio.y = midForceY + highForceY;

                    // 4. Mouse interaction
                    const dx = p.x - state.mouse.sx;
                    const dy = p.y - state.mouse.sy;
                    const distance = Math.hypot(dx, dy);
                    const influenceRadius = Math.max(config.cursorRadius, state.mouse.vs);

                    if (distance < influenceRadius) {
                        const strength = 1 - distance / influenceRadius;
                        const force = Math.cos(distance * 0.001) * strength;

                        p.cursor.vx += Math.cos(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                        p.cursor.vy += Math.sin(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                    }

                    // Apply physics
                    p.cursor.vx += (0 - p.cursor.x) * config.restoration;
                    p.cursor.vy += (0 - p.cursor.y) * config.restoration;
                    p.cursor.vx *= config.damping;
                    p.cursor.vy *= config.damping;

                    p.cursor.x += p.cursor.vx;
                    p.cursor.y += p.cursor.vy;

                    // Limit displacement
                    p.cursor.x = Math.min(50, Math.max(-50, p.cursor.x));
                    p.cursor.y = Math.min(50, Math.max(-50, p.cursor.y));
                });
            });
        }

        // =====================================================
        // THEME RENDERERS
        // =====================================================

        function drawLinesLinear() {
            const theme = config.themes.linear;
            const { low, mid, high } = state.audioLevels;

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Calculate overall audio energy for dramatic effect
            const totalEnergy = (low + mid + high) / 3;
            const dynamicOpacity = theme.opacity + totalEnergy * theme.opacityMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                // Start path
                const firstPoint = points[0];
                let pathData = `M ${
                    firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x
                } ${
                    firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y
                }`;

                // Draw line segments
                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = p.x + p.wave.x + p.cursor.x + p.audio.x;
                    const y = p.y + p.wave.y + p.cursor.y + p.audio.y;
                    pathData += ` L ${x} ${y}`;
                }

                // Update path with dynamic opacity
                const path = state.paths[lineIndex];
                path.setAttribute('d', pathData);
                path.removeAttribute('filter');
                path.removeAttribute('transform');
                path.setAttribute('opacity', Math.min(1.0, dynamicOpacity));
            });
        }

        function drawLinesNeon() {
            const theme = config.themes.neon;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Hide all line paths for NEON theme
            state.paths.forEach(path => {
                path.setAttribute('d', '');
                path.setAttribute('opacity', '0');
            });

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // Always render gradient mesh background
            // Get or create gradient mesh container
            let gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (!gradientMeshGroup) {
                gradientMeshGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gradientMeshGroup.setAttribute('id', 'neon-gradient-mesh');
                elements.svg.appendChild(gradientMeshGroup);
            }

            // Get color mode settings
            const colorMode = state.settings.neonMode;
            const colorTempIntensity = state.settings.colorTemp;

            // Calculate audio-reactive parameters
            const hueShift = (mid * 360 + time * 0.05) % 360;

            // Saturation mapping: high frequencies = less saturated, low frequencies = more saturated
            const baseSaturation = theme.saturationBase + high * theme.saturationMultiplier;
            const saturationFromLow = low * 30; // Bass increases saturation
            const saturationFromHigh = -high * 20; // Highs decrease saturation
            const saturation = Math.max(0, Math.min(100, baseSaturation + saturationFromLow + saturationFromHigh));

            // Lightness: Low frequencies darken, high frequencies brighten
            // Range from 20% (dark) to 90% (bright)
            const lightnessFromLow = -low * theme.lightnessRange * 0.5; // Darken with bass
            const lightnessFromHigh = high * theme.lightnessRange * 0.7; // Brighten with highs
            const lightness = theme.lightnessBase + lightnessFromLow + lightnessFromHigh;

            // Movement: More dramatic with bass
            const movementAmplitude = theme.movementBase + low * theme.movementMultiplier;

            // Size: Dramatic pulsing with all frequencies combined
            const combinedEnergy = (low * 0.5 + mid * 0.3 + high * 0.2);
            const sizeMultiplier = theme.sizeMultiplierBase + combinedEnergy * theme.sizeMultiplierRange;

            // Debug logging for NEON renderer (every ~1 second)
            if (Math.random() < 0.016) {
                console.log('ðŸŽ¨ NEON Render:', {
                    audioLevels: { low, mid, high },
                    hueShift: hueShift.toFixed(1),
                    saturation: saturation.toFixed(1),
                    lightness: lightness.toFixed(1),
                    movementAmplitude: movementAmplitude.toFixed(1),
                    sizeMultiplier: sizeMultiplier.toFixed(2)
                });
            }

            // Create multiple gradient centers for organic look
            const numBaseCenters = theme.baseHues.length;
            const numUserCenters = state.userGradientCenters.length;

            // Get or create gradient definitions in defs
            let defsElement = elements.svg.querySelector('defs');
            if (!defsElement) {
                defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                elements.svg.insertBefore(defsElement, elements.svg.firstChild);
            }

            // Clear and recreate gradient mesh
            gradientMeshGroup.innerHTML = '';

            // Render base gradient centers
            for (let i = 0; i < numBaseCenters; i++) {
                // Calculate organic position using noise
                const noiseX = state.noise(time * 0.0005 + i * 10, i * 20) * movementAmplitude;
                const noiseY = state.noise(time * 0.0007 + i * 15, i * 25 + 100) * movementAmplitude;

                // Base position distributed around the screen
                const baseX = canvasWidth * (0.2 + (i / numBaseCenters) * 0.6);
                const baseY = canvasHeight * (0.3 + Math.sin(i * 2) * 0.4);

                const cx = baseX + noiseX;
                const cy = baseY + noiseY;

                // Calculate size based on audio and position
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.6;
                const radius = baseRadius * sizeMultiplier * state.settings.burstSize;

                // Create radial gradient for this center
                const gradientId = `neon-radial-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Calculate hue for this center based on color mode
                let hue, finalSaturation, finalLightness;

                if (colorMode === 'gray') {
                    // Grayscale mode: no hue, zero saturation, full lightness range
                    hue = 0;
                    finalSaturation = 0;
                    // Expand lightness range for grayscale: 0% (black) to 100% (white)
                    finalLightness = Math.max(0, Math.min(100, lightness));
                } else if (colorMode === 'pastel') {
                    // Pastel mode: Map warm colors to highs, cool colors to lows
                    // Cool (blue/cyan): 180-240, Warm (red/orange/yellow): 0-60
                    const frequencyBalance = (high - low) * colorTempIntensity; // -1 to 1 range
                    // Map: -1 (low/cool) = 210 (cyan-blue), +1 (high/warm) = 30 (orange-red)
                    const frequencyHue = 120 - frequencyBalance * 90; // 210 to 30
                    const baseHue = theme.baseHues[i];
                    hue = ((frequencyHue + baseHue * 0.3 + hueShift * 0.5) % 360);

                    // Pastel colors: higher saturation but softer
                    finalSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                    finalLightness = Math.max(60, Math.min(85, lightness + 10)); // Lighter for pastel
                } else {
                    // Bright mode (default): Original vibrant colors
                    const baseHue = theme.baseHues[i];
                    hue = (baseHue + hueShift) % 360;
                    finalSaturation = saturation;
                    finalLightness = lightness;
                }

                // Create gradient stops for smooth fade
                const stops = [
                    { offset: '0%', opacity: 0.8 },
                    { offset: '40%', opacity: 0.6 },
                    { offset: '70%', opacity: 0.3 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${hue}, ${finalSaturation}%, ${finalLightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Render user-created gradient centers
            for (let i = 0; i < numUserCenters; i++) {
                const userCenter = state.userGradientCenters[i];
                const cx = userCenter.x;
                const cy = userCenter.y;

                // Calculate size - larger for user centers to make them more prominent
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.5;
                const radius = baseRadius * sizeMultiplier * 1.2 * state.settings.burstSize; // 20% larger + burst size

                // Create radial gradient for this user center
                const gradientId = `neon-user-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Calculate hue for user center based on color mode
                let userHue, userSaturation, userLightness;

                if (colorMode === 'gray') {
                    // Grayscale mode: full lightness range
                    userHue = 0;
                    userSaturation = 0;
                    userLightness = Math.max(0, Math.min(100, lightness));
                } else if (colorMode === 'pastel') {
                    // Pastel mode with frequency mapping
                    const frequencyBalance = (high - low) * colorTempIntensity;
                    const frequencyHue = 120 - frequencyBalance * 90;
                    const baseHue = theme.baseHues[i % theme.baseHues.length];
                    userHue = ((frequencyHue + baseHue * 0.3 + hueShift * 0.5 + 45) % 360);
                    userSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                    userLightness = Math.max(60, Math.min(85, lightness + 10));
                } else {
                    // Bright mode
                    userHue = (theme.baseHues[i % theme.baseHues.length] + hueShift + 45) % 360;
                    userSaturation = saturation;
                    userLightness = lightness;
                }

                // Create gradient stops with higher initial opacity for user centers
                const stops = [
                    { offset: '0%', opacity: 0.95 },
                    { offset: '30%', opacity: 0.75 },
                    { offset: '60%', opacity: 0.4 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${userHue}, ${userSaturation}%, ${userLightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Update glow filter based on bass
            const blurRadius = theme.blurBase + low * theme.blurMultiplier;
            const filter = elements.svg.querySelector('#neon-glow');
            if (filter) {
                const blur1 = filter.querySelector('feGaussianBlur[result="blur1"]');
                const blur2 = filter.querySelector('feGaussianBlur[result="blur2"]');
                const blur3 = filter.querySelector('feGaussianBlur[result="blur3"]');

                if (blur1) blur1.setAttribute('stdDeviation', blurRadius * 0.5);
                if (blur2) blur2.setAttribute('stdDeviation', blurRadius);
                if (blur3) blur3.setAttribute('stdDeviation', blurRadius * 1.5);

                // Debug blur values
                if (Math.random() < 0.016) {
                    console.log('âœ¨ Blur Filter:', {
                        low,
                        blurRadius: blurRadius.toFixed(2),
                        blur1: (blurRadius * 0.5).toFixed(2),
                        blur2: blurRadius.toFixed(2),
                        blur3: (blurRadius * 1.5).toFixed(2)
                    });
                }
            }
        }

        function renderNeonImage(canvas, theme, low, mid, high, time, canvasWidth, canvasHeight, img, themeBlur = 0, themeOpacity = 1.0) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw base image
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Get color mode settings
            const colorMode = state.settings.neonMode;
            const colorTempIntensity = state.settings.colorTemp;

            // Calculate audio-reactive parameters
            const hueShift = (mid * 360 + time * 0.05) % 360;

            // Saturation mapping
            const baseSaturation = theme.saturationBase + high * theme.saturationMultiplier;
            const saturationFromLow = low * 30;
            const saturationFromHigh = -high * 20;
            const saturation = Math.max(0, Math.min(100, baseSaturation + saturationFromLow + saturationFromHigh));

            // Lightness
            const lightnessFromLow = -low * theme.lightnessRange * 0.5;
            const lightnessFromHigh = high * theme.lightnessRange * 0.7;
            const lightness = theme.lightnessBase + lightnessFromLow + lightnessFromHigh;

            // Blur based on bass
            const blurRadius = theme.blurBase + low * theme.blurMultiplier;

            // Apply gradient overlay effect
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
            );

            // Calculate color based on mode
            let hue, finalSaturation, finalLightness;

            if (colorMode === 'gray') {
                hue = 0;
                finalSaturation = 0;
                // Expand lightness range for grayscale: 0% (black) to 100% (white)
                finalLightness = Math.max(0, Math.min(100, lightness));
            } else if (colorMode === 'pastel') {
                const frequencyBalance = (high - low) * colorTempIntensity;
                const frequencyHue = 120 - frequencyBalance * 90;
                hue = ((frequencyHue + hueShift * 0.5) % 360);
                finalSaturation = Math.max(40, Math.min(70, saturation * 0.7));
                finalLightness = Math.max(60, Math.min(85, lightness + 10));
            } else {
                // Bright mode
                hue = (180 + hueShift) % 360; // Cyan base
                finalSaturation = saturation;
                finalLightness = lightness;
            }

            // Create gradient stops (apply theme opacity)
            gradient.addColorStop(0, `hsla(${hue}, ${finalSaturation}%, ${finalLightness}%, ${0.6 * themeOpacity})`);
            gradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, ${finalSaturation}%, ${finalLightness}%, ${0.3 * themeOpacity})`);
            gradient.addColorStop(1, `hsla(${(hue + 120) % 360}, ${finalSaturation}%, ${finalLightness}%, 0)`);

            // Apply gradient overlay with blend mode
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = themeOpacity;
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            // Apply blur filter if supported
            if (blurRadius > 0) {
                ctx.filter = `blur(${blurRadius}px)`;
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        function drawLinesGlitch() {
            const theme = config.themes.glitch;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Hide all line paths for GLITCH theme (show black background)
            state.paths.forEach((path) => {
                path.setAttribute('d', '');
            });

            // If an image is loaded, render it with glitch effect
            if (state.glitchImage.loaded && state.glitchImage.img) {
                const canvas = document.getElementById('theme-canvas');
                if (canvas) {
                    canvas.style.display = 'block';

                    // Set canvas size to fill entire container
                    canvas.width = state.boundingRect.width;
                    canvas.height = state.boundingRect.height;
                    canvas.style.width = state.boundingRect.width + 'px';
                    canvas.style.height = state.boundingRect.height + 'px';
                    canvas.style.left = '0px';
                    canvas.style.top = '0px';

                    renderGlitchImageBackground(
                        canvas,
                        theme,
                        low,
                        mid,
                        high,
                        time,
                        state.glitchImage.img
                    );
                }
            } else {
                // Hide canvas when no image is loaded
                const canvas = document.getElementById('theme-canvas');
                if (canvas) {
                    canvas.style.display = 'none';
                }
            }
        }

        function renderGlitchImageBackground(canvas, theme, low, mid, high, time, img) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Calculate glitch parameters with user intensity multipliers
            const glitchEffectIntensity = state.settings.glitchEffectIntensity;
            const channelSeparation = (theme.channelSeparationBase + low * theme.channelSeparationMultiplier) * glitchEffectIntensity;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier * glitchEffectIntensity;
            const quantization = Math.max(1, (theme.quantizationBase + high * theme.quantizationMultiplier) * glitchEffectIntensity);

            // Calculate 3D rotation based on audio with user intensity multiplier
            const rotationIntensity = state.settings.rotationIntensity;
            const rotationX = mid * 45 * rotationIntensity;
            const rotationY = high * 45 * rotationIntensity;
            const rotationZ = low * 15 * rotationIntensity;

            // Apply 3D transform to canvas
            const perspective = 1000;
            canvas.style.transformStyle = 'preserve-3d';
            canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply quantization/pixelation by scaling down and up
            const pixelSize = Math.max(1, Math.floor(quantization));
            const scaledWidth = Math.floor(canvas.width / pixelSize);
            const scaledHeight = Math.floor(canvas.height / pixelSize);

            // Create temporary canvas for RGB channel separation
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Use stored image dimensions and position from state.glitchImage
            const drawWidth = state.glitchImage.width;
            const drawHeight = state.glitchImage.height;
            const drawX = state.glitchImage.x;
            const drawY = state.glitchImage.y;

            // Draw pixelated base image with user-defined size
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            tempCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight, drawX, drawY, drawWidth, drawHeight);

            // Get image data for RGB channel manipulation
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply glitch effects (scanlines, blocks, etc) - same as renderGlitchImage
            const scanlineGlitchChance = mid * 0.3 * glitchEffectIntensity;
            for (let y = 0; y < canvas.height; y++) {
                if (Math.random() < scanlineGlitchChance) {
                    const offset = Math.floor((Math.random() - 0.5) * glitchIntensity * 30);
                    if (offset !== 0) {
                        const rowStart = y * canvas.width * 4;
                        const rowData = data.slice(rowStart, rowStart + canvas.width * 4);

                        for (let x = 0; x < canvas.width; x++) {
                            const sourceX = Math.max(0, Math.min(canvas.width - 1, x - offset));
                            const sourceIdx = sourceX * 4;
                            const targetIdx = rowStart + x * 4;

                            data[targetIdx] = rowData[sourceIdx];
                            data[targetIdx + 1] = rowData[sourceIdx + 1];
                            data[targetIdx + 2] = rowData[sourceIdx + 2];
                            data[targetIdx + 3] = rowData[sourceIdx + 3];
                        }
                    }
                }
            }

            // Add random block corruption
            const blockGlitchChance = low * 0.15 * glitchEffectIntensity;
            const numBlocks = Math.floor(low * 10 * glitchEffectIntensity);
            for (let b = 0; b < numBlocks; b++) {
                if (Math.random() < blockGlitchChance) {
                    const blockX = Math.floor(Math.random() * canvas.width);
                    const blockY = Math.floor(Math.random() * canvas.height);
                    const blockWidth = Math.floor(Math.random() * glitchIntensity * 40 + 10);
                    const blockHeight = Math.floor(Math.random() * glitchIntensity * 20 + 5);
                    const glitchType = Math.random();

                    for (let y = blockY; y < Math.min(blockY + blockHeight, canvas.height); y++) {
                        for (let x = blockX; x < Math.min(blockX + blockWidth, canvas.width); x++) {
                            const idx = (y * canvas.width + x) * 4;

                            if (glitchType < 0.33) {
                                data[idx] = 255 - data[idx];
                                data[idx + 1] = 255 - data[idx + 1];
                                data[idx + 2] = 255 - data[idx + 2];
                            } else if (glitchType < 0.66) {
                                const temp = data[idx];
                                data[idx] = data[idx + 2];
                                data[idx + 2] = temp;
                            }
                        }
                    }
                }
            }

            // Put modified image data back
            tempCtx.putImageData(imageData, 0, 0);

            // RGB Channel Separation
            const glitchMode = state.settings.glitchMode || 'rgb';
            const redCanvas = document.createElement('canvas');
            const greenCanvas = document.createElement('canvas');
            const blueCanvas = document.createElement('canvas');

            redCanvas.width = greenCanvas.width = blueCanvas.width = canvas.width;
            redCanvas.height = greenCanvas.height = blueCanvas.height = canvas.height;

            const redCtx = redCanvas.getContext('2d');
            const greenCtx = greenCanvas.getContext('2d');
            const blueCtx = blueCanvas.getContext('2d');

            const redData = ctx.createImageData(canvas.width, canvas.height);
            const greenData = ctx.createImageData(canvas.width, canvas.height);
            const blueData = ctx.createImageData(canvas.width, canvas.height);

            for (let i = 0; i < data.length; i += 4) {
                if (glitchMode === 'rgb') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = 0;
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                } else if (glitchMode === 'br') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = 0;
                    blueData.data[i + 3] = 0;
                } else if (glitchMode === 'gray') {
                    redData.data[i] = data[i];
                    redData.data[i + 1] = data[i + 1];
                    redData.data[i + 2] = data[i + 2];
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = data[i];
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = data[i];
                    blueData.data[i + 1] = data[i + 1];
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                }
            }

            redCtx.putImageData(redData, 0, 0);
            greenCtx.putImageData(greenData, 0, 0);
            blueCtx.putImageData(blueData, 0, 0);

            // Composite the channels with separation
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'lighter';

            // Apply contrast filter
            const contrast = state.settings.glitchContrast;
            ctx.filter = `contrast(${contrast})`;

            ctx.drawImage(redCanvas, -channelSeparation, 0);
            ctx.drawImage(greenCanvas, 0, 0);
            ctx.drawImage(blueCanvas, channelSeparation, 0);

            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';
        }

        function renderGlitchImage(canvas, theme, low, mid, high, time, img, themeBlur = 0, themeOpacity = 1.0, baseRotation = 0) {
            const ctx = canvas.getContext('2d');

            if (!img) return;

            // Calculate glitch parameters with user intensity multipliers
            const glitchEffectIntensity = state.settings.glitchEffectIntensity;
            const channelSeparation = (theme.channelSeparationBase + low * theme.channelSeparationMultiplier) * glitchEffectIntensity;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier * glitchEffectIntensity;
            const quantization = Math.max(1, (theme.quantizationBase + high * theme.quantizationMultiplier) * glitchEffectIntensity);

            // Calculate 3D rotation based on audio with user intensity multiplier
            // Use image3DMotion setting for image objects
            const motionIntensity = state.settings.image3DMotion;
            const rotationX = mid * 45 * motionIntensity; // Mids control pitch (X-axis rotation)
            const rotationY = high * 45 * motionIntensity; // Highs control yaw (Y-axis rotation)
            const rotationZ = low * 15 * motionIntensity + baseRotation; // Bass controls roll (Z-axis rotation) + user rotation

            // Apply 3D transform to canvas
            const perspective = 1000;
            canvas.style.transformStyle = 'preserve-3d';
            canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply quantization/pixelation by scaling down and up
            const pixelSize = Math.max(1, Math.floor(quantization));
            const scaledWidth = Math.floor(canvas.width / pixelSize);
            const scaledHeight = Math.floor(canvas.height / pixelSize);

            // Create temporary canvas for RGB channel separation
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw pixelated base image
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            tempCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight, 0, 0, canvas.width, canvas.height);

            // Get image data for RGB channel manipulation
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply random glitch displacement to scan lines (controlled by mids)
            const scanlineGlitchChance = mid * 0.3 * glitchEffectIntensity;
            for (let y = 0; y < canvas.height; y++) {
                if (Math.random() < scanlineGlitchChance) {
                    const offset = Math.floor((Math.random() - 0.5) * glitchIntensity * 30);
                    if (offset !== 0) {
                        const rowStart = y * canvas.width * 4;
                        const rowData = data.slice(rowStart, rowStart + canvas.width * 4);

                        for (let x = 0; x < canvas.width; x++) {
                            const sourceX = Math.max(0, Math.min(canvas.width - 1, x - offset));
                            const sourceIdx = sourceX * 4;
                            const targetIdx = rowStart + x * 4;

                            data[targetIdx] = rowData[sourceIdx];
                            data[targetIdx + 1] = rowData[sourceIdx + 1];
                            data[targetIdx + 2] = rowData[sourceIdx + 2];
                            data[targetIdx + 3] = rowData[sourceIdx + 3];
                        }
                    }
                }
            }

            // Add random block corruption based on bass (creates chunky glitches)
            const blockGlitchChance = low * 0.15 * glitchEffectIntensity;
            const numBlocks = Math.floor(low * 10 * glitchEffectIntensity);
            for (let b = 0; b < numBlocks; b++) {
                if (Math.random() < blockGlitchChance) {
                    const blockX = Math.floor(Math.random() * canvas.width);
                    const blockY = Math.floor(Math.random() * canvas.height);
                    const blockWidth = Math.floor(Math.random() * glitchIntensity * 40 + 10);
                    const blockHeight = Math.floor(Math.random() * glitchIntensity * 20 + 5);

                    // Random glitch type
                    const glitchType = Math.random();

                    for (let y = blockY; y < Math.min(blockY + blockHeight, canvas.height); y++) {
                        for (let x = blockX; x < Math.min(blockX + blockWidth, canvas.width); x++) {
                            const idx = (y * canvas.width + x) * 4;

                            if (glitchType < 0.33) {
                                // Color inversion
                                data[idx] = 255 - data[idx];
                                data[idx + 1] = 255 - data[idx + 1];
                                data[idx + 2] = 255 - data[idx + 2];
                            } else if (glitchType < 0.66) {
                                // Channel swap
                                const temp = data[idx];
                                data[idx] = data[idx + 2];
                                data[idx + 2] = temp;
                            } else {
                                // Random shift within block
                                const shiftX = Math.floor((Math.random() - 0.5) * 20);
                                const sourceX = Math.max(0, Math.min(canvas.width - 1, x + shiftX));
                                const sourceIdx = (y * canvas.width + sourceX) * 4;
                                data[idx] = data[sourceIdx];
                                data[idx + 1] = data[sourceIdx + 1];
                                data[idx + 2] = data[sourceIdx + 2];
                            }
                        }
                    }
                }
            }

            // Add vertical tears based on highs (sudden glitch lines)
            const tearChance = high * 0.2 * glitchEffectIntensity;
            const numTears = Math.floor(high * 5 * glitchEffectIntensity);
            for (let t = 0; t < numTears; t++) {
                if (Math.random() < tearChance) {
                    const tearX = Math.floor(Math.random() * canvas.width);
                    const tearWidth = Math.floor(Math.random() * 5 + 1);
                    const tearOffset = Math.floor((Math.random() - 0.5) * glitchIntensity * 15);

                    for (let y = 0; y < canvas.height; y++) {
                        for (let dx = 0; dx < tearWidth; dx++) {
                            const x = tearX + dx;
                            if (x >= 0 && x < canvas.width) {
                                const sourceY = Math.max(0, Math.min(canvas.height - 1, y + tearOffset));
                                const targetIdx = (y * canvas.width + x) * 4;
                                const sourceIdx = (sourceY * canvas.width + x) * 4;

                                data[targetIdx] = data[sourceIdx];
                                data[targetIdx + 1] = data[sourceIdx + 1];
                                data[targetIdx + 2] = data[sourceIdx + 2];
                                data[targetIdx + 3] = data[sourceIdx + 3];
                            }
                        }
                    }
                }
            }

            // Get glitch mode
            const glitchMode = state.settings.glitchMode;

            // Apply grayscale conversion if in GRAY mode
            if (glitchMode === 'gray') {
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
            }

            // Create canvases for channel separation
            const redCanvas = document.createElement('canvas');
            redCanvas.width = canvas.width;
            redCanvas.height = canvas.height;
            const redCtx = redCanvas.getContext('2d');

            const greenCanvas = document.createElement('canvas');
            greenCanvas.width = canvas.width;
            greenCanvas.height = canvas.height;
            const greenCtx = greenCanvas.getContext('2d');

            const blueCanvas = document.createElement('canvas');
            blueCanvas.width = canvas.width;
            blueCanvas.height = canvas.height;
            const blueCtx = blueCanvas.getContext('2d');

            // Extract individual color channels based on mode
            const redData = ctx.createImageData(canvas.width, canvas.height);
            const greenData = ctx.createImageData(canvas.width, canvas.height);
            const blueData = ctx.createImageData(canvas.width, canvas.height);

            for (let i = 0; i < data.length; i += 4) {
                if (glitchMode === 'rgb') {
                    // RGB mode: Full RGB separation
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = 0;
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                } else if (glitchMode === 'br') {
                    // B&R mode: Red and Cyan (like 3D glasses)
                    redData.data[i] = data[i];
                    redData.data[i + 1] = 0;
                    redData.data[i + 2] = 0;
                    redData.data[i + 3] = data[i + 3];

                    // Cyan channel (green + blue)
                    greenData.data[i] = 0;
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    // Blue stays empty for B&R mode
                    blueData.data[i] = 0;
                    blueData.data[i + 1] = 0;
                    blueData.data[i + 2] = 0;
                    blueData.data[i + 3] = 0;
                } else if (glitchMode === 'gray') {
                    // Grayscale mode: Use grayscale for all channels
                    redData.data[i] = data[i];
                    redData.data[i + 1] = data[i + 1];
                    redData.data[i + 2] = data[i + 2];
                    redData.data[i + 3] = data[i + 3];

                    greenData.data[i] = data[i];
                    greenData.data[i + 1] = data[i + 1];
                    greenData.data[i + 2] = data[i + 2];
                    greenData.data[i + 3] = data[i + 3];

                    blueData.data[i] = data[i];
                    blueData.data[i + 1] = data[i + 1];
                    blueData.data[i + 2] = data[i + 2];
                    blueData.data[i + 3] = data[i + 3];
                }
            }

            redCtx.putImageData(redData, 0, 0);
            greenCtx.putImageData(greenData, 0, 0);
            blueCtx.putImageData(blueData, 0, 0);

            // Composite the channels with separation and random variations
            const randomOffsetX = (Math.random() - 0.5) * channelSeparation * 0.5;
            const randomOffsetY = (Math.random() - 0.5) * channelSeparation * 0.5;

            // Apply contrast filter
            const contrast = state.settings.glitchContrast;
            ctx.filter = `contrast(${contrast})`;

            if (glitchMode === 'gray') {
                // GRAY mode: Single render to avoid overexposure
                // Apply subtle offset variations for glitch effect
                ctx.globalCompositeOperation = 'source-over';

                const offsetX = (Math.random() - 0.5) * channelSeparation * 0.5 * low;
                const offsetY = (Math.random() - 0.5) * channelSeparation * 0.5 * mid;

                ctx.putImageData(imageData, offsetX, offsetY);
            } else {
                // RGB and B&R modes: Use lighter blend mode for color separation
                ctx.globalCompositeOperation = 'lighter';

                if (glitchMode === 'rgb') {
                    // RGB mode: All three channels with separation
                    // Red channel (offset left with random variation)
                    const redOffsetX = -channelSeparation + randomOffsetX * low * 2;
                    const redOffsetY = randomOffsetY * mid;
                    ctx.drawImage(redCanvas, redOffsetX, redOffsetY);

                    // Green channel (slightly offset with random jitter)
                    const greenOffsetX = (Math.random() - 0.5) * channelSeparation * 0.3 * mid;
                    const greenOffsetY = (Math.random() - 0.5) * channelSeparation * 0.3 * high;
                    ctx.drawImage(greenCanvas, greenOffsetX, greenOffsetY);

                    // Blue channel (offset right and down with variation)
                    const blueOffsetX = channelSeparation + randomOffsetX * high * 2;
                    const blueOffsetY = channelSeparation * 0.5 + randomOffsetY * low;
                    ctx.drawImage(blueCanvas, blueOffsetX, blueOffsetY);
                } else if (glitchMode === 'br') {
                    // B&R mode: Only red and cyan (like 3D glasses)
                    // Red channel (offset left)
                    const redOffsetX = -channelSeparation + randomOffsetX * low * 2;
                    const redOffsetY = randomOffsetY * mid;
                    ctx.drawImage(redCanvas, redOffsetX, redOffsetY);

                    // Cyan channel (offset right) - stored in greenCanvas
                    const cyanOffsetX = channelSeparation + randomOffsetX * high * 2;
                    const cyanOffsetY = randomOffsetY * low;
                    ctx.drawImage(greenCanvas, cyanOffsetX, cyanOffsetY);
                }
            }

            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';
        }

        function renderGlitchLines(theme, low, mid, high) {
            // Calculate glitch parameters
            const channelSeparation = theme.channelSeparationBase + low * theme.channelSeparationMultiplier;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier;
            const quantization = theme.quantizationBase + high * theme.quantizationMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                const path = state.paths[lineIndex];

                // Random glitch displacement per line (controlled by mids)
                const lineGlitch = (Math.random() < mid * 0.3) ? Math.random() * glitchIntensity * 30 : 0;

                // Quantize position (pixelate effect controlled by highs)
                const quantize = (val) => Math.round(val / quantization) * quantization;

                // Build path with quantized positions
                const firstPoint = points[0];
                const fx = quantize(firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x + lineGlitch);
                const fy = quantize(firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y);

                let pathData = `M ${fx} ${fy}`;

                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = quantize(p.x + p.wave.x + p.cursor.x + p.audio.x + lineGlitch);
                    const y = quantize(p.y + p.wave.y + p.cursor.y + p.audio.y);
                    pathData += ` L ${x} ${y}`;
                }

                // RGB Channel Separation - render same path 3 times with color channels offset
                const colorIndex = lineIndex % theme.colors.length;
                const baseColor = theme.colors[colorIndex];

                // Red channel (offset left)
                const pathR = state.paths[lineIndex];
                pathR.setAttribute('d', pathData);
                pathR.setAttribute('stroke', baseColor);
                pathR.setAttribute('opacity', theme.opacity);
                pathR.setAttribute('transform', `translate(${-channelSeparation}, 0)`);
                pathR.removeAttribute('filter');

                // Create or get additional paths for G and B channels
                let pathG = elements.svg.querySelector(`#glitch-g-${lineIndex}`);
                if (!pathG) {
                    pathG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathG.setAttribute('id', `glitch-g-${lineIndex}`);
                    pathG.setAttribute('fill', 'none');
                    pathG.setAttribute('stroke-width', '1');
                    pathG.setAttribute('stroke-linecap', 'round');
                    pathG.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathG);
                }

                let pathB = elements.svg.querySelector(`#glitch-b-${lineIndex}`);
                if (!pathB) {
                    pathB = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathB.setAttribute('id', `glitch-b-${lineIndex}`);
                    pathB.setAttribute('fill', 'none');
                    pathB.setAttribute('stroke-width', '1');
                    pathB.setAttribute('stroke-linecap', 'round');
                    pathB.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathB);
                }

                // Green channel (no offset)
                const greenColor = theme.colors[(colorIndex + 1) % theme.colors.length];
                pathG.setAttribute('d', pathData);
                pathG.setAttribute('stroke', greenColor);
                pathG.setAttribute('opacity', theme.opacity);
                pathG.setAttribute('transform', 'translate(0, 0)');

                // Blue channel (offset right/down)
                const blueColor = theme.colors[(colorIndex + 2) % theme.colors.length];
                pathB.setAttribute('d', pathData);
                pathB.setAttribute('stroke', blueColor);
                pathB.setAttribute('opacity', theme.opacity);
                pathB.setAttribute('transform', `translate(${channelSeparation}, ${channelSeparation * 0.5})`);
            });

            // Clean up extra glitch paths if lines were reduced
            const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
            allGlitchPaths.forEach(path => {
                const match = path.id.match(/glitch-[gb]-(\d+)/);
                if (match && parseInt(match[1]) >= state.lines.length) {
                    path.remove();
                }
            });
        }

        // =====================================================
        // STARS THEME RENDERER
        // =====================================================

        function initializeStars() {
            const theme = config.themes.stars;
            const w = state.boundingRect.width;
            const h = state.boundingRect.height;

            // Create cached gradient texture for stars
            const gradientCanvas = document.createElement('canvas');
            const gradientCtx = gradientCanvas.getContext('2d');
            gradientCanvas.width = 100;
            gradientCanvas.height = 100;

            state.stars.gradientCanvas = gradientCanvas;
            state.stars.gradientCtx = gradientCtx;

            // Update gradient with current hue
            updateStarGradient();

            // Initialize star array
            state.stars.starArray = [];
            state.stars.count = 0;

            const maxOrbit = Math.round(Math.sqrt(w * w + h * h)) / 2;

            class Star {
                constructor() {
                    this.orbitRadius = Math.floor(Math.random() * maxOrbit);
                    this.radius = Math.floor(Math.random() * (60 - this.orbitRadius / 12) + this.orbitRadius / 12);
                    this.orbitX = w / 2;
                    this.orbitY = h / 2;
                    this.timePassed = Math.random() * theme.maxStars;
                    this.baseSpeed = (Math.random() * this.orbitRadius * theme.baseSpeed);
                    this.alpha = (Math.random() * (theme.alphaMax - theme.alphaMin) + theme.alphaMin) * theme.brightness;
                    state.stars.starArray.push(this);
                }
            }

            for (let i = 0; i < theme.maxStars; i++) {
                new Star();
            }

            state.stars.initialized = true;
            console.log(`âœ¨ Initialized ${theme.maxStars} stars`);
        }

        function updateStarGradient() {
            const canvas = state.stars.gradientCanvas;
            const ctx = state.stars.gradientCtx;
            const hue = state.settings.starHue;
            const saturation = state.settings.starSaturation;
            const half = canvas.width / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const gradient = ctx.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0.025, '#fff');
            gradient.addColorStop(0.1, `hsl(${hue}, ${saturation}%, 33%)`);
            gradient.addColorStop(0.25, `hsl(${hue}, ${Math.min(saturation + 3, 100)}%, 6%)`);
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(half, half, half, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawLinesStars() {
            const theme = config.themes.stars;
            const { low, mid, high } = state.audioLevels;

            // Initialize stars on first render
            if (!state.stars.initialized) {
                initializeStars();
            }

            // Get or create stars canvas
            let starsCanvas = document.getElementById('stars-canvas');
            if (!starsCanvas) {
                starsCanvas = document.createElement('canvas');
                starsCanvas.id = 'stars-canvas';
                starsCanvas.style.position = 'fixed';
                starsCanvas.style.top = '0';
                starsCanvas.style.left = '0';
                starsCanvas.style.width = '100%';
                starsCanvas.style.height = '100%';
                starsCanvas.style.pointerEvents = 'none';
                starsCanvas.style.zIndex = '0';
                document.body.insertBefore(starsCanvas, document.body.firstChild);
            }

            const ctx = starsCanvas.getContext('2d');
            const w = starsCanvas.width = state.boundingRect.width;
            const h = starsCanvas.height = state.boundingRect.height;

            // Clear with fade effect
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = theme.bg;
            ctx.fillRect(0, 0, w, h);

            // Calculate audio-reactive speed multiplier
            // Bass increases orbit speed
            const speedBoost = 1.0 + (low * theme.speedMultiplier);

            // Draw stars
            ctx.globalCompositeOperation = 'lighter';

            state.stars.starArray.forEach((star) => {
                const x = Math.sin(star.timePassed) * star.orbitRadius + star.orbitX;
                const y = Math.cos(star.timePassed) * star.orbitRadius + star.orbitY;

                // Twinkle effect
                const twinkle = Math.floor(Math.random() * theme.twinkleIntensity);
                if (twinkle === 1 && star.alpha > theme.alphaMin) {
                    star.alpha -= 0.05;
                } else if (twinkle === 2 && star.alpha < theme.alphaMax * theme.brightness) {
                    star.alpha += 0.05;
                }

                // Mid frequencies add brightness boost
                const brightnessBoost = mid * 0.3;

                ctx.globalAlpha = star.alpha + brightnessBoost;
                ctx.drawImage(
                    state.stars.gradientCanvas,
                    x - star.radius / 2,
                    y - star.radius / 2,
                    star.radius,
                    star.radius
                );

                // Update orbit with audio-reactive speed
                // baseSpeed * user speed multiplier * audio boost
                star.timePassed += star.baseSpeed * state.settings.starSpeed * speedBoost;
            });
        }

        // Theme renderer dispatcher
        const themeRenderers = {
            linear: drawLinesLinear,
            neon: drawLinesNeon,
            glitch: drawLinesGlitch,
            stars: drawLinesStars
        };

        function drawLines() {
            // Render background theme
            const renderer = themeRenderers[state.settings.theme] || drawLinesLinear;
            renderer();

            // Render image objects (for all themes)
            renderImageObjects();
        }

        function renderImageObjects() {
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            state.imageObjects.forEach((imageObj, index) => {
                const canvas = imageObj.canvas;
                const ctx = canvas.getContext('2d');

                // Update canvas size and position
                canvas.width = imageObj.width;
                canvas.height = imageObj.height;
                canvas.style.left = `${imageObj.x}px`;
                canvas.style.top = `${imageObj.y}px`;
                canvas.style.display = 'block';

                // Flash effect logic
                let shouldHideFlash = false;

                if (imageObj.flashFrequencyEnabled) {
                    // Calculate average frequency level (0-1 range)
                    const avgFrequency = (low + mid + high) / 3;
                    if (avgFrequency > imageObj.flashFrequencyThreshold) {
                        shouldHideFlash = true;
                    }
                }

                if (imageObj.flashVolumeEnabled && !shouldHideFlash) {
                    // Use high frequency as volume proxy (0-1 range)
                    const volume = Math.max(low, mid, high);
                    if (volume > imageObj.flashVolumeThreshold) {
                        shouldHideFlash = true;
                    }
                }

                // Apply flash visibility
                if (shouldHideFlash) {
                    canvas.style.display = 'none';
                }

                // Apply transparency
                canvas.style.opacity = imageObj.transparency;

                // Apply rotation and 3D motion
                const motion3D = state.settings.image3DMotion;
                if (imageObj.theme !== 'glitch') {
                    // Non-glitch themes: Apply rotation and optional 3D motion
                    if (motion3D > 0) {
                        // Apply 3D motion based on audio
                        const rotationX = mid * 45 * motion3D; // Mids control pitch (X-axis rotation)
                        const rotationY = high * 45 * motion3D; // Highs control yaw (Y-axis rotation)
                        const rotationZ = low * 15 * motion3D + imageObj.rotation; // Bass controls roll + user rotation
                        const perspective = 1000;
                        canvas.style.transformStyle = 'preserve-3d';
                        canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;
                        canvas.style.transformOrigin = 'center center';
                    } else {
                        // No 3D motion, just apply simple rotation
                        canvas.style.transform = `rotate(${imageObj.rotation}deg)`;
                        canvas.style.transformOrigin = 'center center';
                    }
                }

                // Apply blur filter
                if (imageObj.blur > 0) {
                    canvas.style.filter = `blur(${imageObj.blur}px)`;
                } else {
                    canvas.style.filter = 'none';
                }

                // Add selection outline if selected
                if (index === state.selectedImageIndex) {
                    canvas.style.border = '2px solid #ffffff';
                    canvas.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.5)';
                } else {
                    canvas.style.border = 'none';
                    canvas.style.boxShadow = 'none';
                }

                // Handle video trimming and looping
                if (imageObj.isVideo && imageObj.video) {
                    const video = imageObj.video;
                    video.loop = imageObj.loop || false;

                    // Apply trimming
                    if (video.currentTime < imageObj.trimStart || video.currentTime > imageObj.trimEnd) {
                        video.currentTime = imageObj.trimStart;
                    }

                    // If we reach the trim end, loop back to trim start
                    if (imageObj.loop && video.currentTime >= imageObj.trimEnd) {
                        video.currentTime = imageObj.trimStart;
                    }
                }

                // Get the source (video or image)
                const source = imageObj.isVideo ? imageObj.video : imageObj.img;

                // Render based on image's assigned theme
                if (imageObj.theme === 'none') {
                    // No effect - just draw the plain image/video
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
                } else if (imageObj.theme === 'neon') {
                    renderNeonImage(canvas, config.themes.neon, low, mid, high, time, imageObj.width, imageObj.height, source, imageObj.themeBlur, imageObj.themeOpacity);
                } else if (imageObj.theme === 'glitch') {
                    renderGlitchImage(canvas, config.themes.glitch, low, mid, high, time, source, imageObj.themeBlur, imageObj.themeOpacity, imageObj.rotation);
                } else if (imageObj.theme === 'linear') {
                    // For LINEAR theme on image/video, just draw with some audio-reactive effects
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Apply audio-reactive opacity combined with theme opacity
                    ctx.globalAlpha = (0.8 + (mid * 0.2)) * imageObj.themeOpacity;
                    ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        // =====================================================
        // CONTROL VISIBILITY
        // =====================================================

        function showControls() {
            if (!state.controlsVisible) {
                state.controlsVisible = true;
                elements.statusBar.classList.remove('hidden-control');
                elements.sidebarToggle.classList.remove('hidden-control');

                const fullscreenToggle = document.getElementById('fullscreenToggle');
                if (fullscreenToggle) {
                    fullscreenToggle.classList.remove('hidden-control');
                }

                const addImageBtn = document.getElementById('addImageButton');
                if (addImageBtn) {
                    addImageBtn.classList.remove('hidden-control');
                }

                const pairingToggle = document.getElementById('pairingToggle');
                if (pairingToggle) {
                    pairingToggle.classList.remove('hidden-control');
                }
            }

            // Reset idle timeout
            clearTimeout(state.idleTimeout);
            state.idleTimeout = setTimeout(hideControls, 2000); // Hide after 2 seconds of no movement
        }

        function hideControls() {
            // Don't hide if sidebar is open
            const sidebarOpen = elements.sidebar.classList.contains('open');
            if (sidebarOpen) {
                // Restart the timeout to check again later
                state.idleTimeout = setTimeout(hideControls, 2000);
                return;
            }

            state.controlsVisible = false;
            elements.statusBar.classList.add('hidden-control');
            elements.sidebarToggle.classList.add('hidden-control');

            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle) {
                fullscreenToggle.classList.add('hidden-control');
            }

            const addImageBtn = document.getElementById('addImageButton');
            if (addImageBtn) {
                addImageBtn.classList.add('hidden-control');
            }

            const pairingToggle = document.getElementById('pairingToggle');
            if (pairingToggle) {
                pairingToggle.classList.add('hidden-control');
            }
        }

        // =====================================================
        // SAVE/LOAD STATE
        // =====================================================

        function setupImageInteraction(canvas, imageIndex) {
            canvas.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();

                // Select this image
                state.selectedImageIndex = imageIndex;
                updateModeVisibility(); // Update UI to show image theme selector

                const imageObj = state.imageObjects[imageIndex];
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if clicking near edges for resize (within 20px)
                const edgeThreshold = 20;
                const nearRightEdge = mouseX > canvas.width - edgeThreshold;
                const nearBottomEdge = mouseY > canvas.height - edgeThreshold;

                if (nearRightEdge || nearBottomEdge) {
                    // Start resize
                    imageObj.isResizing = true;
                    imageObj.dragStartX = e.clientX;
                    imageObj.dragStartY = e.clientY;
                    imageObj.dragStartWidth = imageObj.width;
                    imageObj.dragStartHeight = imageObj.height;
                    canvas.style.cursor = 'nwse-resize';
                } else {
                    // Start drag
                    imageObj.isDragging = true;
                    imageObj.dragStartX = e.clientX - imageObj.x;
                    imageObj.dragStartY = e.clientY - imageObj.y;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const imageObj = state.imageObjects[imageIndex];
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Update cursor based on position
                if (!imageObj.isDragging && !imageObj.isResizing) {
                    const edgeThreshold = 20;
                    const nearRightEdge = mouseX > canvas.width - edgeThreshold;
                    const nearBottomEdge = mouseY > canvas.height - edgeThreshold;

                    if (nearRightEdge || nearBottomEdge) {
                        canvas.style.cursor = 'nwse-resize';
                    } else {
                        canvas.style.cursor = 'move';
                    }
                }
            });
        }

        async function saveCanvasState() {
            try {
                // Collect all state data
                const canvasState = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    background: {
                        theme: state.settings.theme,
                        mode: state.settings.mode,
                        glitchMode: state.settings.glitchMode,
                        rotationIntensity: state.settings.rotationIntensity,
                        glitchEffectIntensity: state.settings.glitchEffectIntensity,
                        neonColorMode: state.settings.neonColorMode,
                        neonWarmCool: state.settings.neonWarmCool,
                        neonSatRange: state.settings.neonSatRange,
                        neonBurstSize: state.settings.neonBurstSize
                    },
                    audioSettings: {
                        lowEmphasis: state.settings.lowEmphasis,
                        midEmphasis: state.settings.midEmphasis,
                        highEmphasis: state.settings.highEmphasis
                    },
                    waveSettings: {
                        intensity: state.settings.waveIntensity,
                        speed: state.settings.waveSpeed,
                        smoothing: state.settings.waveSmoothing
                    },
                    density: state.settings.density,
                    imageObjects: []
                };

                // Convert each image object to serializable format
                for (const imageObj of state.imageObjects) {
                    // Convert image to base64
                    const canvas = document.createElement('canvas');
                    canvas.width = imageObj.img.width;
                    canvas.height = imageObj.img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(imageObj.img, 0, 0);
                    const imageData = canvas.toDataURL('image/png');

                    canvasState.imageObjects.push({
                        x: imageObj.x,
                        y: imageObj.y,
                        width: imageObj.width,
                        height: imageObj.height,
                        theme: imageObj.theme,
                        transparency: imageObj.transparency,
                        rotation: imageObj.rotation,
                        blur: imageObj.blur,
                        themeBlur: imageObj.themeBlur,
                        themeOpacity: imageObj.themeOpacity,
                        flashFrequencyEnabled: imageObj.flashFrequencyEnabled,
                        flashFrequencyThreshold: imageObj.flashFrequencyThreshold,
                        flashVolumeEnabled: imageObj.flashVolumeEnabled,
                        flashVolumeThreshold: imageObj.flashVolumeThreshold,
                        imageData: imageData
                    });
                }

                // Convert to JSON and download
                const jsonString = JSON.stringify(canvasState, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `soundscape-${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('âœ… Canvas state saved successfully');
            } catch (error) {
                console.error('âŒ Error saving canvas state:', error);
                alert('Error saving canvas state. Check console for details.');
            }
        }

        function loadCanvasStateFromFile(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const canvasState = JSON.parse(event.target.result);
                    restoreCanvasState(canvasState);
                } catch (error) {
                    console.error('âŒ Error loading canvas state:', error);
                    alert('Error loading canvas state. Check console for details.');
                }
            };
            reader.readAsText(file);
        }

        async function restoreCanvasState(canvasState) {
            try {
                console.log('ðŸ”„ Restoring canvas state...');

                // Clear existing image objects
                state.imageObjects.forEach(obj => {
                    if (obj.canvas && obj.canvas.parentNode) {
                        obj.canvas.parentNode.removeChild(obj.canvas);
                    }
                });
                state.imageObjects = [];
                state.selectedImageIndex = -1;

                // Restore background theme
                state.settings.theme = canvasState.background.theme;
                state.settings.mode = canvasState.background.mode;
                state.settings.glitchMode = canvasState.background.glitchMode || 'rgb';
                state.settings.rotationIntensity = canvasState.background.rotationIntensity || 1.0;
                state.settings.glitchEffectIntensity = canvasState.background.glitchEffectIntensity || 1.0;
                state.settings.neonColorMode = canvasState.background.neonColorMode || 'rainbow';
                state.settings.neonWarmCool = canvasState.background.neonWarmCool || 0.5;
                state.settings.neonSatRange = canvasState.background.neonSatRange || 0.5;

                // Restore audio settings
                state.settings.lowEmphasis = canvasState.audioSettings.lowEmphasis;
                state.settings.midEmphasis = canvasState.audioSettings.midEmphasis;
                state.settings.highEmphasis = canvasState.audioSettings.highEmphasis;

                // Restore wave settings
                state.settings.waveIntensity = canvasState.waveSettings.intensity;
                state.settings.waveSpeed = canvasState.waveSettings.speed;
                state.settings.waveSmoothing = canvasState.waveSettings.smoothing;

                // Restore density
                state.settings.density = canvasState.density;

                // Derive burst size from density
                const densityToBurstSize = {
                    'low': 0.5,
                    'medium': 1.0,
                    'high': 1.5
                };
                state.settings.neonBurstSize = densityToBurstSize[state.settings.density] || 1.0;

                // Restore image objects
                for (const imageObjData of canvasState.imageObjects) {
                    await restoreImageObject(imageObjData);
                }

                // Update UI to reflect loaded state
                updateModeVisibility();
                syncControlsWithState();

                console.log('âœ… Canvas state restored successfully');
            } catch (error) {
                console.error('âŒ Error restoring canvas state:', error);
                alert('Error restoring canvas state. Check console for details.');
            }
        }

        function restoreImageObject(imageObjData) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                canvas.style.position = 'absolute';
                canvas.style.cursor = 'move';
                canvas.style.pointerEvents = 'auto';
                canvas.className = 'image-object-canvas';
                document.getElementById('visualization-container').appendChild(canvas);

                if (imageObjData.imageData) {
                    // Image data exists - load it
                    const img = new Image();
                    img.onload = () => {
                        const imageObject = {
                            img: img,
                            x: imageObjData.x,
                            y: imageObjData.y,
                            width: imageObjData.width,
                            height: imageObjData.height,
                            theme: imageObjData.theme,
                            transparency: imageObjData.transparency,
                            rotation: imageObjData.rotation,
                            blur: imageObjData.blur,
                            themeBlur: imageObjData.themeBlur,
                            themeOpacity: imageObjData.themeOpacity,
                            flashFrequencyEnabled: imageObjData.flashFrequencyEnabled || false,
                            flashFrequencyThreshold: imageObjData.flashFrequencyThreshold || 0.5,
                            flashVolumeEnabled: imageObjData.flashVolumeEnabled || false,
                            flashVolumeThreshold: imageObjData.flashVolumeThreshold || 0.5,
                            canvas: canvas,
                            isDragging: false,
                            isResizing: false,
                            dragStartX: 0,
                            dragStartY: 0,
                            dragStartWidth: 0,
                            dragStartHeight: 0
                        };

                        state.imageObjects.push(imageObject);
                        const imageIndex = state.imageObjects.length - 1;
                        setupImageInteraction(canvas, imageIndex);

                        console.log(`âœ… Image object restored: ${imageObjData.width.toFixed(0)}x${imageObjData.height.toFixed(0)}, theme: ${imageObject.theme}`);
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('âŒ Failed to load image data, creating placeholder');
                        createImagePlaceholder(canvas, imageObjData);
                        resolve();
                    };
                    img.src = imageObjData.imageData;
                } else {
                    // No image data - create placeholder
                    createImagePlaceholder(canvas, imageObjData);
                    resolve();
                }
            });
        }

        function createImagePlaceholder(canvas, imageObjData) {
            // Create a placeholder image object
            const placeholderCanvas = document.createElement('canvas');
            placeholderCanvas.width = 200;
            placeholderCanvas.height = 200;
            const ctx = placeholderCanvas.getContext('2d');

            // Draw placeholder (gray box with dashed border)
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 200, 200);
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.strokeRect(0, 0, 200, 200);
            ctx.setLineDash([]);

            // Add text
            ctx.fillStyle = '#999999';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('DROP IMAGE', 100, 90);
            ctx.fillText('HERE', 100, 110);

            const placeholderImg = new Image();
            placeholderImg.onload = () => {
                const imageObject = {
                    img: placeholderImg,
                    x: imageObjData.x,
                    y: imageObjData.y,
                    width: imageObjData.width,
                    height: imageObjData.height,
                    theme: imageObjData.theme,
                    transparency: imageObjData.transparency,
                    rotation: imageObjData.rotation,
                    blur: imageObjData.blur,
                    themeBlur: imageObjData.themeBlur,
                    themeOpacity: imageObjData.themeOpacity,
                    flashFrequencyEnabled: imageObjData.flashFrequencyEnabled || false,
                    flashFrequencyThreshold: imageObjData.flashFrequencyThreshold || 0.5,
                    flashVolumeEnabled: imageObjData.flashVolumeEnabled || false,
                    flashVolumeThreshold: imageObjData.flashVolumeThreshold || 0.5,
                    canvas: canvas,
                    isDragging: false,
                    isResizing: false,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragStartWidth: 0,
                    dragStartHeight: 0,
                    isPlaceholder: true
                };

                state.imageObjects.push(imageObject);
                const imageIndex = state.imageObjects.length - 1;
                setupImageInteraction(canvas, imageIndex);
                setupPlaceholderDropZone(canvas, imageIndex);

                console.log(`âš ï¸ Placeholder created at ${imageObjData.x.toFixed(0)}, ${imageObjData.y.toFixed(0)}`);
            };
            placeholderImg.src = placeholderCanvas.toDataURL();
        }

        function setupPlaceholderDropZone(canvas, imageIndex) {
            // Add drag & drop functionality to placeholder
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '0.5';
            });

            canvas.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '1.0';
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvas.style.opacity = '1.0';

                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    replacePlaceholderWithImage(imageIndex, files[0]);
                }
            });
        }

        function replacePlaceholderWithImage(imageIndex, file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const imageObj = state.imageObjects[imageIndex];
                    imageObj.img = img;
                    imageObj.isPlaceholder = false;
                    console.log(`âœ… Placeholder replaced with image at index ${imageIndex}`);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function syncControlsWithState() {
            // Sync theme dropdown
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) themeSelect.value = state.settings.theme;

            // Sync mode buttons
            const modeButtons = document.querySelectorAll('[data-mode]');
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === state.settings.mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync density buttons
            const densityButtons = document.querySelectorAll('[data-density]');
            densityButtons.forEach(btn => {
                if (btn.dataset.density === state.settings.density) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync sliders
            const sliderMappings = [
                { id: 'lowEmphasis', value: state.settings.lowEmphasis, display: 'lowValue' },
                { id: 'midEmphasis', value: state.settings.midEmphasis, display: 'midValue' },
                { id: 'highEmphasis', value: state.settings.highEmphasis, display: 'highValue' },
                { id: 'intensitySlider', value: state.settings.waveIntensity, display: 'intensityValue' },
                { id: 'speedSlider', value: state.settings.waveSpeed, display: 'speedValue' },
                { id: 'smoothingSlider', value: state.settings.waveSmoothing, display: 'smoothingValue' },
                { id: 'rotationSlider', value: state.settings.rotationIntensity, display: 'rotationValue' },
                { id: 'glitchSlider', value: state.settings.glitchEffectIntensity, display: 'glitchValue' },
                { id: 'neonWarmCoolSlider', value: state.settings.neonWarmCool, display: 'neonWarmCoolValue' },
                { id: 'neonSatRangeSlider', value: state.settings.neonSatRange, display: 'neonSatRangeValue' }
            ];

            sliderMappings.forEach(mapping => {
                const slider = document.getElementById(mapping.id);
                const display = document.getElementById(mapping.display);
                if (slider) slider.value = mapping.value;
                if (display) display.textContent = mapping.value.toFixed(1);
            });

            // Sync glitch mode
            const glitchModeButtons = document.querySelectorAll('[data-glitch-mode]');
            glitchModeButtons.forEach(btn => {
                if (btn.dataset.glitchMode === state.settings.glitchMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Sync neon color mode
            const neonColorModeButtons = document.querySelectorAll('[data-neon-mode]');
            neonColorModeButtons.forEach(btn => {
                if (btn.dataset.neonMode === state.settings.neonColorMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // =====================================================
        // CONTROLS SETUP
        // =====================================================

        function setupControls() {
            // Sidebar toggle
            elements.sidebarToggle.addEventListener('click', () => {
                elements.sidebar.classList.toggle('open');

                // Also toggle class on buttons for animation
                const sidebarOpen = elements.sidebar.classList.contains('open');
                const sidebarToggle = document.getElementById('sidebarToggle');
                const fullscreenToggle = document.getElementById('fullscreenToggle');

                if (sidebarOpen) {
                    if (sidebarToggle) sidebarToggle.classList.add('sidebar-is-open');
                    if (fullscreenToggle) fullscreenToggle.classList.add('sidebar-is-open');
                } else {
                    if (sidebarToggle) sidebarToggle.classList.remove('sidebar-is-open');
                    if (fullscreenToggle) fullscreenToggle.classList.remove('sidebar-is-open');
                }
            });

            // Fullscreen toggle
            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle) {
                fullscreenToggle.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        // Enter fullscreen
                        document.documentElement.requestFullscreen().catch(err => {
                            console.error(`Error attempting to enable fullscreen: ${err.message}`);
                        });
                    } else {
                        // Exit fullscreen
                        document.exitFullscreen();
                    }
                });

                // Update button icon when fullscreen state changes
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        fullscreenToggle.textContent = 'â›¶'; // Exit fullscreen icon
                    } else {
                        fullscreenToggle.textContent = 'â›¶'; // Enter fullscreen icon
                    }
                });
            }

            // 'h' key to toggle UI visibility (all nav icons)
            document.addEventListener('keydown', (e) => {
                // 'h' key - toggle UI visibility
                if (e.key === 'h' || e.key === 'H') {
                    const statusBar = document.getElementById('statusBar');
                    const fullscreenBtn = document.getElementById('fullscreenToggle');
                    const addImageBtn = document.getElementById('addImageButton');
                    const sidebarToggle = document.getElementById('sidebarToggle');

                    // Check if UI is currently hidden
                    const isHidden = statusBar && statusBar.classList.contains('hidden-control');

                    if (isHidden) {
                        // Show UI and cursor
                        if (statusBar) statusBar.classList.remove('hidden-control');
                        if (fullscreenBtn) fullscreenBtn.classList.remove('hidden-control');
                        if (addImageBtn) addImageBtn.classList.remove('hidden-control');
                        if (sidebarToggle) sidebarToggle.classList.remove('hidden-control');
                        document.body.classList.remove('hide-cursor');
                    } else {
                        // Hide UI and cursor
                        if (statusBar) statusBar.classList.add('hidden-control');
                        if (fullscreenBtn) fullscreenBtn.classList.add('hidden-control');
                        if (addImageBtn) addImageBtn.classList.add('hidden-control');
                        if (sidebarToggle) sidebarToggle.classList.add('hidden-control');
                        document.body.classList.add('hide-cursor');
                    }
                }

                // 'Escape' key - deselect image
                if (e.key === 'Escape' && state.selectedImageIndex !== -1) {
                    state.selectedImageIndex = -1;
                    updateModeVisibility();
                    console.log('ðŸ”² Image deselected');
                }

                // 'Delete' or 'Backspace' key - remove selected image
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedImageIndex !== -1) {
                    // Prevent default browser back navigation on Backspace
                    e.preventDefault();

                    const imageIndex = state.selectedImageIndex;
                    const imageObj = state.imageObjects[imageIndex];

                    // Remove canvas from DOM
                    if (imageObj.canvas && imageObj.canvas.parentNode) {
                        imageObj.canvas.parentNode.removeChild(imageObj.canvas);
                    }

                    // Remove from array
                    state.imageObjects.splice(imageIndex, 1);

                    // Deselect
                    state.selectedImageIndex = -1;
                    updateModeVisibility();

                    console.log(`ðŸ—‘ï¸ Image removed at index ${imageIndex}`);
                }
            });

            // Theme selector
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    state.settings.theme = e.target.value;
                    console.log(`ðŸŽ¨ Theme changed to: ${state.settings.theme.toUpperCase()}`);

                    // Clean up theme-specific elements
                    const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
                    if (gradientMeshGroup) {
                        gradientMeshGroup.innerHTML = '';
                    }

                    // Clean up glitch paths
                    const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
                    allGlitchPaths.forEach(path => path.remove());

                    // Reset path attributes for theme change
                    state.paths.forEach((path) => {
                        path.removeAttribute('filter');
                        path.removeAttribute('transform');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('stroke', '#ffffff');
                    });

                    // Update colors for new theme
                    updateColors();

                    console.log(`âœ… Theme switched to ${state.settings.theme.toUpperCase()}`);
                });
            }

            // Image theme selector
            const imageThemeSelect = document.getElementById('imageThemeSelect');
            if (imageThemeSelect) {
                imageThemeSelect.addEventListener('change', (e) => {
                    if (state.selectedImageIndex === -1) return;

                    const imageObj = state.imageObjects[state.selectedImageIndex];
                    if (imageObj) {
                        imageObj.theme = e.target.value;
                        console.log(`ðŸŽ¨ Image theme changed to: ${imageObj.theme.toUpperCase()}`);

                        // Hide/show effect settings based on theme
                        const effectSettings = document.getElementById('imageEffectSettings');
                        if (effectSettings) {
                            if (e.target.value === 'none') {
                                effectSettings.style.display = 'none';
                            } else {
                                effectSettings.style.display = 'block';
                            }
                        }
                    }
                });
            }

            // Image transparency slider
            setupSlider('imageTransparencySlider', 'imageTransparencyValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.transparency = value;
                }
            });

            // Image rotation slider
            setupSlider('imageRotationSlider', 'imageRotationValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.rotation = value;
                }
            });

            // Image blur slider
            setupSlider('imageBlurSlider', 'imageBlurValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.blur = value;
                }
            });

            // 3D Motion slider (global setting for all images)
            setupSlider('image3DMotionSlider', 'image3DMotionValue', (value) => {
                state.settings.image3DMotion = value;
            });

            // Flash effect controls
            const flashFrequencyCheck = document.getElementById('flashFrequencyCheck');
            const flashFrequencySliderGroup = document.getElementById('flashFrequencySliderGroup');
            const flashVolumeCheck = document.getElementById('flashVolumeCheck');
            const flashVolumeSliderGroup = document.getElementById('flashVolumeSliderGroup');

            flashFrequencyCheck.addEventListener('change', (e) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashFrequencyEnabled = e.target.checked;
                    flashFrequencySliderGroup.style.display = e.target.checked ? 'block' : 'none';
                }
            });

            flashVolumeCheck.addEventListener('change', (e) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashVolumeEnabled = e.target.checked;
                    flashVolumeSliderGroup.style.display = e.target.checked ? 'block' : 'none';
                }
            });

            setupSlider('flashFrequencySlider', 'flashFrequencyValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashFrequencyThreshold = value;
                }
            });

            setupSlider('flashVolumeSlider', 'flashVolumeValue', (value) => {
                if (state.selectedImageIndex === -1) return;
                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.flashVolumeThreshold = value;
                }
            });

            // Video controls
            const videoLoopCheck = document.getElementById('videoLoopCheck');
            if (videoLoopCheck) {
                videoLoopCheck.addEventListener('change', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo) {
                        videoObj.loop = e.target.checked;
                    }
                });
            }

            // Video trim sliders with scrubbing
            const videoTrimStartSlider = document.getElementById('videoTrimStartSlider');
            const videoTrimStartValue = document.getElementById('videoTrimStartValue');
            if (videoTrimStartSlider && videoTrimStartValue) {
                videoTrimStartSlider.addEventListener('input', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo && videoObj.video) {
                        const value = parseFloat(e.target.value);
                        videoObj.trimStart = value;
                        videoTrimStartValue.textContent = `${value.toFixed(1)}s`;
                        // Scrub to this position
                        videoObj.video.currentTime = value;
                    }
                });
            }

            const videoTrimEndSlider = document.getElementById('videoTrimEndSlider');
            const videoTrimEndValue = document.getElementById('videoTrimEndValue');
            if (videoTrimEndSlider && videoTrimEndValue) {
                videoTrimEndSlider.addEventListener('input', (e) => {
                    if (state.selectedImageIndex === -1) return;
                    const videoObj = state.imageObjects[state.selectedImageIndex];
                    if (videoObj && videoObj.isVideo && videoObj.video) {
                        const value = parseFloat(e.target.value);
                        videoObj.trimEnd = value;
                        videoTrimEndValue.textContent = `${value.toFixed(1)}s`;
                        // Scrub to this position
                        videoObj.video.currentTime = value;
                    }
                });
            }

            // Theme opacity slider
            setupSlider('themeOpacitySlider', 'themeOpacityValue', (value) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (imageObj) {
                    imageObj.themeOpacity = value;
                }
            });

            // Frequency emphasis sliders
            setupSlider('lowEmphasis', 'lowValue', (value) => {
                state.settings.lowEmphasis = value;
            });

            setupSlider('midEmphasis', 'midValue', (value) => {
                state.settings.midEmphasis = value;
            });

            setupSlider('highEmphasis', 'highValue', (value) => {
                state.settings.highEmphasis = value;
            });

            // Wave settings sliders
            setupSlider('intensitySlider', 'intensityValue', (value) => {
                state.settings.intensity = value;
            });

            setupSlider('speedSlider', 'speedValue', (value) => {
                state.settings.speed = value;
            });

            setupSlider('smoothingSlider', 'smoothingValue', (value) => {
                state.settings.smoothing = value;
                if (state.analyser) {
                    state.analyser.smoothingTimeConstant = value;
                }
            });

            // NEON color temperature slider
            setupSlider('colorTempSlider', 'colorTempValue', (value) => {
                state.settings.colorTemp = value;
            });


            // GLITCH rotation intensity slider
            setupSlider('rotationIntensitySlider', 'rotationIntensityValue', (value) => {
                state.settings.rotationIntensity = value;
            });

            // GLITCH effect intensity slider
            setupSlider('glitchIntensitySlider', 'glitchIntensityValue', (value) => {
                state.settings.glitchEffectIntensity = value;
            });

            // GLITCH contrast slider
            setupSlider('glitchContrastSlider', 'glitchContrastValue', (value) => {
                state.settings.glitchContrast = value;
            });

            // STARS hue slider
            const starHueSlider = document.getElementById('starHueSlider');
            const starHueValue = document.getElementById('starHueValue');
            if (starHueSlider && starHueValue) {
                starHueSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starHue = value;
                    starHueValue.textContent = `${Math.round(value)}Â°`;
                    // Update star gradient with new hue
                    if (state.stars.initialized) {
                        updateStarGradient();
                    }
                });
            }

            // STARS saturation slider
            const starSaturationSlider = document.getElementById('starSaturationSlider');
            const starSaturationValue = document.getElementById('starSaturationValue');
            if (starSaturationSlider && starSaturationValue) {
                starSaturationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starSaturation = value;
                    starSaturationValue.textContent = `${Math.round(value)}%`;
                    // Update star gradient with new saturation
                    if (state.stars.initialized) {
                        updateStarGradient();
                    }
                });
            }

            // STARS speed slider
            const starSpeedSlider = document.getElementById('starSpeedSlider');
            const starSpeedValue = document.getElementById('starSpeedValue');
            if (starSpeedSlider && starSpeedValue) {
                starSpeedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.settings.starSpeed = value;
                    starSpeedValue.textContent = value.toFixed(1);
                    // Speed affects orbit velocity, no need to reinitialize
                });
            }

            // Density and mode options
            document.querySelectorAll('.density-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Handle density change
                    if (option.dataset.density) {
                        document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.density = option.dataset.density;
                        setupWaveGrid();

                        // Map density to burst size for NEON theme
                        const densityToBurstSize = {
                            'low': 0.5,
                            'medium': 1.0,
                            'high': 1.5
                        };
                        state.settings.neonBurstSize = densityToBurstSize[option.dataset.density] || 1.0;
                        console.log(`ðŸŽ¨ NEON burst size set to: ${state.settings.neonBurstSize} (density: ${option.dataset.density})`);
                    }

                    // Handle mode change
                    if (option.dataset.mode) {
                        document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.mode = option.dataset.mode;
                        console.log(`ðŸ”„ Mode changed to: ${state.settings.mode.toUpperCase()}`);
                    }

                    // Handle glitch mode change
                    if (option.dataset.glitchMode) {
                        document.querySelectorAll('[data-glitch-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.glitchMode = option.dataset.glitchMode;
                        console.log(`ðŸŽ¨ GLITCH mode changed to: ${state.settings.glitchMode.toUpperCase()}`);
                    }

                    // Handle neon mode change
                    if (option.dataset.neonMode) {
                        document.querySelectorAll('[data-neon-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.neonMode = option.dataset.neonMode;
                        console.log(`ðŸŽ¨ NEON mode changed to: ${state.settings.neonMode.toUpperCase()}`);
                    }
                });
            });

            // Reset button
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetToDefaults);
            }

            // Add image button and dropdown
            const addImageButton = document.getElementById('addImageButton');
            const addImageDropdown = document.getElementById('addImageDropdown');
            const addImageMenuItem = document.getElementById('addImageMenuItem');

            if (addImageButton && addImageDropdown && addImageMenuItem) {
                // Toggle dropdown on button click
                addImageButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addImageDropdown.classList.toggle('show');
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!addImageButton.contains(e.target) && !addImageDropdown.contains(e.target)) {
                        addImageDropdown.classList.remove('show');
                    }
                });

                // Handle "Add Image" menu item click
                addImageMenuItem.addEventListener('click', () => {
                    addImageDropdown.classList.remove('show');

                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';

                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadImageFile(file);
                        }
                    });

                    document.body.appendChild(fileInput);
                    fileInput.click();
                    document.body.removeChild(fileInput);
                });

                // Handle "Add Video" menu item click
                const addVideoMenuItem = document.getElementById('addVideoMenuItem');
                if (addVideoMenuItem) {
                    addVideoMenuItem.addEventListener('click', () => {
                        addImageDropdown.classList.remove('show');
                        const videoPopup = document.getElementById('videoPopup');
                        const videoUrlInput = document.getElementById('videoUrlInput');
                        if (videoPopup && videoUrlInput) {
                            videoUrlInput.value = '';
                            videoPopup.style.display = 'flex';
                            videoUrlInput.focus();
                        }
                    });
                }

                // Handle video popup buttons
                const videoPopupAdd = document.getElementById('videoPopupAdd');
                const videoPopupCancel = document.getElementById('videoPopupCancel');
                const videoPopup = document.getElementById('videoPopup');
                const videoUrlInput = document.getElementById('videoUrlInput');

                if (videoPopupAdd && videoPopup && videoUrlInput) {
                    videoPopupAdd.addEventListener('click', () => {
                        const url = videoUrlInput.value.trim();
                        if (url) {
                            loadVideoFromUrl(url);
                            videoPopup.style.display = 'none';
                        }
                    });
                }

                if (videoPopupCancel && videoPopup) {
                    videoPopupCancel.addEventListener('click', () => {
                        videoPopup.style.display = 'none';
                    });
                }

                // Close video popup on Escape key
                if (videoPopup && videoUrlInput) {
                    videoUrlInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            videoPopup.style.display = 'none';
                        } else if (e.key === 'Enter') {
                            const url = videoUrlInput.value.trim();
                            if (url) {
                                loadVideoFromUrl(url);
                                videoPopup.style.display = 'none';
                            }
                        }
                    });
                }

                // Handle "Save Canvas" menu item click
                const saveCanvasMenuItem = document.getElementById('saveCanvasMenuItem');
                if (saveCanvasMenuItem) {
                    saveCanvasMenuItem.addEventListener('click', () => {
                        addImageDropdown.classList.remove('show');
                        saveCanvasState();
                    });
                }

                // Handle "Load Canvas" menu item click
                const loadCanvasMenuItem = document.getElementById('loadCanvasMenuItem');
                const loadCanvasInput = document.getElementById('loadCanvasInput');
                if (loadCanvasMenuItem && loadCanvasInput) {
                    loadCanvasMenuItem.addEventListener('click', () => {
                        addImageDropdown.classList.remove('show');
                        loadCanvasInput.click();
                    });

                    loadCanvasInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadCanvasStateFromFile(file);
                        }
                    });
                }
            }

            // Mouse tracking
            window.addEventListener('mousemove', (e) => {
                state.mouse.x = e.clientX;
                state.mouse.y = e.clientY;
                state.mouse.onScreen = true;

                if (!state.mouse.set) {
                    state.mouse.sx = state.mouse.x;
                    state.mouse.sy = state.mouse.y;
                    state.mouse.lx = state.mouse.x;
                    state.mouse.ly = state.mouse.y;
                    state.mouse.set = true;
                }

                // Show controls on mouse movement
                showControls();
            });

            // Track when mouse leaves the screen
            window.addEventListener('mouseleave', () => {
                state.mouse.onScreen = false;
            });

            window.addEventListener('mouseenter', () => {
                state.mouse.onScreen = true;
            });

            // Window resize
            window.addEventListener('resize', () => {
                setupWaveGrid();
            });

            // Image upload overlay click handler
            const uploadOverlay = document.getElementById('upload-overlay');
            if (uploadOverlay) {
                uploadOverlay.addEventListener('click', () => {
                    // Create hidden file input
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';

                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadImageFile(file);
                        }
                    });

                    document.body.appendChild(fileInput);
                    fileInput.click();
                    document.body.removeChild(fileInput);
                });
            }

            // Drag & drop image upload
            const dragOverlay = document.getElementById('drag-overlay');
            const visualizationContainer = document.getElementById('visualization-container');

            if (visualizationContainer && dragOverlay) {
                // Prevent default drag behavior
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    visualizationContainer.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Show drag overlay when dragging over
                visualizationContainer.addEventListener('dragenter', (e) => {
                    if (!state.glitchImage.loaded) {
                        dragOverlay.style.display = 'flex';
                    }
                });

                visualizationContainer.addEventListener('dragleave', (e) => {
                    // Only hide if we're leaving the container entirely
                    if (e.target === visualizationContainer) {
                        dragOverlay.style.display = 'none';
                    }
                });

                visualizationContainer.addEventListener('drop', (e) => {
                    dragOverlay.style.display = 'none';

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        // Check if it's a JSON file (canvas state)
                        if (file.type === 'application/json' || file.name.endsWith('.json')) {
                            console.log('ðŸ“ Loading canvas state from dropped JSON file');
                            loadCanvasStateFromFile(file);
                        } else if (file.type.startsWith('image/')) {
                            // It's an image file
                            loadImageFile(file);
                        }
                    }
                });
            }

            // Helper function to load image file
            function loadVideoFromUrl(url) {
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.muted = true; // Muted by default for autoplay compatibility

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.createElement('canvas');
                    canvas.style.position = 'absolute';
                    canvas.style.cursor = 'move';
                    canvas.style.pointerEvents = 'auto';
                    canvas.className = 'image-object-canvas';
                    document.getElementById('visualization-container').appendChild(canvas);

                    // Scale to reasonable size
                    const width = Math.min(video.videoWidth, 600);
                    const height = (width / video.videoWidth) * video.videoHeight;
                    const x = (state.boundingRect.width - width) / 2;
                    const y = (state.boundingRect.height - height) / 2;

                    // Create video object (similar to image object but with video element)
                    const videoObject = {
                        video: video,
                        isVideo: true,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        theme: 'none',
                        transparency: 1.0,
                        rotation: 0,
                        blur: 0,
                        themeBlur: 0,
                        themeOpacity: 1.0,
                        flashFrequencyEnabled: false,
                        flashFrequencyThreshold: 0.5,
                        flashVolumeEnabled: false,
                        flashVolumeThreshold: 0.5,
                        loop: true,
                        trimStart: 0,
                        trimEnd: video.duration,
                        duration: video.duration,
                        canvas: canvas,
                        isDragging: false,
                        isResizing: false,
                        dragStartX: 0,
                        dragStartY: 0,
                        dragStartWidth: 0,
                        dragStartHeight: 0
                    };

                    state.imageObjects.push(videoObject);
                    const videoIndex = state.imageObjects.length - 1;
                    state.selectedImageIndex = videoIndex;

                    // Add event listeners for selection and dragging
                    setupImageInteraction(canvas, videoIndex);

                    // Start playing the video
                    video.loop = true;
                    video.play().catch(e => console.warn('Video autoplay prevented:', e));

                    console.log(`âœ… Video object created: ${video.videoWidth}x${video.videoHeight} â†’ ${width.toFixed(0)}x${height.toFixed(0)}, duration: ${video.duration.toFixed(2)}s`);

                    // Update mode visibility
                    updateModeVisibility();
                });

                video.addEventListener('error', (e) => {
                    console.error('âŒ Failed to load video:', url, e);
                    alert('Failed to load video. Please check the URL and ensure CORS is enabled.');
                });

                video.src = url;
                video.load();
            }

            function loadImageFile(file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (state.settings.theme === 'glitch') {
                            // GLITCH theme: Load into glitchImage for background replacement
                            state.glitchImage.img = img;
                            state.glitchImage.loaded = true;

                            // Fill canvas by scaling to cover
                            const canvasAspect = state.boundingRect.width / state.boundingRect.height;
                            const imgAspect = img.width / img.height;

                            if (imgAspect > canvasAspect) {
                                // Image is wider - fit to height
                                state.glitchImage.height = state.boundingRect.height;
                                state.glitchImage.width = state.glitchImage.height * imgAspect;
                            } else {
                                // Image is taller - fit to width
                                state.glitchImage.width = state.boundingRect.width;
                                state.glitchImage.height = state.glitchImage.width / imgAspect;
                            }

                            // Center the image
                            state.glitchImage.x = (state.boundingRect.width - state.glitchImage.width) / 2;
                            state.glitchImage.y = (state.boundingRect.height - state.glitchImage.height) / 2;

                            console.log(`âœ… GLITCH image loaded: ${img.width}x${img.height} â†’ ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                        } else {
                            // LINEAR/NEON theme: Create image object overlay
                            const canvas = document.createElement('canvas');
                            canvas.style.position = 'absolute';
                            canvas.style.cursor = 'move';
                            canvas.style.pointerEvents = 'auto';
                            canvas.className = 'image-object-canvas';
                            document.getElementById('visualization-container').appendChild(canvas);

                            // Scale to reasonable size
                            const width = Math.min(img.width, 600);
                            const height = (width / img.width) * img.height;
                            const x = (state.boundingRect.width - width) / 2;
                            const y = (state.boundingRect.height - height) / 2;

                            // Create image object
                            const imageObject = {
                                img: img,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                theme: 'none', // Default to no effect
                                transparency: 1.0, // Default to fully opaque
                                rotation: 0, // Rotation in degrees
                                blur: 0, // Blur amount in pixels
                                themeBlur: 0, // Blur on theme effect
                                themeOpacity: 1.0, // Opacity of theme effect
                                flashFrequencyEnabled: false,
                                flashFrequencyThreshold: 0.5,
                                flashVolumeEnabled: false,
                                flashVolumeThreshold: 0.5,
                                canvas: canvas,
                                isDragging: false,
                                isResizing: false,
                                dragStartX: 0,
                                dragStartY: 0,
                                dragStartWidth: 0,
                                dragStartHeight: 0
                            };

                            state.imageObjects.push(imageObject);
                            const imageIndex = state.imageObjects.length - 1;
                            state.selectedImageIndex = imageIndex; // Select the newly added image

                            // Add event listeners for selection and dragging
                            setupImageInteraction(canvas, imageIndex);

                            console.log(`âœ… Image object created: ${img.width}x${img.height} â†’ ${width.toFixed(0)}x${height.toFixed(0)}, theme: ${imageObject.theme}`);
                        }

                        // Hide upload overlay
                        updateModeVisibility();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }

            // Global mouse handlers for dragging and resizing
            window.addEventListener('mousemove', (e) => {
                if (state.selectedImageIndex === -1) return;

                const imageObj = state.imageObjects[state.selectedImageIndex];
                if (!imageObj) return;

                if (imageObj.isDragging) {
                    // Drag to move
                    imageObj.x = e.clientX - imageObj.dragStartX;
                    imageObj.y = e.clientY - imageObj.dragStartY;
                } else if (imageObj.isResizing) {
                    // Drag to resize
                    const deltaX = e.clientX - imageObj.dragStartX;
                    const deltaY = e.clientY - imageObj.dragStartY;

                    const newWidth = Math.max(100, imageObj.dragStartWidth + deltaX);
                    const newHeight = Math.max(100, imageObj.dragStartHeight + deltaY);

                    // Maintain aspect ratio
                    let aspectRatio;
                    if (imageObj.isVideo && imageObj.video) {
                        aspectRatio = imageObj.video.videoWidth / imageObj.video.videoHeight;
                    } else if (imageObj.img) {
                        aspectRatio = imageObj.img.width / imageObj.img.height;
                    } else {
                        aspectRatio = 1;
                    }
                    imageObj.width = newWidth;
                    imageObj.height = newWidth / aspectRatio;
                }
            });

            window.addEventListener('mouseup', (e) => {
                // Stop dragging/resizing for all image objects
                state.imageObjects.forEach((imageObj) => {
                    if (imageObj.isDragging || imageObj.isResizing) {
                        imageObj.isDragging = false;
                        imageObj.isResizing = false;
                        imageObj.canvas.style.cursor = 'move';
                    }
                });
            });

            // Click on background to deselect images (reuse visualizationContainer from above)
            if (visualizationContainer) {
                visualizationContainer.addEventListener('click', (e) => {
                    // Only deselect if clicking directly on the container (not on an image canvas)
                    if (e.target === visualizationContainer || e.target.id === 'wave-svg') {
                        state.selectedImageIndex = -1;
                        updateModeVisibility(); // Update UI to hide image theme selector
                    }
                });
            }

            // Click to add gradient centers (NEON theme only)
            window.addEventListener('click', (e) => {
                // Only add gradient centers for NEON theme
                if (state.settings.theme !== 'neon') return;

                // Don't add if clicking on UI elements or image canvases
                if (e.target.closest('.sidebar') || e.target.closest('.sidebar-toggle') || e.target.classList.contains('image-object-canvas')) return;

                // Add new gradient center at click position
                const newCenter = {
                    x: e.clientX,
                    y: e.clientY,
                    createdAt: Date.now()
                };

                state.userGradientCenters.push(newCenter);

                // Keep only the most recent 3 centers
                if (state.userGradientCenters.length > 3) {
                    state.userGradientCenters.shift(); // Remove the oldest
                }

                console.log(`âœ¨ Added gradient center at (${e.clientX}, ${e.clientY}). Total: ${state.userGradientCenters.length}`);
            });

            // Click & drag to resize GLITCH background image
            const themeCanvas = document.getElementById('theme-canvas');

            if (themeCanvas) {
                themeCanvas.addEventListener('mousedown', (e) => {
                    // Only handle resize when GLITCH theme is active and image is loaded
                    if (state.settings.theme !== 'glitch' || !state.glitchImage.loaded) return;

                    state.glitchImage.isDragging = true;
                    state.glitchImage.dragStartX = e.clientX;
                    state.glitchImage.dragStartY = e.clientY;
                    state.glitchImage.dragStartWidth = state.glitchImage.width;
                    state.glitchImage.dragStartHeight = state.glitchImage.height;

                    themeCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            }

            // Handle mouse move for resize
            window.addEventListener('mousemove', (e) => {
                if (!state.glitchImage.isDragging) return;

                // Calculate drag distance
                const dx = e.clientX - state.glitchImage.dragStartX;
                const dy = e.clientY - state.glitchImage.dragStartY;
                const dragDistance = Math.hypot(dx, dy);
                const dragDirection = dx + dy > 0 ? 1 : -1;

                // Calculate new size (proportional to drag distance)
                const scaleFactor = 1 + (dragDirection * dragDistance / 500);
                const newWidth = Math.max(100, state.glitchImage.dragStartWidth * scaleFactor);
                const aspectRatio = state.glitchImage.img.height / state.glitchImage.img.width;
                const newHeight = newWidth * aspectRatio;

                // Update image dimensions
                state.glitchImage.width = newWidth;
                state.glitchImage.height = newHeight;

                // Re-center the image
                state.glitchImage.x = (state.boundingRect.width - newWidth) / 2;
                state.glitchImage.y = (state.boundingRect.height - newHeight) / 2;
            });

            // Handle mouse up to finish resize
            window.addEventListener('mouseup', () => {
                if (state.glitchImage.isDragging) {
                    state.glitchImage.isDragging = false;

                    // Reset cursor on theme canvas
                    if (themeCanvas) themeCanvas.style.cursor = 'grab';

                    console.log(`ðŸ–¼ï¸ GLITCH image resized to ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                }
            });
        }

        function setupSlider(sliderId, valueId, callback) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                callback(value);
                valueDisplay.textContent = value.toFixed(1);
            });
        }

        function resetToDefaults() {
            // Reset settings
            state.settings = {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.5,
                density: 'medium',
                gradient: 'default',
                mode: 'default',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0,
                glitchContrast: 1.0,
                glitchMode: 'rgb',
                neonMode: 'bright',
                colorTemp: 1.0,
                image3DMotion: 0.0,
                starHue: 217,
                starSaturation: 61,
                starSpeed: 1.0
            };

            // Update UI
            document.getElementById('lowEmphasis').value = 1.0;
            document.getElementById('midEmphasis').value = 1.0;
            document.getElementById('highEmphasis').value = 1.0;
            document.getElementById('intensitySlider').value = 2.5;
            document.getElementById('speedSlider').value = 1.0;
            document.getElementById('smoothingSlider').value = 0.5;
            document.getElementById('colorTempSlider').value = 1.0;
            document.getElementById('rotationIntensitySlider').value = 1.0;
            document.getElementById('glitchIntensitySlider').value = 1.0;
            document.getElementById('glitchContrastSlider').value = 1.0;
            document.getElementById('image3DMotionSlider').value = 0.0;
            document.getElementById('starHueSlider').value = 217;
            document.getElementById('starSaturationSlider').value = 61;
            document.getElementById('starSpeedSlider').value = 1.0;

            document.getElementById('lowValue').textContent = '1.0';
            document.getElementById('midValue').textContent = '1.0';
            document.getElementById('highValue').textContent = '1.0';
            document.getElementById('intensityValue').textContent = '2.5';
            document.getElementById('speedValue').textContent = '1.0';
            document.getElementById('smoothingValue').textContent = '0.5';
            document.getElementById('colorTempValue').textContent = '1.0';
            document.getElementById('rotationIntensityValue').textContent = '1.0';
            document.getElementById('glitchIntensityValue').textContent = '1.0';
            document.getElementById('glitchContrastValue').textContent = '1.0';
            document.getElementById('image3DMotionValue').textContent = '0.0';
            document.getElementById('starHueValue').textContent = '217Â°';
            document.getElementById('starSaturationValue').textContent = '61%';
            document.getElementById('starSpeedValue').textContent = '1.0';

            // Update analyser if active
            if (state.analyser) {
                state.analyser.smoothingTimeConstant = 0.3;
            }

            // Clear user-created gradient centers
            state.userGradientCenters = [];

            // Reset density
            document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-density="medium"]').classList.add('active');

            // Reset mode
            document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-mode="hole"]').classList.add('active');

            // Reset glitch mode
            document.querySelectorAll('[data-glitch-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-glitch-mode="rgb"]').classList.add('active');

            // Reset neon mode
            document.querySelectorAll('[data-neon-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-neon-mode="bright"]').classList.add('active');

            // Reset theme
            document.getElementById('themeSelect').value = 'linear';

            // Rebuild grid and colors
            setupWaveGrid();
            updateColors();

            console.log('ðŸ”„ Reset to defaults');
        }

        // =====================================================
        // MOBILE COMPANION PAIRING (WebSocket)
        // =====================================================

        let socket = null;
        let pairingCode = null;
        let mobileConnected = false;

        // Connect to WebSocket server
        function initializePairing() {
            // Determine WebSocket server URL
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const port = window.location.port || '3000';

            // Use same host as web page, or fallback to localhost for local dev
            const socketUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                ? `http://localhost:3000`
                : `${window.location.protocol}//${window.location.host}`;

            socket = io(socketUrl);

            socket.on('connect', () => {
                console.log('ðŸ”Œ Connected to WebSocket server');

                // Request pairing code from server
                socket.emit('desktop:create-session', (response) => {
                    if (response.success) {
                        pairingCode = response.code;
                        console.log('ðŸ“± Pairing code generated:', pairingCode);
                    } else {
                        console.error('âŒ Failed to create session');
                    }
                });
            });

            socket.on('disconnect', () => {
                console.log('ðŸ”Œ Disconnected from WebSocket server');
                mobileConnected = false;
            });

            socket.on('mobile:connected', () => {
                console.log('ðŸ“± Mobile device connected');
                mobileConnected = true;

                // Send initial state to mobile
                sendStateToMobile();
            });

            socket.on('mobile:disconnected', () => {
                console.log('ðŸ“± Mobile device disconnected');
                mobileConnected = false;
            });

            socket.on('control-update', (update) => {
                console.log('ðŸ“± Received control update from mobile:', update);
                applyMobileUpdates(update);
            });

            socket.on('connect_error', (error) => {
                console.error('âŒ WebSocket connection error:', error);
            });
        }

        // Send current state to mobile
        function sendStateToMobile() {
            if (!socket || !mobileConnected) return;

            const stateSnapshot = {
                settings: {
                    intensity: state.settings.intensity,
                    speed: state.settings.speed,
                    smoothing: state.settings.smoothing,
                    mode: state.settings.mode,
                    freqEmphasis: state.settings.freqEmphasis
                }
            };

            socket.emit('desktop:state-update', stateSnapshot);
        }

        // Update shared state (called when desktop controls change)
        function updateSharedState(updates) {
            if (!socket || !mobileConnected) return;
            socket.emit('desktop:state-update', updates);
        }

        // Listen for state changes from mobile
        function startListeningForMobileUpdates() {
            // WebSocket listeners are already set up in initializePairing()
            // This function kept for compatibility
        }

        function applyMobileUpdates(updates) {
            // Apply settings updates from mobile
            if (updates.settings) {
                Object.assign(state.settings, updates.settings);

                // Update UI elements to reflect changes
                Object.entries(updates.settings).forEach(([key, value]) => {
                    const slider = document.getElementById(`${key}Slider`);
                    const valueEl = document.getElementById(`${key}Value`);

                    if (slider) slider.value = value;

                    if (valueEl) {
                        if (typeof value === 'number') {
                            valueEl.textContent = value.toFixed(1);
                        } else {
                            valueEl.textContent = value;
                        }
                    }

                    // Handle mode buttons
                    if (key === 'mode') {
                        document.querySelectorAll('.density-option').forEach(opt => {
                            opt.classList.toggle('active', opt.dataset.mode === value);
                        });
                    }
                });
            }
        }

        // Setup pairing UI event handlers
        function setupPairingUI() {
            const pairingToggle = document.getElementById('pairingToggle');
            const pairingPanel = document.getElementById('pairingPanel');
            const pairingClose = document.getElementById('pairingClose');
            const pairingCodeEl = document.getElementById('pairingCode');
            const pairingUrlEl = document.getElementById('pairingUrl');

            if (pairingToggle && pairingPanel) {
                pairingToggle.addEventListener('click', () => {
                    pairingPanel.style.display = 'flex';
                    // Update URL and code
                    if (pairingCodeEl) pairingCodeEl.textContent = pairingCode;
                    if (pairingUrlEl) {
                        const baseUrl = window.location.href.replace('/index.html', '').replace(/\/$/, '');
                        pairingUrlEl.textContent = `${baseUrl}/mobile.html`;
                    }
                });
            }

            if (pairingClose && pairingPanel) {
                pairingClose.addEventListener('click', () => {
                    pairingPanel.style.display = 'none';
                });
            }

            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && pairingPanel && pairingPanel.style.display !== 'none') {
                    pairingPanel.style.display = 'none';
                }
            });
        }

        // =====================================================
        // START APPLICATION
        // =====================================================

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        console.log('ðŸŒŠ Soundscape loaded');
    </script>
</body>
</html>
