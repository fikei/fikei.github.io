<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soundscape ‚Äî Audio-Reactive Wave Visualization</title>
    <meta name="description" content="Real-time audio visualization using simplex-noise wave grid that reacts to microphone input">
    <link rel="icon" type="image/png" href="https://cdn.glitch.me/597fe374-3d18-46a5-b99c-ceff1f8ffd79%2Ffavicon.png"/>

    <!-- Space Grotesk Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', monospace;
            font-size: 10px;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* ===== SVG VISUALIZATION CONTAINER ===== */
        #visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #wave-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-screen h1 {
            font-size: 10px;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #ffffff;
        }

        .loading-screen p {
            display: none;
        }

        .loading-spinner {
            margin-top: 1rem;
            width: 20px;
            height: 20px;
            border: 1px solid #333333;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== STATUS INDICATOR ===== */
        .status-bar {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 20;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #ffffff;
            font-size: 10px;
            display: none;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .status-bar.active {
            display: flex;
        }

        .status-bar.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            background: #ffffff;
            animation: blink 1s step-start infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        /* ===== SIDEBAR TOGGLE BUTTON ===== */
        .sidebar-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 101;
            width: 30px;
            height: 30px;
            background: #000000;
            border: 1px solid #ffffff;
            color: white;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease, background 0.15s ease;
        }

        .sidebar-toggle:hover {
            background: #ffffff;
            color: #000000;
        }

        .sidebar-toggle.hidden-control {
            opacity: 0;
            pointer-events: none;
        }

        /* ===== CONTROLS SIDEBAR ===== */
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100vh;
            background: #000000;
            border-left: 1px solid #ffffff;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            overflow-y: auto;
            padding: 1rem;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar h2 {
            font-size: 10px;
            margin-bottom: 2rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
            border-top: 1px solid #333333;
            padding-top: 1rem;
        }

        .control-section h3 {
            font-size: 10px;
            font-weight: 400;
            margin-bottom: 1rem;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 10px;
            color: #999999;
        }

        .control-value {
            color: #ffffff;
            font-weight: 400;
        }

        /* Range Sliders */
        input[type="range"] {
            width: 100%;
            height: 1px;
            background: #333333;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #000000;
        }

        input[type="range"]::-moz-range-thumb {
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid #ffffff;
            cursor: pointer;
        }

        /* Gradient Presets Grid */
        .gradient-grid {
            display: none;
        }

        /* Grid Density Controls */
        .density-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .density-option {
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .density-option:hover {
            border-color: #ffffff;
        }

        .density-option.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
        }

        /* Theme Dropdown */
        .theme-select {
            width: 100%;
            padding: 0.5rem;
            background: #000000;
            border: 1px solid #333333;
            color: #ffffff;
            font-size: 10px;
            font-family: 'Space Grotesk', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }

        .theme-select:hover {
            border-color: #ffffff;
        }

        .theme-select:focus {
            outline: none;
            border-color: #ffffff;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.5rem;
            font-size: 10px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-reset {
            background: #000000;
            border: 1px solid #ffffff;
            color: white;
            margin-top: 1.5rem;
        }

        .btn-reset:hover {
            background: #ffffff;
            color: #000000;
        }

        /* ===== ERROR SCREEN ===== */
        .error-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 2rem;
            background: #000000;
            border: 1px solid #ffffff;
            text-align: center;
            max-width: 300px;
            display: none;
        }

        .error-screen.show {
            display: block;
        }

        .error-screen h2 {
            color: #ffffff;
            margin-bottom: 1rem;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .error-screen p {
            color: #999999;
            line-height: 1.4;
            font-size: 10px;
        }

        /* ===== SCROLLBAR STYLING ===== */
        .sidebar::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #000000;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #333333;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #ffffff;
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- SVG Visualization Container -->
    <div id="visualization-container">
        <svg id="wave-svg" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- Neon glow filter -->
                <filter id="neon-glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur1"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur2"/>
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0" result="blur3"/>
                    <feMerge>
                        <feMergeNode in="blur3"/>
                        <feMergeNode in="blur2"/>
                        <feMergeNode in="blur1"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        </svg>
        <!-- Canvas for GLITCH theme image -->
        <canvas id="glitch-canvas" style="display: none; position: absolute; cursor: grab;"></canvas>
        <!-- Upload overlay for GLITCH theme -->
        <div id="upload-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10; cursor: pointer; align-items: center; justify-content: center;">
            <div style="text-align: center;">
                <p id="upload-text" style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload Image...</p>
            </div>
        </div>
        <!-- Drag overlay for GLITCH theme -->
        <div id="drag-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 15; pointer-events: none; align-items: center; justify-content: center; border: 3px dashed #ffffff; box-sizing: border-box;">
            <div style="text-align: center;">
                <p style="font-size: 10px; font-weight: 400; letter-spacing: 0.1em; color: #ffffff; text-transform: uppercase;">Upload</p>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1>SOUNDSCAPE</h1>
        <div class="loading-spinner"></div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
        <div class="status-indicator"></div>
        <span>ACTIVE</span>
    </div>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle controls">+</button>

    <!-- Controls Sidebar -->
    <aside class="sidebar" id="sidebar">
        <h2>CTRL</h2>

        <!-- Theme Selection -->
        <section class="control-section">
            <h3>THEME</h3>
            <select class="theme-select" id="themeSelect">
                <option value="linear">LINEAR</option>
                <option value="neon">NEON</option>
                <option value="glitch">GLITCH</option>
            </select>
        </section>

        <!-- Mode Selection (LINEAR theme only) -->
        <section class="control-section" id="modeSection">
            <h3>MODE</h3>
            <div class="density-options">
                <div class="density-option active" data-mode="hole">HOLE</div>
                <div class="density-option" data-mode="crunch">CRUNCH</div>
            </div>
        </section>

        <!-- NEON Theme Controls -->
        <section class="control-section" id="neonControlsSection" style="display: none;">
            <h3>NEON</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>BURST SIZE</span>
                    <span class="control-value" id="burstSizeValue">1.0</span>
                </div>
                <input type="range" id="burstSizeSlider" min="0.3" max="2.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- GLITCH Theme Controls -->
        <section class="control-section" id="glitchControlsSection" style="display: none;">
            <h3>GLITCH</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>ROTATION</span>
                    <span class="control-value" id="rotationIntensityValue">1.0</span>
                </div>
                <input type="range" id="rotationIntensitySlider" min="0" max="2.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>GLITCH</span>
                    <span class="control-value" id="glitchIntensityValue">1.0</span>
                </div>
                <input type="range" id="glitchIntensitySlider" min="0" max="2.0" step="0.1" value="1.0">
            </div>
        </section>

        <!-- Frequency Emphasis -->
        <section class="control-section">
            <h3>FREQ</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>LOW</span>
                    <span class="control-value" id="lowValue">1.0</span>
                </div>
                <input type="range" id="lowEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>MID</span>
                    <span class="control-value" id="midValue">1.0</span>
                </div>
                <input type="range" id="midEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>HIGH</span>
                    <span class="control-value" id="highValue">1.0</span>
                </div>
                <input type="range" id="highEmphasis" min="0" max="3" step="0.1" value="1">
            </div>
        </section>

        <!-- Wave Settings -->
        <section class="control-section">
            <h3>WAVE</h3>
            <div class="control-group">
                <div class="control-label">
                    <span>INTENSITY</span>
                    <span class="control-value" id="intensityValue">2.5</span>
                </div>
                <input type="range" id="intensitySlider" min="0" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SPEED</span>
                    <span class="control-value" id="speedValue">1.0</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="control-label">
                    <span>SMOOTHING</span>
                    <span class="control-value" id="smoothingValue">0.3</span>
                </div>
                <input type="range" id="smoothingSlider" min="0" max="1" step="0.1" value="0.3">
            </div>
        </section>

        <!-- Grid Density -->
        <section class="control-section">
            <h3>DENSITY</h3>
            <div class="density-options">
                <div class="density-option" data-density="low">L</div>
                <div class="density-option active" data-density="medium">M</div>
                <div class="density-option" data-density="high">H</div>
            </div>
        </section>

        <!-- Reset Button -->
        <button class="btn btn-reset" id="resetBtn">RESET</button>
    </aside>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <h2>MIC ACCESS REQUIRED</h2>
        <p>Allow microphone permissions and reload</p>
    </div>

    <script>
        // =====================================================
        // SOUNDSCAPE: Audio-Reactive Wave Visualization
        // =====================================================

        // Simple 2D noise function (Perlin-like)
        function createNoise2D() {
            const permutation = [];
            for (let i = 0; i < 256; i++) permutation[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
            }
            const p = [...permutation, ...permutation];

            const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return function(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = fade(x);
                const v = fade(y);
                const a = p[X] + Y;
                const b = p[X + 1] + Y;
                return lerp(v,
                    lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                    lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1))
                );
            };
        }

        // ===== DOM ELEMENTS =====
        const elements = {
            svg: document.getElementById('wave-svg'),
            container: document.getElementById('visualization-container'),
            loading: document.getElementById('loadingScreen'),
            sidebar: document.getElementById('sidebar'),
            sidebarToggle: document.getElementById('sidebarToggle'),
            statusBar: document.getElementById('statusBar'),
            error: document.getElementById('errorScreen')
        };

        // ===== CONFIGURATION =====
        const config = {
            // Audio settings
            fftSize: 128, // Reduced from 256 for lower latency
            smoothing: 0.3, // Reduced from 0.5 for faster response

            // Grid settings
            densityPresets: {
                low: { xGap: 20, yGap: 20 },
                medium: { xGap: 12, yGap: 12 },
                high: { xGap: 8, yGap: 8 }
            },

            // Wave physics
            waveAmplitude: 12,
            cursorInfluence: 0.00035,
            cursorRadius: 175,
            damping: 0.95,
            restoration: 0.01,

            // Color gradients (grayscale only)
            gradients: {
                default: { colors: ['#ffffff', '#999999'], bg: '#000000' }
            },

            // Theme configurations
            themes: {
                linear: {
                    colors: ['#ffffff', '#999999'],
                    bg: '#000000',
                    opacity: 0.6,
                    opacityMultiplier: 0.4 // Dynamic opacity range
                },
                neon: {
                    blurBase: 3,
                    blurMultiplier: 20,
                    saturationBase: 85,
                    saturationMultiplier: 15,
                    lightnessBase: 55,
                    lightnessRange: 35, // Will range from (55-35) to (55+35) = 20-90%
                    bg: '#000000',
                    opacity: 0.9,
                    baseHues: [180, 300, 60, 120, 340], // cyan, magenta, yellow, lime, pink
                    sizeMultiplierBase: 1.0,
                    sizeMultiplierRange: 1.5, // Will multiply size by 1.0-2.5x
                    movementBase: 150,
                    movementMultiplier: 300
                },
                glitch: {
                    bg: '#000000',
                    opacity: 0.85,
                    colors: ['#FF0000', '#00FFFF', '#FF00FF', '#00FF00'], // R, C, M, G
                    channelSeparationBase: 2,
                    channelSeparationMultiplier: 12, // Bass increases RGB separation
                    glitchIntensityMultiplier: 8, // Mids control random displacement
                    quantizationBase: 1,
                    quantizationMultiplier: 8 // Highs increase pixelation
                }
            }
        };

        // ===== STATE =====
        const state = {
            // User settings
            settings: {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.3,
                density: 'medium',
                gradient: 'default',
                mode: 'hole',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0
            },

            // Audio
            audioContext: null,
            analyser: null,
            microphone: null,
            dataArray: null,
            bufferLength: 0,
            isActive: false,

            // Wave grid
            paths: [],
            lines: [],
            noise: null,
            boundingRect: null,
            transitioning: false,
            transitionProgress: 1.0,

            // Mouse tracking
            mouse: {
                x: -10,
                y: 0,
                lx: 0,
                ly: 0,
                sx: 0,
                sy: 0,
                v: 0,
                vs: 0,
                a: 0,
                set: false,
                onScreen: false
            },

            // Control visibility
            controlsVisible: true,
            idleTimeout: null,

            // Audio levels (for theme renderers)
            audioLevels: {
                low: 0,
                mid: 0,
                high: 0
            },
            currentTime: 0,

            // User-created gradient centers (for NEON theme)
            userGradientCenters: [],

            // GLITCH theme image state
            glitchImage: {
                img: null,
                loaded: false,
                width: 400,
                height: 300,
                x: 0,
                y: 0,
                rotation3D: { x: 0, y: 0, z: 0 },
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragStartWidth: 0,
                dragStartHeight: 0
            }
        };

        // =====================================================
        // INITIALIZATION
        // =====================================================

        async function init() {
            console.log('üé® Initializing Soundscape...');

            // Initialize noise generator
            state.noise = createNoise2D();

            // Setup wave grid
            setupWaveGrid();

            // Setup all controls
            setupControls();

            // Auto-start audio capture
            await startAudioCapture();
        }

        // =====================================================
        // WAVE GRID SETUP
        // =====================================================

        function setupWaveGrid() {
            // Store old grid for transition
            const oldLines = state.lines.length > 0 ? state.lines.map(line =>
                line.map(p => ({ x: p.x, y: p.y }))
            ) : null;

            // Get container dimensions
            state.boundingRect = elements.container.getBoundingClientRect();
            const { width, height } = state.boundingRect;

            // Set SVG dimensions
            elements.svg.style.width = `${width}px`;
            elements.svg.style.height = `${height}px`;
            elements.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Get density settings
            const density = config.densityPresets[state.settings.density];
            const { xGap, yGap } = density;

            // Calculate grid dimensions - oversized to hide edges
            const padding = 400; // Increased padding to ensure edges are never visible
            const oWidth = width + padding;
            const oHeight = height + padding;
            const totalLines = Math.ceil(oWidth / xGap);
            const totalPoints = Math.ceil(oHeight / yGap);
            const xStart = (width - xGap * totalLines) / 2;
            const yStart = (height - yGap * totalPoints) / 2;

            console.log(`üìä Creating ${totalLines} lines with ${totalPoints} points each`);

            // Check if we need to rebuild or just transition
            const needsRebuild = state.lines.length !== totalLines ||
                                (state.lines.length > 0 && state.lines[0].length !== totalPoints);

            if (needsRebuild) {
                // Clear existing grid
                state.paths.forEach(path => path.remove());
                state.paths = [];
                state.lines = [];

                // Create grid lines
                for (let i = 0; i < totalLines; i++) {
                    const points = [];

                    // Create points for this line
                    for (let j = 0; j < totalPoints; j++) {
                        const targetX = xStart + xGap * i;
                        const targetY = yStart + yGap * j;

                        // Try to find nearest old point for smooth transition
                        let startX = targetX;
                        let startY = targetY;

                        if (oldLines && oldLines.length > 0) {
                            const oldLineIndex = Math.min(i, oldLines.length - 1);
                            const oldLine = oldLines[oldLineIndex];
                            if (oldLine && oldLine.length > 0) {
                                const oldPointIndex = Math.min(j, oldLine.length - 1);
                                startX = oldLine[oldPointIndex].x;
                                startY = oldLine[oldPointIndex].y;
                            }
                        }

                        points.push({
                            x: startX,
                            y: startY,
                            targetX: targetX,
                            targetY: targetY,
                            wave: { x: 0, y: 0 },
                            cursor: { x: 0, y: 0, vx: 0, vy: 0 },
                            audio: { x: 0, y: 0 }
                        });
                    }

                    // Create SVG path
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-width', '1');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('opacity', '0.6');
                    elements.svg.appendChild(path);

                    state.paths.push(path);
                    state.lines.push(points);
                }

                // Start transition if we had an old grid
                if (oldLines) {
                    state.transitioning = true;
                    state.transitionProgress = 0.0;
                }
            } else {
                // Just update target positions
                for (let i = 0; i < totalLines; i++) {
                    for (let j = 0; j < totalPoints; j++) {
                        const p = state.lines[i][j];
                        p.targetX = xStart + xGap * i;
                        p.targetY = yStart + yGap * j;
                    }
                }

                state.transitioning = true;
                state.transitionProgress = 0.0;
            }

            // Apply colors
            updateColors();
        }

        function updateModeVisibility() {
            const modeSection = document.getElementById('modeSection');
            const neonControlsSection = document.getElementById('neonControlsSection');
            const glitchControlsSection = document.getElementById('glitchControlsSection');
            const uploadOverlay = document.getElementById('upload-overlay');

            if (modeSection) {
                // Only show mode selection for LINEAR theme
                modeSection.style.display = state.settings.theme === 'linear' ? 'block' : 'none';
            }

            if (neonControlsSection) {
                // Only show NEON controls for NEON theme
                neonControlsSection.style.display = state.settings.theme === 'neon' ? 'block' : 'none';
            }

            if (glitchControlsSection) {
                // Only show GLITCH controls for GLITCH theme
                glitchControlsSection.style.display = state.settings.theme === 'glitch' ? 'block' : 'none';
            }

            if (uploadOverlay) {
                // Show upload overlay for GLITCH theme when no image is loaded
                const shouldShowOverlay = state.settings.theme === 'glitch' && !state.glitchImage.loaded;
                uploadOverlay.style.display = shouldShowOverlay ? 'flex' : 'none';
            }
        }

        function updateColors() {
            const theme = config.themes[state.settings.theme];

            // Update background
            document.body.style.background = theme.bg;

            // Update mode visibility based on theme
            updateModeVisibility();

            // Update line colors based on theme
            if (state.settings.theme === 'linear') {
                // Linear uses gradient colors
                state.paths.forEach((path, i) => {
                    const progress = i / state.paths.length;
                    const colorIndex = Math.floor(progress * theme.colors.length);
                    const color = theme.colors[Math.min(colorIndex, theme.colors.length - 1)];
                    path.setAttribute('stroke', color);
                    path.removeAttribute('filter');
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'neon') {
                // Neon theme colors are set dynamically in drawLinesNeon
                // Just ensure paths are ready
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            } else if (state.settings.theme === 'glitch') {
                // Glitch theme colors are set dynamically in drawLinesGlitch
                // Reset path attributes
                state.paths.forEach((path) => {
                    path.setAttribute('opacity', theme.opacity);
                });
            }
        }

        // =====================================================
        // AUDIO CAPTURE
        // =====================================================

        async function startAudioCapture() {
            try {
                console.log('üé§ Requesting microphone access...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Setup audio context
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.microphone = state.audioContext.createMediaStreamSource(stream);

                // Configure analyser
                state.analyser.fftSize = config.fftSize;
                state.analyser.smoothingTimeConstant = state.settings.smoothing;
                state.bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(state.bufferLength);

                // Connect audio graph
                state.microphone.connect(state.analyser);

                // Update UI
                state.isActive = true;
                elements.loading.classList.add('hidden');
                elements.statusBar.classList.add('active');

                console.log('‚úÖ Audio capture started');
                console.log('üé§ Analyser config:', {
                    fftSize: state.analyser.fftSize,
                    bufferLength: state.bufferLength,
                    smoothing: state.analyser.smoothingTimeConstant
                });

                // Start idle timeout for controls
                showControls();

                // Start animation loop
                requestAnimationFrame(animate);

            } catch (err) {
                console.error('‚ùå Microphone access denied:', err);
                elements.loading.classList.add('hidden');
                elements.error.classList.add('show');
            }
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate(time = 0) {
            if (!state.isActive) return;

            // Update mouse smoothing
            updateMouse();

            // Move all points
            movePoints(time);

            // Draw all lines
            drawLines();

            // Continue loop
            requestAnimationFrame(animate);
        }

        function updateMouse() {
            const m = state.mouse;

            // Smooth mouse position
            m.sx += (m.x - m.sx) * 0.1;
            m.sy += (m.y - m.sy) * 0.1;

            // Calculate velocity
            const dx = m.x - m.lx;
            const dy = m.y - m.ly;
            const distance = Math.hypot(dx, dy);

            m.v = distance;
            m.vs += (distance - m.vs) * 0.1;
            m.vs = Math.min(100, m.vs);

            // Store last position
            m.lx = m.x;
            m.ly = m.y;

            // Calculate angle
            m.a = Math.atan2(dy, dx);
        }

        function movePoints(time) {
            // Store time for theme renderers
            state.currentTime = time;

            // Handle grid transition animation
            if (state.transitioning) {
                state.transitionProgress += 0.05; // Smooth transition speed
                if (state.transitionProgress >= 1.0) {
                    state.transitionProgress = 1.0;
                    state.transitioning = false;
                }

                // Interpolate all points to their target positions
                const easeProgress = easeInOutCubic(state.transitionProgress);
                state.lines.forEach((points) => {
                    points.forEach((p) => {
                        if (p.targetX !== undefined && p.targetY !== undefined) {
                            p.x += (p.targetX - p.x) * easeProgress * 0.2;
                            p.y += (p.targetY - p.y) * easeProgress * 0.2;
                        }
                    });
                });
            }

            // Get audio frequency data
            let lowSum = 0, midSum = 0, highSum = 0;

            if (state.analyser) {
                state.analyser.getByteFrequencyData(state.dataArray);

                for (let i = 0; i < state.bufferLength; i++) {
                    const value = state.dataArray[i];
                    if (i < state.bufferLength * 0.3) lowSum += value;
                    else if (i < state.bufferLength * 0.7) midSum += value;
                    else highSum += value;
                }
            }

            // Calculate frequency levels with emphasis
            const lowLevel = (lowSum / (state.bufferLength * 0.3) / 255) * state.settings.lowEmphasis;
            const midLevel = (midSum / (state.bufferLength * 0.4) / 255) * state.settings.midEmphasis;
            const highLevel = (highSum / (state.bufferLength * 0.3) / 255) * state.settings.highEmphasis;

            // Store audio levels for theme renderers
            state.audioLevels.low = lowLevel;
            state.audioLevels.mid = midLevel;
            state.audioLevels.high = highLevel;

            // Debug logging (every 60 frames ~= 1 second)
            if (Math.random() < 0.016) {
                console.log('üéµ Audio Levels:', {
                    low: lowLevel.toFixed(3),
                    mid: midLevel.toFixed(3),
                    high: highLevel.toFixed(3),
                    lowSum,
                    midSum,
                    highSum
                });
            }

            // Bass creates global background shift - more dramatic
            const bassShiftX = Math.sin(time * 0.001) * lowLevel * 60 * state.settings.intensity;
            const bassShiftY = Math.cos(time * 0.0015) * lowLevel * 50 * state.settings.intensity;

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // MODE-DEPENDENT BEHAVIOR
            let midCursorX, midCursorY, highCursorX, highCursorY;

            if (state.settings.mode === 'hole') {
                // HOLE MODE: Follow cursor if on screen, random if not
                if (state.mouse.onScreen) {
                    midCursorX = state.mouse.sx;
                    midCursorY = state.mouse.sy;
                    highCursorX = state.mouse.sx;
                    highCursorY = state.mouse.sy;
                } else {
                    // Random virtual cursor positions
                    midCursorX = canvasWidth * 0.3 + Math.sin(time * 0.002) * midLevel * 200;
                    midCursorY = canvasHeight * 0.5 + Math.cos(time * 0.003) * midLevel * 150;

                    highCursorX = canvasWidth * 0.7 + Math.sin(time * 0.0025) * highLevel * 250;
                    highCursorY = canvasHeight * 0.5 + Math.cos(time * 0.002) * highLevel * 200;
                }
            }

            // CRUNCH MODE: Calculate wave front positions
            const crunchMidAngle = time * 0.0008 + state.noise(time * 0.0002, 0) * Math.PI * 2;
            const crunchHighAngle = time * 0.001 + state.noise(time * 0.0003, 100) * Math.PI * 2;
            const crunchMidOffset = Math.sin(time * 0.0005) * canvasWidth * 0.5;
            const crunchHighOffset = Math.sin(time * 0.0007) * canvasWidth * 0.5;

            // Update all points
            state.lines.forEach((points) => {
                points.forEach((p) => {
                    // 1. Base wave motion (simplex noise)
                    const timeScale = time * 0.008 * state.settings.speed;
                    const noiseValue = state.noise(
                        (p.x + timeScale) * 0.003,
                        (p.y + timeScale * 0.375) * 0.002
                    ) * 8;

                    p.wave.x = Math.cos(noiseValue) * config.waveAmplitude + bassShiftX;
                    p.wave.y = Math.sin(noiseValue) * (config.waveAmplitude * 0.5) + bassShiftY;

                    let midForceX = 0;
                    let midForceY = 0;
                    let highForceX = 0;
                    let highForceY = 0;

                    if (state.settings.mode === 'hole') {
                        // HOLE MODE: Radial ripples from cursor position
                        // 2. Mids create ripple effect - MORE DRAMATIC
                        const midDx = p.x - midCursorX;
                        const midDy = p.y - midCursorY;
                        const midDist = Math.hypot(midDx, midDy);
                        const midRadius = 400 * midLevel;

                        if (midDist < midRadius && midDist > 0) {
                            const midStrength = (1 - midDist / midRadius) * midLevel;
                            const angle = Math.atan2(midDy, midDx);
                            midForceX = Math.cos(angle) * midStrength * 120 * state.settings.intensity;
                            midForceY = Math.sin(angle) * midStrength * 120 * state.settings.intensity;
                        }

                        // 3. Highs create sharper ripple effect - MORE DRAMATIC
                        const highDx = p.x - highCursorX;
                        const highDy = p.y - highCursorY;
                        const highDist = Math.hypot(highDx, highDy);
                        const highRadius = 250 * highLevel;

                        if (highDist < highRadius && highDist > 0) {
                            const highStrength = (1 - highDist / highRadius) * highLevel;
                            const angle = Math.atan2(highDy, highDx);
                            highForceX = Math.cos(angle) * highStrength * 150 * state.settings.intensity;
                            highForceY = Math.sin(angle) * highStrength * 150 * state.settings.intensity;
                        }
                    } else {
                        // CRUNCH MODE: Directional wave sweep across screen - MORE DRAMATIC
                        // Calculate distance from wave front for mids
                        const midWaveX = Math.cos(crunchMidAngle);
                        const midWaveY = Math.sin(crunchMidAngle);
                        const midDistFromFront = (p.x - canvasWidth * 0.5) * midWaveX + (p.y - canvasHeight * 0.5) * midWaveY + crunchMidOffset;
                        const midWaveWidth = 500;

                        if (Math.abs(midDistFromFront) < midWaveWidth) {
                            const midStrength = (1 - Math.abs(midDistFromFront) / midWaveWidth) * midLevel;
                            const perpAngle = crunchMidAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.01, p.y * 0.01 + time * 0.001) > 0 ? 1 : -1;
                            midForceX = Math.cos(perpAngle) * midStrength * 180 * state.settings.intensity * waveDir;
                            midForceY = Math.sin(perpAngle) * midStrength * 180 * state.settings.intensity * waveDir;
                        }

                        // Calculate distance from wave front for highs
                        const highWaveX = Math.cos(crunchHighAngle);
                        const highWaveY = Math.sin(crunchHighAngle);
                        const highDistFromFront = (p.x - canvasWidth * 0.5) * highWaveX + (p.y - canvasHeight * 0.5) * highWaveY + crunchHighOffset;
                        const highWaveWidth = 400;

                        if (Math.abs(highDistFromFront) < highWaveWidth) {
                            const highStrength = (1 - Math.abs(highDistFromFront) / highWaveWidth) * highLevel;
                            const perpAngle = crunchHighAngle + Math.PI * 0.5;
                            const waveDir = state.noise(p.x * 0.015, p.y * 0.015 + time * 0.0015) > 0 ? 1 : -1;
                            highForceX = Math.cos(perpAngle) * highStrength * 220 * state.settings.intensity * waveDir;
                            highForceY = Math.sin(perpAngle) * highStrength * 220 * state.settings.intensity * waveDir;
                        }
                    }

                    // Combine audio forces
                    p.audio.x = midForceX + highForceX;
                    p.audio.y = midForceY + highForceY;

                    // 4. Mouse interaction
                    const dx = p.x - state.mouse.sx;
                    const dy = p.y - state.mouse.sy;
                    const distance = Math.hypot(dx, dy);
                    const influenceRadius = Math.max(config.cursorRadius, state.mouse.vs);

                    if (distance < influenceRadius) {
                        const strength = 1 - distance / influenceRadius;
                        const force = Math.cos(distance * 0.001) * strength;

                        p.cursor.vx += Math.cos(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                        p.cursor.vy += Math.sin(state.mouse.a) * force * influenceRadius * state.mouse.vs * config.cursorInfluence;
                    }

                    // Apply physics
                    p.cursor.vx += (0 - p.cursor.x) * config.restoration;
                    p.cursor.vy += (0 - p.cursor.y) * config.restoration;
                    p.cursor.vx *= config.damping;
                    p.cursor.vy *= config.damping;

                    p.cursor.x += p.cursor.vx;
                    p.cursor.y += p.cursor.vy;

                    // Limit displacement
                    p.cursor.x = Math.min(50, Math.max(-50, p.cursor.x));
                    p.cursor.y = Math.min(50, Math.max(-50, p.cursor.y));
                });
            });
        }

        // =====================================================
        // THEME RENDERERS
        // =====================================================

        function drawLinesLinear() {
            const theme = config.themes.linear;
            const { low, mid, high } = state.audioLevels;

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Calculate overall audio energy for dramatic effect
            const totalEnergy = (low + mid + high) / 3;
            const dynamicOpacity = theme.opacity + totalEnergy * theme.opacityMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                // Start path
                const firstPoint = points[0];
                let pathData = `M ${
                    firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x
                } ${
                    firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y
                }`;

                // Draw line segments
                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = p.x + p.wave.x + p.cursor.x + p.audio.x;
                    const y = p.y + p.wave.y + p.cursor.y + p.audio.y;
                    pathData += ` L ${x} ${y}`;
                }

                // Update path with dynamic opacity
                const path = state.paths[lineIndex];
                path.setAttribute('d', pathData);
                path.removeAttribute('filter');
                path.removeAttribute('transform');
                path.setAttribute('opacity', Math.min(1.0, dynamicOpacity));
            });
        }

        function drawLinesNeon() {
            const theme = config.themes.neon;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Hide all line paths for NEON theme
            state.paths.forEach(path => {
                path.setAttribute('d', '');
                path.setAttribute('opacity', '0');
            });

            // Get canvas dimensions
            const canvasWidth = state.boundingRect.width;
            const canvasHeight = state.boundingRect.height;

            // Get or create gradient mesh container
            let gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (!gradientMeshGroup) {
                gradientMeshGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gradientMeshGroup.setAttribute('id', 'neon-gradient-mesh');
                elements.svg.appendChild(gradientMeshGroup);
            }

            // Calculate audio-reactive parameters
            const hueShift = (mid * 360 + time * 0.05) % 360;
            const saturation = theme.saturationBase + high * theme.saturationMultiplier;

            // Lightness: Low frequencies darken, high frequencies brighten
            // Range from 20% (dark) to 90% (bright)
            const lightnessFromLow = -low * theme.lightnessRange * 0.5; // Darken with bass
            const lightnessFromHigh = high * theme.lightnessRange * 0.7; // Brighten with highs
            const lightness = theme.lightnessBase + lightnessFromLow + lightnessFromHigh;

            // Movement: More dramatic with bass
            const movementAmplitude = theme.movementBase + low * theme.movementMultiplier;

            // Size: Dramatic pulsing with all frequencies combined
            const combinedEnergy = (low * 0.5 + mid * 0.3 + high * 0.2);
            const sizeMultiplier = theme.sizeMultiplierBase + combinedEnergy * theme.sizeMultiplierRange;

            // Debug logging for NEON renderer (every ~1 second)
            if (Math.random() < 0.016) {
                console.log('üé® NEON Render:', {
                    audioLevels: { low, mid, high },
                    hueShift: hueShift.toFixed(1),
                    saturation: saturation.toFixed(1),
                    lightness: lightness.toFixed(1),
                    movementAmplitude: movementAmplitude.toFixed(1),
                    sizeMultiplier: sizeMultiplier.toFixed(2)
                });
            }

            // Create multiple gradient centers for organic look
            const numBaseCenters = theme.baseHues.length;
            const numUserCenters = state.userGradientCenters.length;

            // Get or create gradient definitions in defs
            let defsElement = elements.svg.querySelector('defs');
            if (!defsElement) {
                defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                elements.svg.insertBefore(defsElement, elements.svg.firstChild);
            }

            // Clear and recreate gradient mesh
            gradientMeshGroup.innerHTML = '';

            // Render base gradient centers
            for (let i = 0; i < numBaseCenters; i++) {
                // Calculate organic position using noise
                const noiseX = state.noise(time * 0.0005 + i * 10, i * 20) * movementAmplitude;
                const noiseY = state.noise(time * 0.0007 + i * 15, i * 25 + 100) * movementAmplitude;

                // Base position distributed around the screen
                const baseX = canvasWidth * (0.2 + (i / numBaseCenters) * 0.6);
                const baseY = canvasHeight * (0.3 + Math.sin(i * 2) * 0.4);

                const cx = baseX + noiseX;
                const cy = baseY + noiseY;

                // Calculate size based on audio and position
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.6;
                const radius = baseRadius * sizeMultiplier * state.settings.burstSize;

                // Create radial gradient for this center
                const gradientId = `neon-radial-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Calculate hue for this center
                const baseHue = theme.baseHues[i];
                const hue = (baseHue + hueShift) % 360;

                // Create gradient stops for smooth fade
                const stops = [
                    { offset: '0%', opacity: 0.8 },
                    { offset: '40%', opacity: 0.6 },
                    { offset: '70%', opacity: 0.3 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Render user-created gradient centers
            for (let i = 0; i < numUserCenters; i++) {
                const userCenter = state.userGradientCenters[i];
                const cx = userCenter.x;
                const cy = userCenter.y;

                // Calculate size - larger for user centers to make them more prominent
                const baseRadius = Math.max(canvasWidth, canvasHeight) * 0.5;
                const radius = baseRadius * sizeMultiplier * 1.2 * state.settings.burstSize; // 20% larger + burst size

                // Create radial gradient for this user center
                const gradientId = `neon-user-${i}`;
                let gradient = defsElement.querySelector(`#${gradientId}`);
                if (!gradient) {
                    gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    defsElement.appendChild(gradient);
                }

                gradient.setAttribute('cx', '50%');
                gradient.setAttribute('cy', '50%');
                gradient.setAttribute('r', '50%');

                // Use a different hue based on user center index
                const userHue = (theme.baseHues[i % theme.baseHues.length] + hueShift + 45) % 360;

                // Create gradient stops with higher initial opacity for user centers
                const stops = [
                    { offset: '0%', opacity: 0.95 },
                    { offset: '30%', opacity: 0.75 },
                    { offset: '60%', opacity: 0.4 },
                    { offset: '100%', opacity: 0 }
                ];

                gradient.innerHTML = '';
                stops.forEach(stop => {
                    const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stopElement.setAttribute('offset', stop.offset);
                    stopElement.setAttribute('stop-color', `hsl(${userHue}, ${saturation}%, ${lightness}%)`);
                    stopElement.setAttribute('stop-opacity', stop.opacity);
                    gradient.appendChild(stopElement);
                });

                // Create circle with gradient fill
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', `url(#${gradientId})`);
                circle.setAttribute('filter', 'url(#neon-glow)');

                gradientMeshGroup.appendChild(circle);
            }

            // Update glow filter based on bass
            const blurRadius = theme.blurBase + low * theme.blurMultiplier;
            const filter = elements.svg.querySelector('#neon-glow');
            if (filter) {
                const blur1 = filter.querySelector('feGaussianBlur[result="blur1"]');
                const blur2 = filter.querySelector('feGaussianBlur[result="blur2"]');
                const blur3 = filter.querySelector('feGaussianBlur[result="blur3"]');

                if (blur1) blur1.setAttribute('stdDeviation', blurRadius * 0.5);
                if (blur2) blur2.setAttribute('stdDeviation', blurRadius);
                if (blur3) blur3.setAttribute('stdDeviation', blurRadius * 1.5);

                // Debug blur values
                if (Math.random() < 0.016) {
                    console.log('‚ú® Blur Filter:', {
                        low,
                        blurRadius: blurRadius.toFixed(2),
                        blur1: (blurRadius * 0.5).toFixed(2),
                        blur2: blurRadius.toFixed(2),
                        blur3: (blurRadius * 1.5).toFixed(2)
                    });
                }
            }
        }

        function drawLinesGlitch() {
            const theme = config.themes.glitch;
            const { low, mid, high } = state.audioLevels;
            const time = state.currentTime;

            // Hide NEON gradient mesh if it exists
            const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
            if (gradientMeshGroup) {
                gradientMeshGroup.innerHTML = '';
            }

            // Get canvas element
            const canvas = document.getElementById('glitch-canvas');
            if (!canvas) return;

            // Check if image is loaded
            if (state.glitchImage.loaded && state.glitchImage.img) {
                // IMAGE-BASED RENDERING
                renderGlitchImage(canvas, theme, low, mid, high, time);
            } else {
                // LINE-BASED RENDERING (fallback)
                // Hide canvas
                canvas.style.display = 'none';

                renderGlitchLines(theme, low, mid, high);
            }
        }

        function renderGlitchImage(canvas, theme, low, mid, high, time) {
            const ctx = canvas.getContext('2d');
            const img = state.glitchImage.img;

            // Show canvas
            canvas.style.display = 'block';

            // Hide SVG lines
            state.paths.forEach(path => {
                path.setAttribute('d', '');
                path.setAttribute('opacity', '0');
            });

            // Clean up glitch paths
            const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
            allGlitchPaths.forEach(path => path.remove());

            // Set canvas size and position
            canvas.width = state.glitchImage.width;
            canvas.height = state.glitchImage.height;
            canvas.style.left = `${state.glitchImage.x}px`;
            canvas.style.top = `${state.glitchImage.y}px`;

            // Calculate glitch parameters with user intensity multipliers
            const glitchEffectIntensity = state.settings.glitchEffectIntensity;
            const channelSeparation = (theme.channelSeparationBase + low * theme.channelSeparationMultiplier) * glitchEffectIntensity;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier * glitchEffectIntensity;
            const quantization = Math.max(1, (theme.quantizationBase + high * theme.quantizationMultiplier) * glitchEffectIntensity);

            // Calculate 3D rotation based on audio with user intensity multiplier
            const rotationIntensity = state.settings.rotationIntensity;
            const rotationX = mid * 45 * rotationIntensity; // Mids control pitch (X-axis rotation)
            const rotationY = high * 45 * rotationIntensity; // Highs control yaw (Y-axis rotation)
            const rotationZ = low * 15 * rotationIntensity; // Bass controls roll (Z-axis rotation)

            // Apply 3D transform to canvas
            const perspective = 1000;
            canvas.style.transformStyle = 'preserve-3d';
            canvas.style.transform = `perspective(${perspective}px) rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply quantization/pixelation by scaling down and up
            const pixelSize = Math.max(1, Math.floor(quantization));
            const scaledWidth = Math.floor(canvas.width / pixelSize);
            const scaledHeight = Math.floor(canvas.height / pixelSize);

            // Create temporary canvas for RGB channel separation
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw pixelated base image
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            tempCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight, 0, 0, canvas.width, canvas.height);

            // Get image data for RGB channel manipulation
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply random glitch displacement to scan lines
            const scanlineGlitchChance = mid * 0.2;
            for (let y = 0; y < canvas.height; y++) {
                if (Math.random() < scanlineGlitchChance) {
                    const offset = Math.floor((Math.random() - 0.5) * glitchIntensity * 20);
                    if (offset !== 0) {
                        const rowStart = y * canvas.width * 4;
                        const rowData = data.slice(rowStart, rowStart + canvas.width * 4);

                        for (let x = 0; x < canvas.width; x++) {
                            const sourceX = Math.max(0, Math.min(canvas.width - 1, x - offset));
                            const sourceIdx = sourceX * 4;
                            const targetIdx = rowStart + x * 4;

                            data[targetIdx] = rowData[sourceIdx];
                            data[targetIdx + 1] = rowData[sourceIdx + 1];
                            data[targetIdx + 2] = rowData[sourceIdx + 2];
                            data[targetIdx + 3] = rowData[sourceIdx + 3];
                        }
                    }
                }
            }

            // Create three canvases for RGB channel separation
            const redCanvas = document.createElement('canvas');
            redCanvas.width = canvas.width;
            redCanvas.height = canvas.height;
            const redCtx = redCanvas.getContext('2d');

            const greenCanvas = document.createElement('canvas');
            greenCanvas.width = canvas.width;
            greenCanvas.height = canvas.height;
            const greenCtx = greenCanvas.getContext('2d');

            const blueCanvas = document.createElement('canvas');
            blueCanvas.width = canvas.width;
            blueCanvas.height = canvas.height;
            const blueCtx = blueCanvas.getContext('2d');

            // Extract individual color channels
            const redData = ctx.createImageData(canvas.width, canvas.height);
            const greenData = ctx.createImageData(canvas.width, canvas.height);
            const blueData = ctx.createImageData(canvas.width, canvas.height);

            for (let i = 0; i < data.length; i += 4) {
                // Red channel
                redData.data[i] = data[i];
                redData.data[i + 1] = 0;
                redData.data[i + 2] = 0;
                redData.data[i + 3] = data[i + 3];

                // Green channel
                greenData.data[i] = 0;
                greenData.data[i + 1] = data[i + 1];
                greenData.data[i + 2] = 0;
                greenData.data[i + 3] = data[i + 3];

                // Blue channel
                blueData.data[i] = 0;
                blueData.data[i + 1] = 0;
                blueData.data[i + 2] = data[i + 2];
                blueData.data[i + 3] = data[i + 3];
            }

            redCtx.putImageData(redData, 0, 0);
            greenCtx.putImageData(greenData, 0, 0);
            blueCtx.putImageData(blueData, 0, 0);

            // Composite the channels with separation
            ctx.globalCompositeOperation = 'lighter';

            // Red channel (offset left)
            ctx.drawImage(redCanvas, -channelSeparation, 0);

            // Green channel (centered)
            ctx.drawImage(greenCanvas, 0, 0);

            // Blue channel (offset right and down)
            ctx.drawImage(blueCanvas, channelSeparation, channelSeparation * 0.5);

            ctx.globalCompositeOperation = 'source-over';
        }

        function renderGlitchLines(theme, low, mid, high) {
            // Calculate glitch parameters
            const channelSeparation = theme.channelSeparationBase + low * theme.channelSeparationMultiplier;
            const glitchIntensity = mid * theme.glitchIntensityMultiplier;
            const quantization = theme.quantizationBase + high * theme.quantizationMultiplier;

            state.lines.forEach((points, lineIndex) => {
                if (points.length < 2 || !state.paths[lineIndex]) return;

                const path = state.paths[lineIndex];

                // Random glitch displacement per line (controlled by mids)
                const lineGlitch = (Math.random() < mid * 0.3) ? Math.random() * glitchIntensity * 30 : 0;

                // Quantize position (pixelate effect controlled by highs)
                const quantize = (val) => Math.round(val / quantization) * quantization;

                // Build path with quantized positions
                const firstPoint = points[0];
                const fx = quantize(firstPoint.x + firstPoint.wave.x + firstPoint.cursor.x + firstPoint.audio.x + lineGlitch);
                const fy = quantize(firstPoint.y + firstPoint.wave.y + firstPoint.cursor.y + firstPoint.audio.y);

                let pathData = `M ${fx} ${fy}`;

                for (let i = 1; i < points.length; i++) {
                    const p = points[i];
                    const x = quantize(p.x + p.wave.x + p.cursor.x + p.audio.x + lineGlitch);
                    const y = quantize(p.y + p.wave.y + p.cursor.y + p.audio.y);
                    pathData += ` L ${x} ${y}`;
                }

                // RGB Channel Separation - render same path 3 times with color channels offset
                const colorIndex = lineIndex % theme.colors.length;
                const baseColor = theme.colors[colorIndex];

                // Red channel (offset left)
                const pathR = state.paths[lineIndex];
                pathR.setAttribute('d', pathData);
                pathR.setAttribute('stroke', baseColor);
                pathR.setAttribute('opacity', theme.opacity);
                pathR.setAttribute('transform', `translate(${-channelSeparation}, 0)`);
                pathR.removeAttribute('filter');

                // Create or get additional paths for G and B channels
                let pathG = elements.svg.querySelector(`#glitch-g-${lineIndex}`);
                if (!pathG) {
                    pathG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathG.setAttribute('id', `glitch-g-${lineIndex}`);
                    pathG.setAttribute('fill', 'none');
                    pathG.setAttribute('stroke-width', '1');
                    pathG.setAttribute('stroke-linecap', 'round');
                    pathG.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathG);
                }

                let pathB = elements.svg.querySelector(`#glitch-b-${lineIndex}`);
                if (!pathB) {
                    pathB = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathB.setAttribute('id', `glitch-b-${lineIndex}`);
                    pathB.setAttribute('fill', 'none');
                    pathB.setAttribute('stroke-width', '1');
                    pathB.setAttribute('stroke-linecap', 'round');
                    pathB.setAttribute('stroke-linejoin', 'round');
                    elements.svg.appendChild(pathB);
                }

                // Green channel (no offset)
                const greenColor = theme.colors[(colorIndex + 1) % theme.colors.length];
                pathG.setAttribute('d', pathData);
                pathG.setAttribute('stroke', greenColor);
                pathG.setAttribute('opacity', theme.opacity);
                pathG.setAttribute('transform', 'translate(0, 0)');

                // Blue channel (offset right/down)
                const blueColor = theme.colors[(colorIndex + 2) % theme.colors.length];
                pathB.setAttribute('d', pathData);
                pathB.setAttribute('stroke', blueColor);
                pathB.setAttribute('opacity', theme.opacity);
                pathB.setAttribute('transform', `translate(${channelSeparation}, ${channelSeparation * 0.5})`);
            });

            // Clean up extra glitch paths if lines were reduced
            const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
            allGlitchPaths.forEach(path => {
                const match = path.id.match(/glitch-[gb]-(\d+)/);
                if (match && parseInt(match[1]) >= state.lines.length) {
                    path.remove();
                }
            });
        }

        // Theme renderer dispatcher
        const themeRenderers = {
            linear: drawLinesLinear,
            neon: drawLinesNeon,
            glitch: drawLinesGlitch
        };

        function drawLines() {
            const renderer = themeRenderers[state.settings.theme] || drawLinesLinear;
            renderer();
        }

        // =====================================================
        // CONTROL VISIBILITY
        // =====================================================

        function showControls() {
            if (!state.controlsVisible) {
                state.controlsVisible = true;
                elements.statusBar.classList.remove('hidden-control');
                elements.sidebarToggle.classList.remove('hidden-control');
            }

            // Reset idle timeout
            clearTimeout(state.idleTimeout);
            state.idleTimeout = setTimeout(hideControls, 2000); // Hide after 2 seconds of no movement
        }

        function hideControls() {
            // Don't hide if sidebar is open
            const sidebarOpen = elements.sidebar.classList.contains('open');
            if (sidebarOpen) {
                // Restart the timeout to check again later
                state.idleTimeout = setTimeout(hideControls, 2000);
                return;
            }

            state.controlsVisible = false;
            elements.statusBar.classList.add('hidden-control');
            elements.sidebarToggle.classList.add('hidden-control');
        }

        // =====================================================
        // CONTROLS SETUP
        // =====================================================

        function setupControls() {
            // Sidebar toggle
            elements.sidebarToggle.addEventListener('click', () => {
                elements.sidebar.classList.toggle('open');
            });

            // Frequency emphasis sliders
            setupSlider('lowEmphasis', 'lowValue', (value) => {
                state.settings.lowEmphasis = value;
            });

            setupSlider('midEmphasis', 'midValue', (value) => {
                state.settings.midEmphasis = value;
            });

            setupSlider('highEmphasis', 'highValue', (value) => {
                state.settings.highEmphasis = value;
            });

            // Wave settings sliders
            setupSlider('intensitySlider', 'intensityValue', (value) => {
                state.settings.intensity = value;
            });

            setupSlider('speedSlider', 'speedValue', (value) => {
                state.settings.speed = value;
            });

            setupSlider('smoothingSlider', 'smoothingValue', (value) => {
                state.settings.smoothing = value;
                if (state.analyser) {
                    state.analyser.smoothingTimeConstant = value;
                }
            });

            // NEON burst size slider
            setupSlider('burstSizeSlider', 'burstSizeValue', (value) => {
                state.settings.burstSize = value;
            });

            // GLITCH rotation intensity slider
            setupSlider('rotationIntensitySlider', 'rotationIntensityValue', (value) => {
                state.settings.rotationIntensity = value;
            });

            // GLITCH effect intensity slider
            setupSlider('glitchIntensitySlider', 'glitchIntensityValue', (value) => {
                state.settings.glitchEffectIntensity = value;
            });

            // Density options
            document.querySelectorAll('.density-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Handle density change
                    if (option.dataset.density) {
                        document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.density = option.dataset.density;
                        setupWaveGrid();
                    }

                    // Handle mode change
                    if (option.dataset.mode) {
                        document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
                        option.classList.add('active');
                        state.settings.mode = option.dataset.mode;
                        console.log(`üîÑ Mode changed to: ${state.settings.mode.toUpperCase()}`);
                    }
                });
            });

            // Theme selector
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    state.settings.theme = e.target.value;
                    console.log(`üé® Theme changed to: ${state.settings.theme.toUpperCase()}`);

                    // Clean up theme-specific elements
                    const gradientMeshGroup = elements.svg.querySelector('#neon-gradient-mesh');
                    if (gradientMeshGroup) {
                        gradientMeshGroup.innerHTML = '';
                    }

                    // Clean up glitch paths
                    const allGlitchPaths = elements.svg.querySelectorAll('[id^="glitch-"]');
                    allGlitchPaths.forEach(path => path.remove());

                    // Reset path attributes for theme change
                    state.paths.forEach((path) => {
                        path.removeAttribute('filter');
                        path.removeAttribute('transform');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('stroke', '#ffffff');
                    });

                    // Update colors for new theme
                    updateColors();

                    console.log(`‚úÖ Theme switched to ${state.settings.theme.toUpperCase()}`);
                });
            }

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', resetToDefaults);

            // Mouse tracking
            window.addEventListener('mousemove', (e) => {
                state.mouse.x = e.clientX;
                state.mouse.y = e.clientY;
                state.mouse.onScreen = true;

                if (!state.mouse.set) {
                    state.mouse.sx = state.mouse.x;
                    state.mouse.sy = state.mouse.y;
                    state.mouse.lx = state.mouse.x;
                    state.mouse.ly = state.mouse.y;
                    state.mouse.set = true;
                }

                // Show controls on mouse movement
                showControls();
            });

            // Track when mouse leaves the screen
            window.addEventListener('mouseleave', () => {
                state.mouse.onScreen = false;
            });

            window.addEventListener('mouseenter', () => {
                state.mouse.onScreen = true;
            });

            // Window resize
            window.addEventListener('resize', () => {
                setupWaveGrid();
            });

            // Image upload overlay click handler
            const uploadOverlay = document.getElementById('upload-overlay');
            if (uploadOverlay) {
                uploadOverlay.addEventListener('click', () => {
                    // Create hidden file input
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';

                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadImageFile(file);
                        }
                    });

                    document.body.appendChild(fileInput);
                    fileInput.click();
                    document.body.removeChild(fileInput);
                });
            }

            // Drag & drop image upload
            const dragOverlay = document.getElementById('drag-overlay');
            const visualizationContainer = document.getElementById('visualization-container');

            if (visualizationContainer && dragOverlay) {
                // Prevent default drag behavior
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    visualizationContainer.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Show drag overlay when dragging over
                visualizationContainer.addEventListener('dragenter', (e) => {
                    if (state.settings.theme === 'glitch' && !state.glitchImage.loaded) {
                        dragOverlay.style.display = 'flex';
                    }
                });

                visualizationContainer.addEventListener('dragleave', (e) => {
                    // Only hide if we're leaving the container entirely
                    if (e.target === visualizationContainer) {
                        dragOverlay.style.display = 'none';
                    }
                });

                visualizationContainer.addEventListener('drop', (e) => {
                    dragOverlay.style.display = 'none';

                    if (state.settings.theme === 'glitch') {
                        const files = e.dataTransfer.files;
                        if (files.length > 0 && files[0].type.startsWith('image/')) {
                            loadImageFile(files[0]);
                        }
                    }
                });
            }

            // Helper function to load image file
            function loadImageFile(file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        state.glitchImage.img = img;
                        state.glitchImage.loaded = true;
                        state.glitchImage.width = Math.min(img.width, 600);
                        state.glitchImage.height = (state.glitchImage.width / img.width) * img.height;
                        state.glitchImage.x = (state.boundingRect.width - state.glitchImage.width) / 2;
                        state.glitchImage.y = (state.boundingRect.height - state.glitchImage.height) / 2;
                        console.log(`‚úÖ Image loaded: ${img.width}x${img.height}`);

                        // Hide upload overlay
                        updateModeVisibility();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }

            // Click to add gradient centers (NEON theme only)
            window.addEventListener('click', (e) => {
                // Only add gradient centers for NEON theme
                if (state.settings.theme !== 'neon') return;

                // Don't add if clicking on UI elements
                if (e.target.closest('.sidebar') || e.target.closest('.sidebar-toggle')) return;

                // Add new gradient center at click position
                const newCenter = {
                    x: e.clientX,
                    y: e.clientY,
                    createdAt: Date.now()
                };

                state.userGradientCenters.push(newCenter);

                // Keep only the most recent 3 centers
                if (state.userGradientCenters.length > 3) {
                    state.userGradientCenters.shift(); // Remove the oldest
                }

                console.log(`‚ú® Added gradient center at (${e.clientX}, ${e.clientY}). Total: ${state.userGradientCenters.length}`);
            });

            // Click & drag to resize image (GLITCH theme only)
            const glitchCanvas = document.getElementById('glitch-canvas');
            if (glitchCanvas) {
                glitchCanvas.addEventListener('mousedown', (e) => {
                    // Only handle resize for GLITCH theme with loaded image
                    if (state.settings.theme !== 'glitch' || !state.glitchImage.loaded) return;

                    state.glitchImage.isDragging = true;
                    state.glitchImage.dragStartX = e.clientX;
                    state.glitchImage.dragStartY = e.clientY;
                    state.glitchImage.dragStartWidth = state.glitchImage.width;
                    state.glitchImage.dragStartHeight = state.glitchImage.height;

                    glitchCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!state.glitchImage.isDragging) return;

                    // Calculate drag distance
                    const dx = e.clientX - state.glitchImage.dragStartX;
                    const dy = e.clientY - state.glitchImage.dragStartY;
                    const dragDistance = Math.hypot(dx, dy);
                    const dragDirection = dx + dy > 0 ? 1 : -1;

                    // Calculate new size (proportional to drag distance)
                    const scaleFactor = 1 + (dragDirection * dragDistance / 500);
                    const newWidth = Math.max(100, state.glitchImage.dragStartWidth * scaleFactor);
                    const aspectRatio = state.glitchImage.img.height / state.glitchImage.img.width;
                    const newHeight = newWidth * aspectRatio;

                    // Update image dimensions
                    state.glitchImage.width = newWidth;
                    state.glitchImage.height = newHeight;

                    // Re-center the image
                    state.glitchImage.x = (state.boundingRect.width - newWidth) / 2;
                    state.glitchImage.y = (state.boundingRect.height - newHeight) / 2;
                });

                window.addEventListener('mouseup', () => {
                    if (state.glitchImage.isDragging) {
                        state.glitchImage.isDragging = false;
                        glitchCanvas.style.cursor = 'grab';
                        console.log(`üñºÔ∏è Image resized to ${state.glitchImage.width.toFixed(0)}x${state.glitchImage.height.toFixed(0)}`);
                    }
                });
            }
        }

        function setupSlider(sliderId, valueId, callback) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                callback(value);
                valueDisplay.textContent = value.toFixed(1);
            });
        }

        function resetToDefaults() {
            // Reset settings
            state.settings = {
                lowEmphasis: 1.0,
                midEmphasis: 1.0,
                highEmphasis: 1.0,
                intensity: 2.5,
                speed: 1.0,
                smoothing: 0.3,
                density: 'medium',
                gradient: 'default',
                mode: 'hole',
                theme: 'linear',
                burstSize: 1.0,
                rotationIntensity: 1.0,
                glitchEffectIntensity: 1.0
            };

            // Update UI
            document.getElementById('lowEmphasis').value = 1.0;
            document.getElementById('midEmphasis').value = 1.0;
            document.getElementById('highEmphasis').value = 1.0;
            document.getElementById('intensitySlider').value = 2.5;
            document.getElementById('speedSlider').value = 1.0;
            document.getElementById('smoothingSlider').value = 0.3;
            document.getElementById('burstSizeSlider').value = 1.0;
            document.getElementById('rotationIntensitySlider').value = 1.0;
            document.getElementById('glitchIntensitySlider').value = 1.0;

            document.getElementById('lowValue').textContent = '1.0';
            document.getElementById('midValue').textContent = '1.0';
            document.getElementById('highValue').textContent = '1.0';
            document.getElementById('intensityValue').textContent = '2.5';
            document.getElementById('speedValue').textContent = '1.0';
            document.getElementById('smoothingValue').textContent = '0.3';
            document.getElementById('burstSizeValue').textContent = '1.0';
            document.getElementById('rotationIntensityValue').textContent = '1.0';
            document.getElementById('glitchIntensityValue').textContent = '1.0';

            // Update analyser if active
            if (state.analyser) {
                state.analyser.smoothingTimeConstant = 0.3;
            }

            // Clear user-created gradient centers
            state.userGradientCenters = [];

            // Reset density
            document.querySelectorAll('[data-density]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-density="medium"]').classList.add('active');

            // Reset mode
            document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
            document.querySelector('[data-mode="hole"]').classList.add('active');

            // Reset theme
            document.getElementById('themeSelect').value = 'linear';

            // Rebuild grid and colors
            setupWaveGrid();
            updateColors();

            console.log('üîÑ Reset to defaults');
        }

        // =====================================================
        // START APPLICATION
        // =====================================================

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        console.log('üåä Soundscape loaded');
    </script>
</body>
</html>
